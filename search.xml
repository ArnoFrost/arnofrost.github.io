<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Jetpack Compose 中的 remember 函数详解</title>
      <link href="/2024/04/30/Compose-remember%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/04/30/Compose-remember%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Version 1.0</p></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Jetpack Compose 中，有效地管理 UI 组件的状态是至关重要的。要深入理解 <code>remember</code> 函数的重要性，首先需要探讨仅使用 <code>MutableState</code> 而不使用 <code>remember</code> 可能带来的问题。</p><h2 id="MutableState-的陷阱"><a href="#MutableState-的陷阱" class="headerlink" title="MutableState 的陷阱"></a><code>MutableState</code> 的陷阱</h2><p><code>MutableState</code> 对象在 Jetpack Compose 中用于保存可观察数据，其变化能触发 UI 重绘（recompose）。但若不慎使用，即在没有 <code>remember</code> 的情况下使用 <code>MutableState</code>，可能会导致一些难以察觉的问题：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CounterWithoutRemember</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = mutableStateOf(<span class="number">0</span>)</span><br><span class="line">    Button(onClick = &#123; count.value++ &#125;) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Count is <span class="subst">$&#123;count.value&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次 <code>CounterWithoutRemember</code> 重组时，由于 <code>count</code> 没有被 <code>remember</code> 函数包裹，它都会重新初始化为 0。这导致计数器看似在增加，但实际上每次重组后都会重置。<strong>使得界面并没有发生“实际改变”</strong>。</p><h2 id="引入-remember"><a href="#引入-remember" class="headerlink" title="引入 remember"></a>引入 <code>remember</code></h2><p>为了解决上述问题，确保 <code>count</code> 的状态在重组间持久保存，应使用 <code>remember</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CounterWithRemember</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> count = remember &#123; mutableStateOf(<span class="number">0</span>) &#125;</span><br><span class="line">    Button(onClick = &#123; count.value++ &#125;) &#123;</span><br><span class="line">        Text(<span class="string">&quot;Count is <span class="subst">$&#123;count.value&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>remember</code> 确保即使在多次重组后，<code>count</code> 保持其状态，不会重新初始化。</p><h2 id="重组作用域-Recompose-Scope"><a href="#重组作用域-Recompose-Scope" class="headerlink" title="重组作用域 (Recompose Scope)"></a>重组作用域 (Recompose Scope)</h2><p><code>@Composable</code> 函数被视为一个重组作用域。当作用域内的变量发生变化时，整个作用域将被标记为无效，并重新执行以反映最新状态。</p><h2 id="remember-函数详解"><a href="#remember-函数详解" class="headerlink" title="remember 函数详解"></a><code>remember</code> 函数详解</h2><p><code>remember</code> 的目的是解决重组过程中的多次初始化问题，通过保持变量状态跨重组持久存在，避免每次重组时的重新初始化。它确保所包含的初始化代码在 Composable 函数<strong>首次调用时执行一次，并在后续的重组过程中保持状态不变</strong>。</p><h2 id="使用场景与最佳实践"><a href="#使用场景与最佳实践" class="headerlink" title="使用场景与最佳实践"></a>使用场景与最佳实践</h2><ul><li><strong>状态恢复</strong>：适用于创建需要在重组间保持状态但在某些条件下需要重新初始化的状态对象。</li><li><strong>Composable 范围</strong>：<code>remember</code> 应在 <code>@Composable</code> 函数内使用，与重组密切相关。</li><li><strong>选择键</strong>：当 <code>remember</code> 使用键时，如果依赖的数据变化，它将重新计算或更新状态，例如：</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">UserGreeting</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> greeting = remember(name) &#123; <span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span> &#125;</span><br><span class="line">    Text(greeting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此例中，<code>name</code> 的改变将导致 <code>greeting</code> 的重新计算，保证 UI 显示与当前 <code>name</code> 一致。</p><ul><li><strong>避免过度使用键</strong>：虽然键提供了强大的灵活性，但不必为每个 <code>remember</code> 使用键，特别是当状态不依赖于动态数据时。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>remember</code> 是构建高效、可维护和无错误 Compose UI 的关键。它不仅帮助管理状态，还确保 UI 组件能够在合适的时机更新，提升用户体验并减少因状态管理错误导致的 bug，确保应用的稳定性和性能。</p><p>通过合理使用 <code>remember</code> 及其键重载功能，开发者可以在保持性能与逻辑正确性之间找到平衡，构建出响应迅速且可靠的现代 Android 应用。</p><h2 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h2><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 1.0</td><td>2024年04月30日</td><td>初版整理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
          <category> Compose </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compose </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo升级手册</title>
      <link href="/2024/04/30/Hexo%E5%8D%87%E7%BA%A7%E6%89%8B%E5%86%8C/"/>
      <url>/2024/04/30/Hexo%E5%8D%87%E7%BA%A7%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.1</p></blockquote><h2 id="1-SSH-配置"><a href="#1-SSH-配置" class="headerlink" title="1. SSH 配置"></a>1. SSH 配置</h2><p>为了区分不同的 Git 服务，需要配置 SSH 连接。</p><ol><li><p>修改 SSH 配置文件 <code>~/.ssh/config</code>，添加如下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GitHub SSH配置</span></span><br><span class="line">Host github</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    Port 22</span><br><span class="line">    IdentityFile ~/.ssh/github_id_rsa</span><br><span class="line">    IdentitiesOnly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li><li><p>通过以下命令验证 SSH 连接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -vT git@github.com</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2. 环境配置"></a>2. 环境配置</h2><h3 id="macOS-下-NVM-安装"><a href="#macOS-下-NVM-安装" class="headerlink" title="macOS 下 NVM 安装"></a>macOS 下 NVM 安装</h3><ol><li><p>安装 NVM（Node Version Manager）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nvm</span><br></pre></td></tr></table></figure></li><li><p>列出可用的 Node.js 版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm ls-remote</span><br></pre></td></tr></table></figure></li><li><p>安装指定版本的 Node.js：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install xxx</span><br></pre></td></tr></table></figure><p>其中 <code>xxx</code> 选择的 Node.js 版本。</p></li></ol><h2 id="3-Hexo-升级"><a href="#3-Hexo-升级" class="headerlink" title="3. Hexo 升级"></a>3. Hexo 升级</h2><ol><li><p>进入 Hexo 项目目录。</p></li><li><p>查看当前 Hexo 版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure></li><li><p>全局升级 <code>hexo-cli</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure></li><li><p>再次查看版本以确认升级成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>npm-check</code>（如果尚未安装）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check</span><br></pre></td></tr></table></figure></li><li><p>检查项目依赖是否需要升级：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm-check</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>npm-upgrade</code>（如果尚未安装）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-upgrade</span><br></pre></td></tr></table></figure></li><li><p>更新 <code>package.json</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm-upgrade</span><br></pre></td></tr></table></figure></li><li><p>更新全局插件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update -g</span><br></pre></td></tr></table></figure></li><li><p>更新项目依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update --save</span><br></pre></td></tr></table></figure></li><li><p>最后，再次查看 Hexo 版本以确认升级成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-备份当前配置"><a href="#4-备份当前配置" class="headerlink" title="4. 备份当前配置"></a>4. 备份当前配置</h2><ol><li><p><strong>备份 Hexo 目录</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czf hexo_backup_$(<span class="built_in">date</span> +%Y%m%d).tar.gz /path/to/hexo</span><br></pre></td></tr></table></figure><p>替换 <code>/path/to/hexo</code> 为你的 Hexo 项目路径。</p></li></ol><h2 id="5-Troubleshooting"><a href="#5-Troubleshooting" class="headerlink" title="5. Troubleshooting"></a>5. Troubleshooting</h2><p>如果在升级过程中遇到问题，这里提供一些常见问题及其解决方案：</p><h3 id="问题-1-升级后网站样式丢失"><a href="#问题-1-升级后网站样式丢失" class="headerlink" title="问题 1: 升级后网站样式丢失"></a>问题 1: 升级后网站样式丢失</h3><ul><li><strong>可能原因</strong>：主题配置文件未更新或被覆盖。</li><li><strong>解决方案</strong>：恢复主题配置文件的备份，或从主题的源仓库中获取最新的配置文件样本。</li></ul><h3 id="问题-2-插件不兼容"><a href="#问题-2-插件不兼容" class="headerlink" title="问题 2: 插件不兼容"></a>问题 2: 插件不兼容</h3><ul><li><strong>可能原因</strong>：插件不支持新版的 Hexo 或 Node.js。</li><li><strong>解决方案</strong>：<ul><li>检查插件的 GitHub 仓库，看是否有相关的兼容性更新。</li><li>降级不兼容的插件或替换为其他相似功能的插件。</li></ul></li></ul><h2 id="6-版本回退"><a href="#6-版本回退" class="headerlink" title="6. 版本回退"></a>6. 版本回退</h2><ol><li><p><strong>使用 NVM 管理 Node.js 版本</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm use xxx</span><br></pre></td></tr></table></figure><p>其中 <code>xxx</code> 是要回退到的 Node.js 版本号。</p></li><li><p><strong>回退 Hexo 版本</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-cli -g</span><br><span class="line">npm install hexo-cli@x.x.x -g</span><br></pre></td></tr></table></figure><p>其中 <code>x.x.x</code> 是要回退到的 Hexo 版本号。</p></li><li><p><strong>恢复 Hexo 项目文件</strong>：</p><p>使用之前备份的 tar.gz 文件恢复项目。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf hexo_backup_date.tar.gz -C /path/to/hexo</span><br></pre></td></tr></table></figure><p>替换 <code>hexo_backup_date.tar.gz</code> 为备份文件名。</p></li></ol><h2 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h2><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2024年04月30日</td><td>初版整理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂类解决 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录Fragment懒加载的一种优化</title>
      <link href="/2022/08/13/%E8%AE%B0%E5%BD%95Fragment%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%80%E7%A7%8D%E4%BC%98%E5%8C%96/"/>
      <url>/2022/08/13/%E8%AE%B0%E5%BD%95Fragment%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E4%B8%80%E7%A7%8D%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.2</p></blockquote><h1 id="主feed-页面懒加载的渲染优化"><a href="#主feed-页面懒加载的渲染优化" class="headerlink" title="主feed 页面懒加载的渲染优化"></a>主feed 页面懒加载的渲染优化</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>当前新闻主端，主feed页面使用viewpager进行<strong>预加载</strong>，当冷启用户进入后会加载旁边channel的fragment ，其中包括<strong>数据请求</strong>与<strong>UI渲染</strong>。通常情况下主流推荐<strong>懒加载模式</strong>，但是粒度有些<strong>粗</strong>，即将数据请求于渲染逻辑都放在可见时才执行，对于主端feed来说数据请求也可能耗时，同时需要接口曝光请求业务，所以不能直接单纯靠后移动触发时机。<code>（2022-10-27: 后续在开屏广告性能卡顿中实践本方案，已经在灰度中，后续线上效果待观察）</code></p><blockquote><p>本文优化点在于试行探讨能否只在fragment真正可见的时候才进行UI绘制</p></blockquote><h2 id="当前逻辑概述"><a href="#当前逻辑概述" class="headerlink" title="当前逻辑概述"></a>当前逻辑概述</h2><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/16603908026213.jpg"></p><p>目前Fragment的初始化里面进行了<code>initData()</code> <strong>请求数据</strong>， 在收到数据后进行 <strong>UI绘制</strong><br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_77a78ff3e2693b4fc83791da26acb759.jpg"></p><h2 id="改进方法概述"><a href="#改进方法概述" class="headerlink" title="改进方法概述"></a>改进方法概述</h2><ol><li>将原本接收到数据后，执行<code>renderFeedListUI</code>的方法保存到一个任务队列中，先不执行</li><li>执行的触发契机有两个，也就是<code>check</code> 是否fragment可见 如果可见则直接执行渲染，以及当fragment外层被调用adpater的<code>setPrimaryItem</code> 方法时再进行一次<code>check</code></li><li>当渲染任务执行后，移除本次任务</li></ol><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_8ed319a5fb80a08700eaf32b8b0dba5b.jpg"><br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_11db91f9731b97a9c61b9bf11e1ef197.jpg"></p><h2 id="测试对比"><a href="#测试对比" class="headerlink" title="测试对比"></a>测试对比</h2><h3 id="改进前"><a href="#改进前" class="headerlink" title="改进前"></a>改进前</h3><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_0a78793bf9485f7a590e21791bf6e179.jpg"></p><p>当前情况会在收到数据后，执行<code>renderFeedListUI</code>操作，可以看见由于预加载的特性，不可见的两个fragment也执行了ui的操作</p><p>优化前冷启加载主feed时，<code>renderFeedListUI</code>方法耗时检测:<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_9d649f5ded24fb4eddfbeeddc3e8b80a.jpg"></p><h3 id="改进后"><a href="#改进后" class="headerlink" title="改进后"></a>改进后</h3><p>其中可以看到，在收到数据的回调中，只有推荐频道被执行了<code>renderFeedListUI</code>操作，其他两个频道的fragment没有再执行<code>renderFeedListUI</code>，减少了主线程的负担<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_750876ca55fc97882ed425d4b0c39347.jpg"></p><p>优化后冷启加载主feed时，<code>renderFeedListUI</code>方法耗时检测:<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_d6c0eba61848ab8e12f3a5d977197549.jpg"></p><p>由于加载少了两个页面，大体耗时为原来的三分之一，基本符合预期理论</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上实验表现，我们可以试行后续是否可以基于此方向来进一步优化feed的加载体验效果</p><p>同时，Fragment相关的API 在近几年已经进行了优化，大体里面优化解耦了很多于Activity 绑定的逻辑，以及减少了代码复杂度， 其中的懒加载也有优化。 本场景下，官方的推荐解决方案是通过<code>setMaxLifeCycle</code>，这样可以真正依赖onResume的回调时机来判定可见性，减少代码复杂度。</p><p>参考文章:</p><ul><li><a href="https://mp.weixin.qq.com/s/wDk8izBXtCoXVV6_lauJCg">ViewPager中的Fragment如何实现懒加载？</a></li><li><a href="https://mp.weixin.qq.com/s/AcOf0nEMJv8Z9xC8aokm9A">Fragment 这么多 API 被废弃了？</a></li><li><a href="https://developer.android.com/studio/profile/record-traces">Android Profiler</a></li></ul><h1 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h1><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2022年08月13日19:39:10</td><td>初版整理</td></tr><tr><td>version 0.2</td><td>2022年10月27日14:49:30</td><td>更换图床</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 优化 </tag>
            
            <tag> Fragment </tag>
            
            <tag> 懒加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin实用技巧</title>
      <link href="/2022/03/01/Kotlin%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/03/01/Kotlin%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.1</p></blockquote><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>现在主力语言已经完全迁移至Kotlin,日常除了维护老的一些业务模块外，基本全都是Kotlin了。我认为Kotlin是一门偏向生产，提高码字效率的语言。很多时候Kotlin便捷的语法糖能给编程带来更丝滑的体验，但Kotlin依旧有很多的语法糖并不是那么的想当然。这些语法糖多数时候是很甜的，但也可能导致一些不好排查的问题，所以打算写一篇记录一下。</p><h2 id="集合越界判空"><a href="#集合越界判空" class="headerlink" title="集合越界判空"></a>集合越界判空</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = emptyList&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> result = list?.<span class="keyword">get</span>(<span class="number">1</span>) ?: <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>之前真有过，刚接触的时候乍一看没什么问题啊，无脑<code>?</code>就行。结果遇到集合这种还是要判断越界的，那么又<code>if-else</code>，这时候用<code>getOrNull()</code>代替</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> List<span class="type">&lt;T&gt;</span>.<span class="title">getOrNull</span><span class="params">(index: <span class="type">Int</span>)</span></span>: T? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= lastIndex) <span class="keyword">get</span>(index) <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="inline-noinline-crossline"><a href="#inline-noinline-crossline" class="headerlink" title="inline noinline crossline"></a>inline noinline crossline</h2><p>首先写两个方法,打印日志  其中<code>doSomethingElse</code> 是一个被嵌套在<code>doSomething</code>中的<code>Unit</code> 类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(<span class="string">&quot;doSomething start&quot;</span>)</span><br><span class="line">    doSomethingElse()</span><br><span class="line">    print(<span class="string">&quot;doSomething end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomethingElse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(<span class="string">&quot;doSomethingElse&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后传统的<code>crossline</code>做法优化嵌套我们都知道, 但有的时候还真不能随便加.<br>当嵌套的方法有类似return之类的返回时要格外注意:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    print(<span class="string">&quot;doSomething start&quot;</span>)</span><br><span class="line">    doSomethingElse &#123;</span><br><span class="line">        print(<span class="string">&quot;doSomethingElse&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// notice this return</span></span><br><span class="line">    &#125;</span><br><span class="line">    print(<span class="string">&quot;doSomething end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingElse</span><span class="params">(abc: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// I can take function</span></span><br><span class="line">    <span class="comment">// do something else here</span></span><br><span class="line">    <span class="comment">// execute the function</span></span><br><span class="line">    abc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不看字节码情况下,这个<code>return</code>的作用到底会产生什么后果的确是个容易忽略的点,要知道<code>return</code>的作用范围.这段代码的字节码如下?:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> void doSomething() &#123;</span><br><span class="line">    System.<span class="keyword">out</span>.print(<span class="string">&quot;doSomething start&quot;</span>);</span><br><span class="line">    System.<span class="keyword">out</span>.print(<span class="string">&quot;doSomethingElse&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到,并没有<code>end</code>的打印输出后续.</p><p>这个时候就要加入<code>crossinline</code>来配合,避免”非本地返回”</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomethingElse</span><span class="params">(<span class="keyword">crossinline</span> abc: () -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// I can take function</span></span><br><span class="line">    <span class="comment">// do something else here</span></span><br><span class="line">    <span class="comment">// execute the function</span></span><br><span class="line">    abc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JvmOverload注解"><a href="#JvmOverload注解" class="headerlink" title="@JvmOverload注解"></a>@JvmOverload注解</h2><p>其实没有太多好说,只是很多时候利于旧代码模块在调用新的类方法时候可以简化一些东西,安卓中其中一个常用场景在自定义view中可以省略很多:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span>(</span><br><span class="line">context: Context, </span><br><span class="line">attrs: AttributeSet? = <span class="literal">null</span>, </span><br><span class="line">defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span>) : RelativeLayout(context, attrs, defStyleAttr) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h2><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2022年04月11日</td><td>初版整理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac实用技巧</title>
      <link href="/2022/02/18/Mac%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/02/18/Mac%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>version 0.1</p></blockquote><h1 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h1><h2 id="按照类型搜索"><a href="#按照类型搜索" class="headerlink" title="按照类型搜索"></a>按照类型搜索</h2><blockquote><p>kind:(file type)</p></blockquote><p>文件类型搜索运算符可以是<code>image</code>,<code>music</code>,<code>application</code>,<code>text</code>,<code>email</code>,<code>save</code>等。</p><h2 id="搜索特定文件格式匹配"><a href="#搜索特定文件格式匹配" class="headerlink" title="搜索特定文件格式匹配"></a>搜索特定文件格式匹配</h2><blockquote><p>kind:(file format)</p></blockquote><p>文件格式搜索运算符非常直观,<code>jpeg</code>,<code>gif</code>,<code>aiff</code>,<code>pdf</code>,<code>rtf</code>,<code>psd</code>,<code>mp3</code>,<code>zip</code>或基本上任何其他内容文件格式</p><h2 id="搜索文件名和特定文件类型-格式"><a href="#搜索文件名和特定文件类型-格式" class="headerlink" title="搜索文件名和特定文件类型&#x2F;格式"></a>搜索文件名和特定文件类型&#x2F;格式</h2><blockquote><p>kind:(operator) “text to search match”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
          <category> 效率 </category>
          
          <category> Mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin多变量判空</title>
      <link href="/2022/02/09/Kotlin%E5%A4%9A%E5%8F%98%E9%87%8F%E5%88%A4%E7%A9%BA/"/>
      <url>/2022/02/09/Kotlin%E5%A4%9A%E5%8F%98%E9%87%8F%E5%88%A4%E7%A9%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.1 2022年02月09日20:48:26</p></blockquote><p>[TOC]</p><h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>最近梳理了一下自己远古的Kotlin业务代码，在一个Kotlin方法实现里遇到了<strong>两个变量连续判空</strong>的具体写法引发的一个思考。系统整理一下，当做一个有意思的思考点。如果对于Java与Kotlin单变量判空区别已经熟悉，可直接跳到<a href="#%E5%A4%9A%E5%8F%98%E9%87%8F%E5%88%A4%E7%A9%BA">多变量判空</a>部分。</p><blockquote><p>注： 为了方便说明这次的问题，下文将使用编译器截图来突出标明。</p></blockquote><h1 id="单变量的判空"><a href="#单变量的判空" class="headerlink" title="单变量的判空"></a>单变量的判空</h1><h2 id="Kotlin的判空编译期检查"><a href="#Kotlin的判空编译期检查" class="headerlink" title="Kotlin的判空编译期检查"></a>Kotlin的判空编译期检查</h2><p>先从熟悉的位置入手，日常开发中判空是无处不在的，为了维护健壮性很多时候都要引入判空。对于判空的检查，Kotlin 在编译期提供了更严格安全的检查，就是线程安全检查。<br>假设我们分别有一个成员变量与局部变量<code>name</code>与<code>localName</code>进行非空判断并打印长度。<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209192504.png" alt="Java-单变量判空"></p><p>这是我们很常见的判空情况，在Java中很常见。那么如果我们照搬过来写Kotlin 会是怎样？<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209192919.png" alt="Kotlin-单变量判空"></p><p>可以看到对于成员变量的判空，Kotlin在编译期阶段给出了报错提示。<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209193032.png" alt="Kotlin-成员变量判空报错"></p><p>看提示可以知道，Kotlin对于可变的变量是有线程安全检查的，也就是说之前很多时候Java的这种判空都是非线程安全的。多数时候Android开发其实那样写也没有事情，但Kotlin会更加明确的让你知道，提高我们的编程意识。</p><p>在初学时候没有想过太多，想当然那么我就利用<code>!!</code>强制非空来判断，以此达到目的。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209193406.png" alt="Kotlin-强制非空"></p><p>这样编译器是不报错了，但是我们真正的解决提示说的问题了吗？很遗憾并没有解决线程安全的问题，如果涉及多线程那么我们对于这个变量的保护措施就是不够的。</p><h2 id="线程安全的判空"><a href="#线程安全的判空" class="headerlink" title="线程安全的判空"></a>线程安全的判空</h2><p>那么如何来保证线程安全的判空？简单直观的一种方式就是用局部变量来进行判空保护。先贴出写法：</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209194601.png" alt="Java-线程安全判空"></p><p>对于此写法是利用了局部变量的特性来维护值的拷贝，不被其他线程修改的特性。</p><p>针对于此Kotlin才有了诸如<code>?.run、apply、let、with</code>等特性来辅助我们进行快速的线程安全的非空判断。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209194936.png" alt="Kotlin-线程安全单变量判空"></p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209195047.png" alt="Kotlin-let源码"></p><p>以上类似的问题如果展开篇幅也比较多，虽然偏八股文一些但本质上还是会对我们编程安全有很大的启发与指导意义的。详细介绍与思考可以参考下面文章，本篇文章不再展开。<br><a href="https://mp.weixin.qq.com/s/lP-xB5yzpvqVEiA439euVQ">Java的值传递和引用传递，你真的搞清楚了吗？</a></p><h1 id="多变量判空"><a href="#多变量判空" class="headerlink" title="多变量判空"></a>多变量判空</h1><p>回到这篇文章的记录初衷，先看一下原来的代码。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209201746.png" alt="Kotlin-多变量判空原始"><br>这里可以看到首先是非线程安全，如果在特定场景单线程也罢，顶多是一个<code>let</code>的语法糖问题。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209202056.png" alt="Kotlin-多变量判空嵌套"></p><h2 id="多变量嵌套臃肿问题"><a href="#多变量嵌套臃肿问题" class="headerlink" title="多变量嵌套臃肿问题"></a>多变量嵌套臃肿问题</h2><p>但是这样做在面临多变量时就会显得臃肿嵌套变多，而且甚至还不得不这样做。那么能不能简化一下？我也搜索了一下百度，那么看到常见的标题符合我的预期，方法是这样：</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209202316.png" alt="Kotlin-多变量判空资料方法"></p><p>乍一看，符合预期，赶紧试试看。<br>（这里有一个有意思的点，就是我发现项目里之前一位同事已经在公共的Kotlin扩展函数库里添加了这个方法，甚至欣喜若狂原来英雄所见略同）</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209202535.png"></p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209202911.png" alt="Kotlin-判空方法依旧不行"></p><p>这一刻突然有了一些疑惑，为什么还是需要判空？然后仔细看了一下，这方法障眼法太强，本质上还是因为判断时用了函数来屏蔽成员变量，使用时依旧没用局部变量导致了这个判断几乎等同于上面Java原生写法，甚至可以说更繁琐了。</p><h2 id="简易但明确的一种解决方案"><a href="#简易但明确的一种解决方案" class="headerlink" title="简易但明确的一种解决方案"></a>简易但明确的一种解决方案</h2><p>在Kotlin社区的讨论中，发现这个问题在16年时候社区里就有人提出来过，并且下面的讨论也都很精彩对自己也都是个启发，其中不乏就有上面那个网络传闻的解决方案的原版（或许）。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/CleanShot%202022-02-09%20at%2020.36.32.png" alt="Kotlin社区提问"></p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/CleanShot%202022-02-09%20at%2020.38.32.png" alt="Kotlin社区答案之一"><br>点开评论，早就有前辈提出来同样的问题，这个方法仍旧不可行。</p><p>其中的讨论都特别有意思，有人类比Swift与Groovy等语言特性以此来希望官方支持等等。</p><p>最后我才用了一种更“笨”，但我认为更实用的解决方法。<a href="https://discuss.kotlinlang.org/t/kotlin-null-check-for-multiple-nullable-vars/1946/48">Kotlin社区答案原贴</a></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, A, B&gt;</span> <span class="title">withNoNulls</span><span class="params">(p1: <span class="type">A</span>?, p2: <span class="type">B</span>?, function: (<span class="type">p1</span>: <span class="type">A</span>, <span class="type">p2</span>: <span class="type">B</span>) -&gt; <span class="type">R</span>)</span></span>: R? = p1?.let &#123; p2?.let &#123; function.invoke(p1, p2) &#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, A, B, C&gt;</span> <span class="title">withNoNulls</span><span class="params">(p1: <span class="type">A</span>?, p2: <span class="type">B</span>?, p3: <span class="type">C</span>?, function: (<span class="type">p1</span>: <span class="type">A</span>, <span class="type">p2</span>: <span class="type">B</span>, <span class="type">p3</span>: <span class="type">C</span>) -&gt; <span class="type">R</span>)</span></span>: R? = p1?.let &#123; p2?.let &#123; p3?.let &#123; function.invoke(p1, p2, p3) &#125; &#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, A, B, C, D&gt;</span> <span class="title">withNoNulls</span><span class="params">(p1: <span class="type">A</span>?, p2: <span class="type">B</span>?, p3: <span class="type">C</span>?, p4: <span class="type">D</span>?, function: (<span class="type">p1</span>: <span class="type">A</span>, <span class="type">p2</span>: <span class="type">B</span>, <span class="type">p3</span>: <span class="type">C</span>, <span class="type">p4</span>: <span class="type">D</span>) -&gt; <span class="type">R</span>)</span></span>: R? = p1?.let &#123; p2?.let &#123; p3?.let &#123; p4?.let &#123; function.invoke(p1, p2, p3, p4) &#125; &#125; &#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, A, B, C, D, E&gt;</span> <span class="title">withNoNulls</span><span class="params">(p1: <span class="type">A</span>?, p2: <span class="type">B</span>?, p3: <span class="type">C</span>?, p4: <span class="type">D</span>?, p5: <span class="type">E</span>?, function: (<span class="type">p1</span>: <span class="type">A</span>, <span class="type">p2</span>: <span class="type">B</span>, <span class="type">p3</span>: <span class="type">C</span>, <span class="type">p4</span>: <span class="type">D</span>, <span class="type">p5</span>: <span class="type">E</span>) -&gt; <span class="type">R</span>)</span></span>: R? = p1?.let &#123; p2?.let &#123; p3?.let &#123; p4?.let &#123; p5?.let &#123; function.invoke(p1, p2, p3, p4, p5) &#125; &#125; &#125; &#125; &#125;</span><br></pre></td></tr></table></figure><p>而没用varargs是因为泛型的问题，提供到第五个参数的重载应该也足够了。本质上虽然我依旧没有很好消除嵌套的方式，但是利用语法糖特性依旧可以做到在<strong>调用处消除嵌套</strong>的使用现象。如果后续知道并了解后，我会继续更新。</p><p>改造后代码：<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220209204642.png" alt="Kotlin-多变量判空改造后代码"></p><h1 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h1><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2022年02月09日20:48:26</td><td>初版整理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓全局浮层方案调研</title>
      <link href="/2022/02/07/%E5%AE%89%E5%8D%93%E6%B5%AE%E5%B1%82%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/"/>
      <url>/2022/02/07/%E5%AE%89%E5%8D%93%E6%B5%AE%E5%B1%82%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p>为满足开机广告丰富样式，7.76.0新闻客户端接入<code>LongView</code>广告样式。目前的<code>LongView</code>效果实现是复用之前<code>一镜到底</code>的视频缩放动画，与集成了<code>sax</code>广告SDK的倒计时相关组件。最后用单独的一个<code>Activity层级</code>的浮层Window来承载后续小窗内容。</p><p>这样做的方式目前满足了第一版的需求，但是前置动画与小窗目前是侵入式埋点在主页面的<code>onCreate</code>中，后续如果想扩充其他场景需要再继续埋入相应代码，不利于统一维护且容易遗漏，并且当前的浮层不能 <strong>“跨页面”</strong>。</p><h2 id="悬浮窗基本原理"><a href="#悬浮窗基本原理" class="headerlink" title="悬浮窗基本原理"></a>悬浮窗基本原理</h2><p>类似于<strong>动态添加View</strong>，但是由于悬浮窗是不依赖具体某个<code>View</code>的所以需要<code>WindowManager</code>介入。</p><ul><li>获取<code>WindowManger</code></li><li>创建悬浮窗View [可额外处理悬浮窗View的拖拽事件等]</li><li>添加到<code>WindowManager</code>中</li></ul><h2 id="1-应用内添加悬浮窗（页面级别）"><a href="#1-应用内添加悬浮窗（页面级别）" class="headerlink" title="1. 应用内添加悬浮窗（页面级别）"></a>1. 应用内添加悬浮窗（页面级别）</h2><p>优点：方便添加<strong>无需权限</strong>申请，快速创建。<br>缺点：<code>Activity层级</code>无法全局，退后台后不能显示。<br>整体流程伪代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> layoutParam = WindowManager.LayoutParams().apply &#123;</span><br><span class="line">    <span class="comment">//设置大小 自适应</span></span><br><span class="line">    width = WRAP_CONTENT</span><br><span class="line">    height = WRAP_CONTENT</span><br><span class="line">    flags =</span><br><span class="line">        WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新建悬浮窗控件</span></span><br><span class="line">floatRootView = LayoutInflater.from(<span class="keyword">this</span>).inflate(R.layout.float_view, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">//设置拖动事件</span></span><br><span class="line">floatRootView?.setOnTouchListener(ItemViewTouchListener(layoutParam, windowManager))</span><br><span class="line"><span class="comment">// 将悬浮窗控件添加到WindowManager</span></span><br><span class="line">windowManager.addView(floatRootView, layoutParam)</span><br></pre></td></tr></table></figure><h2 id="2-系统类全局悬浮窗（需申请权限）"><a href="#2-系统类全局悬浮窗（需申请权限）" class="headerlink" title="2. 系统类全局悬浮窗（需申请权限）"></a>2. 系统类全局悬浮窗（需申请权限）</h2><p>优点：可以在应用后台后依然显示，官方支持，限制较少。<br>缺点：<strong>需要权限申请</strong>考虑用户授权率打开率或许较低，且如果想覆盖所有场景，需要<strong>无障碍敏感权限</strong>。由于有后台操作，所以接口需要用到<code>Service</code>参与。<br>（总结：使用普通的Service创建悬浮窗无法做到任何界面都能显示，利用无障碍服务可以做到任何界面悬浮）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.SYSTEM_OVERLAY_WINDOW&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>相应权限判断代码省略。<strong>（6.0以下声明权限即默认拥有，但华为小米OPPO等手机有自己的畸形悬浮窗权限管理，仍旧需要考虑适配。）</strong></p><p><strong>注意点</strong><code>WindowManager.LayoutParam</code>中的<code>type</code>需要留意<strong>区分版本</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">    layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Android 8.0</strong>之前可以通过<code>TYPE_PHONE</code>来提供用户交互窗口，但是8.0及以上会抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android.view.WindowManager$BadTokenException: Unable to add window android.view.ViewRootImpl$W@f8ec928 -- permission denied for window type 2002</span><br></pre></td></tr></table></figure><p>同时以下类型也被禁止：<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_f50f6c1ff1e34bd7ec0bf282e75e8803.jpg" alt="Android8.0-TYPE规范"></p><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>综上所以我们必须添加<code>TYPE_APPLICATION_OVERLAY</code>类型来达到显示目的，但是某些情况下悬浮窗效果仍旧会失效不显示。<br>所以此时如果仍旧想要<strong>覆盖此种场景</strong>（如小米手机查看系统信息页面），需要添加<code>TYPE_ACCESSIBILITY_OVERLAY</code>类型，则必须搭配<code>AccessibilityService</code>无障碍服务使用。</p><p>过程概述：</p><ul><li>配置无障碍服务</li><li>在<code>AccessibilityService</code>中获取<code>WindowManager</code></li><li>创建悬浮View[设置悬浮View的拖拽事件]</li><li>添加View到<code>WindowManager</code></li></ul><h2 id="3-应用内全局悬浮窗"><a href="#3-应用内全局悬浮窗" class="headerlink" title="3. 应用内全局悬浮窗"></a>3. 应用内全局悬浮窗</h2><p>优点：<strong>无需权限申请</strong>，可满足大部分场景，相对较少的侵入代码。<br>缺点：<strong>无法后台</strong>，且本质上仍旧是<code>Activity页面级别</code>在页面切换时，需要更新<code>token</code>依附<strong>会有闪动</strong>。</p><p>关键点是<code>type</code>类型中有一个<code>TYPE_APPLICATION_PANEL</code>适合用于应用内的悬浮窗开发。所以可以在<code>BaseActivity</code>基类中埋入相关代码，不断切换悬浮窗的token，也可用LifeCycle监听解耦基类代码。</p><p>过程伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">WindowManager</span> <span class="variable">windowManager</span> <span class="operator">=</span> (WindowManager)  applicationContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">WindowManager.<span class="type">LayoutParams</span> <span class="variable">layoutParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WindowManager</span>.LayoutParams();</span><br><span class="line">layoutParams.type = WindowManager.LayoutParams.TYPE_APPLICATION_PANEL;</span><br><span class="line"> <span class="comment">// 必须</span></span><br><span class="line">layoutParams.token = activity.getWindow().getDecorView().getWindowToken();</span><br><span class="line">windowManager.addView(view, layoutParams);</span><br></pre></td></tr></table></figure><p>由于关键点仍旧<strong>依附于页面</strong>，所以切换Activity时会跟随动画一起位移且会有闪动。</p><p>之后在生命周期时做token 切换：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityResumed</span><span class="params">(activity: <span class="type">Activity</span>?)</span></span> &#123;</span><br><span class="line">       activity?.window?.decorView?.let &#123; decorView -&gt;</span><br><span class="line">           decorView.viewTreeObserver?.let &#123; viewTree -&gt;</span><br><span class="line">               <span class="keyword">if</span> (decorView.windowToken != <span class="literal">null</span>) &#123;</span><br><span class="line">                   FloatWindowUtils.bindDebugPanelFloatWindow(activity, decorView.windowToken)</span><br><span class="line">                   weakGlobalListener?.<span class="keyword">get</span>()?.let &#123; globalListener -&gt;</span><br><span class="line">                       decorView.viewTreeObserver.removeOnGlobalLayoutListener(globalListener)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">val</span> globalListener = <span class="keyword">object</span> : ViewTreeObserver.OnGlobalLayoutListener &#123;</span><br><span class="line">                       <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onGlobalLayout</span><span class="params">()</span></span> &#123;</span><br><span class="line">                           activity.window?.decorView?.windowToken?.let &#123;</span><br><span class="line">                               FloatWindowUtils.bindDebugPanelFloatWindow(activity, it)</span><br><span class="line">                           &#125;</span><br><span class="line">                           decorView.viewTreeObserver.removeOnGlobalLayoutListener(<span class="keyword">this</span>)</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   viewTree.addOnGlobalLayoutListener(globalListener)</span><br><span class="line">                   weakGlobalListener = WeakReference(globalListener)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityPaused</span><span class="params">(activity: <span class="type">Activity</span>?)</span></span> &#123;</span><br><span class="line">       activity?.let &#123;</span><br><span class="line">           FloatWindowUtils.unbindDebugPanelFloatWindow(activity)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比上述方案，授予权限仍旧是最佳的方案，但由于广告的特殊性用户授予权限场景低，这样会导致LongView的全局浮层几乎失效。<br>那么第三种方案，将会是首选，目前看到也有通过<strong>自定义toast</strong>方案来解决的，但是对于一些手机系统如小米ROM不稳定等问题需要进一步考量。</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><ul><li><a href="https://github.com/smallchen/blogs/blob/efd540620a50aad6e8eb4429e504f6b7678c52f6/Android/Android-%E6%B5%AE%E7%AA%97/Android-%E6%B5%AE%E7%AA%97%E6%B5%8B%E8%AF%95.md#%E4%B8%8D%E6%B7%BB%E5%8A%A0%E4%BB%BB%E4%BD%95%E6%9D%83%E9%99%90%E5%A3%B0%E6%98%8E%E6%B5%8B%E8%AF%95">Android-浮窗测试.md</a></li><li><a href="https://juejin.cn/post/6951608145537925128">Android悬浮窗看这篇就够了</a></li><li><a href="https://yuanfentiank789.github.io/2017/04/24/windowtype/">Android入门之窗口类型</a></li><li><a href="https://www.codenong.com/cs106044375/">Android 应用内悬浮球开发</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Window </tag>
            
            <tag> 悬浮窗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池应用浅析</title>
      <link href="/2020/07/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8%E6%B5%85%E6%9E%90/"/>
      <url>/2020/07/20/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.3</p></blockquote><p>[TOC]</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p><strong>重用</strong>存在的线程，<strong>减少</strong>对象创建、消亡的<strong>开销</strong>，提升性能。 可有效<strong>控制最大并发</strong>线程数，提高系统资源的使用率，同时避免过多资源竞争，<strong>避免堵塞</strong>。 提供定时执行、定期执行、单线程、并发数控制等功能。（池化技术很多都用了复用思想，<em><strong>享元模式</strong></em>减少创建对象的数量，以减少内存占用提高性能）</p><h1 id="线程池组成与运行机制"><a href="#线程池组成与运行机制" class="headerlink" title="线程池组成与运行机制"></a>线程池组成与运行机制</h1><h2 id="Java线程池构造方法：（四部分）"><a href="#Java线程池构造方法：（四部分）" class="headerlink" title="Java线程池构造方法：（四部分）"></a>Java线程池构造方法：（四部分）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  </span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,  </span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,  </span></span><br><span class="line"><span class="params">                              TimeUnit unit,  </span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,  </span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,  </span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> </span><br></pre></td></tr></table></figure><ol><li><strong>线程池管理器</strong>（<strong>ThreadPool</strong>）：用于<strong>创建并管理</strong>线程池，包括 创建线程池，销毁线程池，添加新任务； </li><li><strong>工作线程</strong>（<strong>PoolWorke</strong>r）：<strong>线程池中线程</strong>，<strong>在没有任务时处于等待状态</strong>，可以循环的执行任务； </li><li><strong>任务接口</strong>（<strong>Task</strong>）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</li><li><strong>任队列</strong>（<strong>taskQueue</strong>）：用于存放没有处理的任务。提供一种缓冲机制。</li></ol><h2 id="执行流程："><a href="#执行流程：" class="headerlink" title="执行流程："></a>执行流程：</h2><ul><li><p>当线程池<strong>小于corePoolSize</strong>时，新提交任务将<strong>创建一个新线程</strong>执行任务，即使此时线程池中存在空闲线程。</p></li><li><p>当线程池<strong>达到corePoolSize时</strong>，新提交任务将被<strong>放入workQueue</strong>中，等待线程池中任务调度执行</p></li><li><p><strong>当workQueue已满</strong>，且<strong>maximumPoolSize&gt;corePoolSize</strong>时，新提交任务会<strong>创建新</strong>线程执行任务</p></li><li><p>当提交任务数<strong>超过maximumPoolSize</strong>时，新提交任务由<em><strong>RejectedExecutionHandler</strong></em>处理</p></li><li><p>当线程池中<strong>超过corePoolSize线程</strong>，<strong>空闲时间达到</strong>keepAliveTime时，关闭<strong>空闲线程</strong></p></li><li><p>当设置<strong>allowCoreThreadTimeOut</strong>(true)时，线程池中<strong>corePoolSize</strong>线程空闲时间达到keepAliveTime<strong>也将关闭</strong></p></li></ul><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>对于任务队列影响线程池的表现：</p><p>我们可以看到，线程池的创建运行不光是要指定核心与线程数，同样更要结合所使用的<strong>任务队列</strong>特性去区别对待。</p><ul><li>如果采用<strong>无界的阻塞队列</strong>比如 <code>LinkedBlockingQueue</code> ，因为<strong>没有大小限制</strong>，队列中可以不断的添加任务，然后一直都是最小核心线程的数量来做事情。换句话说就是最多只能<strong>按照最小线程数量来创建</strong>，而线程池的maxsize被忽略了。这也可以很好地解释<code>newFixedThreadPool</code>的为什么直接将核心数与最大数设置为同一个值，以此来保证并发控制。但由于这种特殊无界的特性，需要关注到是否合理使用防止OOM的发生。（比如<code>OkHttp</code>中，虽然也是创建的<code>newCacheThreadPool</code> 但外部的任务安排还是通过<code>Dispatcher</code>来调度管理分配的避免同时创建过多,默认是64个请求或者5个主机数以内）</li><li>而如果采用一个<strong>有界的队列</strong>比如<code>ArrayBlockingQueue</code>，（假定一个线程池为最小3，最大6，任务队列大小为5）。当前三个任务加入时最小核心数3保持着运行，然后继续添加5个任务，这个时候在任务队列都<strong>可以容纳的前提下</strong>线程池仍旧<strong>不会开启新的线程</strong>，但当<strong>再添加任务时</strong>，这个时候<strong>才会开启</strong>新的工作线程，执行队列中的第一个任务，再将这个新的任务放入任务队列，直到超过最大线程数量后会抛出异常（假设这段时间内没有任何一个任务结束，保证都在运行任务）。这很好的体现了线程池对于多任务并行处理的控制作用，起到了一个<strong>节流阀</strong>的功效。</li></ul><h1 id="Java默认提供的线程池种类："><a href="#Java默认提供的线程池种类：" class="headerlink" title="Java默认提供的线程池种类："></a>Java默认提供的线程池种类：</h1><h2 id="newCachedThreadPool：（特殊无界）"><a href="#newCachedThreadPool：（特殊无界）" class="headerlink" title="newCachedThreadPool：（特殊无界）"></a><code>newCachedThreadPool</code>：（特殊无界）</h2><p>•底层：返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为<strong>Integer.MAX_VALUE</strong>；<strong>keepAliveTime为60L</strong>；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)</p><p>•通俗：当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则<strong>创建一个线程来执行该任务</strong>；若池中线程<strong>空闲时间超过</strong>指定大小，则该线程会被<strong>销毁</strong>。</p><p>•适用：执行很多<strong>短期异步</strong>的小程序或者负载较轻的服务器</p><p>注意：由于可创建很多，所以有OOM的风险，由于使用的队列是SynchronousQueue该队列实际不会堆积任务，只要生产者产生任务，就会有消费者也就是线程来处理。</p><h2 id="newFixedThreadPool：（无界）"><a href="#newFixedThreadPool：（无界）" class="headerlink" title="newFixedThreadPool：（无界）"></a><code>newFixedThreadPool</code>：（无界）</h2><p>•底层：返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，<strong>corePoolSize为nThread</strong>，<strong>maximumPoolSize为nThread</strong>；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue() 无界阻塞队列</p><p>•通俗：<strong>创建可容纳固定数量线程的池子</strong>，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</p><p>•适用：执行<strong>长期</strong>的任务，性能好很多</p><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor:"></a><code>newSingleThreadExecutor</code>:</h2><p>•底层：FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue() 无界阻塞队列</p><p> •通俗：创建<strong>只有一个线程</strong>的线程池，且线程的<strong>存活时间是无限的</strong>；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</p><p> •适用：<strong>一个任务一个任务</strong>执行的场景<br> <br> ps:<br> 回头复习时候看，这里对比创建一个只有1个最大任务数的<code>newFixedThreadPool</code>有什么区别呢？  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span>      <span class="comment">//这里用到了装饰器模式，这是与Fix的唯一区别</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>FinalizableDelegatedExecutorService</code>类里面多了一个<code>finalize()</code>方法，该方法实际上调用的是线程池的<code>shutdown()</code>方法把线程池状态变为SHUTDOWN（即把任务执行完而不接受新任务）。</p><blockquote><p>而二者之间主要区别在于垃圾回收时<code>Single</code>线程池多了一步销毁方法，其次是<code>Fix</code>线程池后期可以更改线程池数量，<code>Single</code>不可以（因为本来就是单一）</p></blockquote><h2 id="NewScheduledThreadPool"><a href="#NewScheduledThreadPool" class="headerlink" title="NewScheduledThreadPool:"></a><code>NewScheduledThreadPool</code>:</h2><p>•底层：创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列</p><p> •通俗：<strong>创建一个固定大小的线程池</strong>，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按<strong>照超时时间排序</strong>的队列结构</p><p>•适用：<strong>周期性</strong>执行任务的场景</p><h3 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h3><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2020年05月20日20:50:03</td><td>初版整理</td></tr><tr><td>version 0.2</td><td>2020年07月21日17:49:04</td><td>添加<code>Fix</code>与<code>Single</code>线程池区分</td></tr><tr><td>version 0.3</td><td>2022年02月08日14:51:43</td><td>重新修正排版顺序</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机制 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler相关知识点</title>
      <link href="/2020/07/20/Handler%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/07/20/Handler%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Handler常见知识总结"><a href="#Handler常见知识总结" class="headerlink" title="Handler常见知识总结"></a>Handler常见知识总结</h1><blockquote><p>version 0.1</p></blockquote><p>[TOC]</p><h2 id="主要组件："><a href="#主要组件：" class="headerlink" title="主要组件："></a>主要组件：</h2><ol><li><strong>Looper</strong>: 一个<strong>线程</strong>可以产生<strong>一个</strong>Looper对象，由它来<strong>管理</strong>此线程里的<strong>MessageQueue</strong>(消息队列)。</li><li><strong>Handler</strong>: 你可以构造Handler对象来<strong>与Looper沟通</strong>，以便<strong>push</strong>新消息到MessageQueue里;或者<strong>接收</strong>Looper从Message Queue取出)所送来的<strong>消息</strong>。</li><li><strong>Message Queue</strong>(消息队列):用来<strong>存放</strong>线程放入的<strong>消息</strong>，采用单链表实现。</li><li><strong>线程</strong>：UIthread 通常就是main thread，而Android启动程序时会替它建立一个MessageQueue。</li></ol><h2 id="过程简单概述"><a href="#过程简单概述" class="headerlink" title="过程简单概述"></a>过程简单概述</h2><p><a href="https://blog.csdn.net/guolin_blog/article/details/9991569">郭霖-Android异步消息处理机制完全解析，带你从源码的角度彻底理解</a></p><p>Android UI线程是不安全，同时也不能进行耗时操作，安卓提供了Handler方便开发者来进行线程间切换与通信。<br>Handler在<strong>创建时需要</strong>传递一个线程的<strong>Looper</strong>，Looper内存在对应线程的<strong>消息队列</strong>（MessageQueue）（通过ThreadLocal获取）。Handler将<strong>消息</strong>（Message）发送给Looper，由Looper<strong>放入消息队列</strong>。而Looper又通过循环从消息队列中<strong>取出</strong>消息再<strong>交给Handler</strong>处理。</p><p><img src="https://imgur.com/download/I4S8ANc" alt="-c"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LooperThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          Looper.prepare();</span><br><span class="line"> </span><br><span class="line">          mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                  <span class="comment">// process incoming messages here</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"> </span><br><span class="line">          Looper.loop();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><blockquote><p>Handler构造方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Handler</span>&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mLooper = Looper.myLooper(); <span class="comment">//这里从Looper中获取mLooper对象，如果为空则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;<span class="comment">//从Looper中获取消息队列</span></span><br><span class="line">        mCallback = callback;<span class="comment">//callback赋值</span></span><br><span class="line">        mAsynchronous = async;<span class="comment">//是否是同步处理消息</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>Looper.myLooper():</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到初始化的过程中就是要从Looper中获取myLooper，那与我们直接使用之间的区别是是否有调用<code>Looper.prepare()</code>方法。</p><blockquote><p>Looper.prepare()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断<code>sThreadLocal</code>中是否已经存在Looper，没有的话则创建一个新的进去，而且必须满足只能有一个Looper对象。</p><p>（主线程不需要，因为系统在<strong>ActivityThread启动</strong>时已经调用了该方法）</p><hr><h3 id="发送消息过程"><a href="#发送消息过程" class="headerlink" title="发送消息过程"></a>发送消息过程</h3><p>最终调用为<code>public boolean sendMessageAtTime(Message msg, long uptimeMillis)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(Message msg, <span class="type">long</span> uptimeMillis)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">sent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue != <span class="literal">null</span>) &#123;</span><br><span class="line">        msg.target = <span class="built_in">this</span>;</span><br><span class="line">        sent = queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>msg</code>为发送的 <strong>Message</strong> 对象，<code>uptimeMillis</code>表示 <strong>发送消息的时间</strong>。如果没有延迟，则延迟时间为0。<em><strong>注意</strong></em> 它的时间是系统 <strong>开机到当前时间的毫秒数再加上延迟时间</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(Message msg, <span class="type">long</span> delayMillis)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="入队过程"><a href="#入队过程" class="headerlink" title="入队过程"></a>入队过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.when != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AndroidRuntimeException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span> &amp;&amp; !mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread not allowed to quit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuiting) &#123;</span><br><span class="line">            <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(<span class="string">&quot;MessageQueue&quot;</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">            mQuiting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="comment">//入队过程</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;<span class="comment">//先判断是否需要立即发送或延迟时间小于队列中第一个消息的延迟时间的话则放入队首</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.when &lt;= when) &#123;<span class="comment">//否则找到合适位置入队</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = prev.next;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入队过程中只有<code>mMessages</code>来表示当前待处理消息，同时按照时间来升序排列。同时注意虽然称之为消息队列但是我们看见其实这是一个单链表的结构，优点是增删的性能较好。</p><h3 id="出队过程"><a href="#出队过程" class="headerlink" title="出队过程"></a>出队过程</h3><p>出队主要是通过<code>Looper.loop()</code>方法,所以使用中只是调用<code>prepare</code>入队是不能让handler工作起来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//这里单链表中获取消息一直是循环的，当没有消息时这里会阻塞住，进入休眠状态等待再有消息后唤醒</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里有一个执行耗时阈值的检测，统计执行时间差如果超过阈值会进行打印，并获取堆栈信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">slowDispatchThresholdMs</span> <span class="operator">=</span> me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> end;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//开始调用target的dispatchMessage来分发消息</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> end - start;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Dispatch took &quot;</span> + time + <span class="string">&quot;ms on &quot;</span></span><br><span class="line">                        + Thread.currentThread().getName() + <span class="string">&quot;, h=&quot;</span> +</span><br><span class="line">                        msg.target + <span class="string">&quot; cb=&quot;</span> + msg.callback + <span class="string">&quot; msg=&quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见主要是进入了<strong>死循环</strong>，并不断的调用消息队列的<code>next()</code>来获取消息，出队操作中如果没有消息或消息发送时间还未到会进入阻塞，只有手动让Looper停止才可以使next()方法返回null，从而退出循环</p><p>具体出队过程分析： &#x2F;&#x2F;TODO </p><h3 id="分发事件"><a href="#分发事件" class="headerlink" title="分发事件"></a>分发事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果消息msg.callback不为空则回调给callback，赋值的地方稍后分析</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果初始化时候有callback，则会在本身的callback中回调handleMessage</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通常情况会直接回调给handleMessage去处理</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而其中的<code>handleCallback</code> 实际上是调用了run（）方法，<br><code>handleMessage</code> 是回调去处理，<code>mCallback</code>赋值地方下面分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback interface you can use when instantiating a Handler to avoid</span></span><br><span class="line"><span class="comment"> * having to implement your own subclass of Handler.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>由于<code>Handler</code>总是依附于<strong>创建时</strong>所在的<strong>线程</strong>（Looper决定），比如在主线程中创建，而子线程无法直接对UI进行操作，于是可以通过调用<code>Handler</code>将消息经过一些列的发送，入队，出队最后在<strong>主线程</strong>的<code>handleMessage</code>中<strong>回调</strong>。</p><ul><li><code>Handler.post()</code> 方法:</li></ul><p>这里调用了<strong>sendMessageDelayed()</strong>, 并将时间设置为 0ms，mCallback也是这个时候去赋值的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(Runnable r)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Message <span class="title function_">getPostMessage</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    <span class="comment">//obtain是从消息缓存池中获取避免多次new的优化</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">    <span class="comment">//这里将runnable对象赋值给了callback</span></span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>View.post()</code> 方法：</li></ul><p>最终还是调用了<code>handler.post</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    Handler handler;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        handler = mAttachInfo.mHandler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果还没有被依附则会放入队列等待直到被依附后调用</span></span><br><span class="line">        ViewRoot.getRunQueue().post(action);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler.post(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>runOnUiThread()</code> 方法：<br>也是调用了<code>post</code>,同时如果是主线程则直接<code>run</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runOnUiThread</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见问题与优化"><a href="#常见问题与优化" class="headerlink" title="常见问题与优化"></a>常见问题与优化</h2><h3 id="Android中为什么非UI线程不能更新UI"><a href="#Android中为什么非UI线程不能更新UI" class="headerlink" title="Android中为什么非UI线程不能更新UI?"></a>Android中为什么非UI线程不能更新UI?</h3><h4 id="UI线程工作机制"><a href="#UI线程工作机制" class="headerlink" title="UI线程工作机制"></a>UI线程工作机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    <span class="comment">//主线程会一直死循环运行 也就是阻塞</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="comment">//如果死循环退出了，程序就会崩掉抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>UI线程</strong>就是<strong>zygote</strong>直接fork出来的<strong>进程中的线程</strong>，就是Activty中的<strong>main</strong>。</p><hr><h4 id="为什么UI线程设计成不安全的？"><a href="#为什么UI线程设计成不安全的？" class="headerlink" title="为什么UI线程设计成不安全的？"></a>为什么UI线程设计成不安全的？</h4><p>如果在子线程子线程中去更新ui，必定要对view更新的操作加锁，<strong>加锁的效率很受影响</strong>，不能接受</p><ul><li>ui具有可变性，甚至是高频可变性</li><li>ui对响应时间非常敏感</li><li>ui组件必须批量绘制，保证效率</li></ul><h4 id="非UI线程一定不能更新UI吗？"><a href="#非UI线程一定不能更新UI吗？" class="headerlink" title="非UI线程一定不能更新UI吗？"></a>非UI线程一定不能更新UI吗？</h4><p>可以间接更新，比如<strong>post</strong>，<strong>postinvalidate</strong>。还有<strong>SurfaceView</strong>是直接在子线程中去更新UI的，在Activity的<code>onCreate</code>生命周期中也可以在子线程中更新ui。</p><p><img src="https://imgur.com/download/4zQHJqG" alt="-c"></p><p>安卓更新UI的时候会去做<strong>线程检测</strong>，检测创建这个UI的线程是不是要更新ui的线程，更新UI就是在<code>ViewRootImpl</code>中做<strong>requestLayout</strong>，做线程检测。</p><p>但是ViewRoot是在<strong>onResume</strong>中<code>addDecView</code>去实现的，如果在<strong>onCreate</strong>中创建子线程更新UI 也许这时候<strong>还没有创建Viewroot</strong>，这时候就<strong>绕开了检测</strong>。</p><p>在子线程弹<code>Toast</code>是可以的，因为<strong>Toast</strong>是在<strong>windowManager</strong>上弹的，与Activity无关，也就与ViewRoot无关，但是由于Toast里面用到了handler，所以在子线程中***Looper.prepare()***一下。所以，在子线程中是可以更新ui的</p><h3 id="Handler常见的内存泄露问题"><a href="#Handler常见的内存泄露问题" class="headerlink" title="Handler常见的内存泄露问题"></a>Handler常见的内存泄露问题</h3><p><a href="https://juejin.im/post/5a692377518825734e3e71ab">掘金 - 你的 Handler 内存泄露 了吗？</a></p><h3 id="Handler-postDelay方法是否可靠？"><a href="#Handler-postDelay方法是否可靠？" class="headerlink" title="Handler postDelay方法是否可靠？"></a>Handler postDelay方法是否可靠？</h3><blockquote><p>结论：不可靠，但需要深入分析</p></blockquote><ul><li>大于Handler Looper的周期时基本可靠（例如主线程&gt;50ms）</li><li>Looper 负载越高，任务越容易积压，进而导致卡顿</li><li>不要用Handler的delay做计时使用</li></ul><p><img src="https://imgur.com/dowanload/R37uPgJ" alt="-c"></p><p>当事件生产过多，在队列中事件产生堆积时要注意。</p><p>这里还是要分析入队的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="type">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                <span class="comment">//如果在队列最开始并满足条件</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//根据when时间去遍历然后放入队列</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入阻塞态</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="loop-分析"><a href="#loop-分析" class="headerlink" title="loop()分析"></a>loop()分析</h4><p><a href="#%E5%87%BA%E9%98%9F%E8%BF%87%E7%A8%8B">Looper.loop过程</a> 中看到了调用了Message的<strong>next</strong>方法，这里是我们要分析的重点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//如果这里的值是-1则会在底层阻塞</span></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">                <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                        <span class="comment">//设置时间要休眠的时间，让nativePollOnce一段时间后醒过来</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">return</span> msg;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，消息等待阻塞机制主要是在<code>nativePollOnce</code>中去实现，当前消息时间还没有到，或者没有消息了，这时候会进行等待<strong>休眠状态</strong>，<strong>不会消耗cpu</strong>，这是采用了<strong>Linux的IO多路复用机制</strong></p><p><img src="https://imgur.com/download/zV9k6EL" alt="-c"></p><p> 大致过程描述为从<code>MessageQueue</code>调用<code>next</code>后<strong>如果没有消息</strong>会进入底层的<code>pollOnce</code>然后去调用<code>epoll_wait</code>这个文件描述符上去<strong>等待</strong>消息。<br> 当有新消息进来<strong>需要处理时</strong>，会让底层的调用<code>wake</code>然后通过<code>write</code>后去让<code>epoll_wait</code><strong>唤醒</strong>，再通知上层继续。</p><blockquote><p>总结：<br>言而言之Looper采用了<strong>epoll机制</strong>，当没有消息来得时候会处于阻塞状态<strong>wait</strong>,从而不消耗CPU,当消息需要通知的时候会通过<strong>wake</strong>来通知上层继续工作。</p></blockquote><ul><li><a href="https://juejin.im/post/5e7776bdf265da57127e6b2b#heading-12">掘金-彻底了解Handler</a></li></ul><hr><h3 id="为什么Handler不会阻塞主线程造成ANR-（Looper死循环为什么不会导致CPU占用率很高？）"><a href="#为什么Handler不会阻塞主线程造成ANR-（Looper死循环为什么不会导致CPU占用率很高？）" class="headerlink" title="为什么Handler不会阻塞主线程造成ANR?（Looper死循环为什么不会导致CPU占用率很高？）"></a>为什么Handler不会阻塞主线程造成ANR?（Looper死循环为什么不会导致CPU占用率很高？）</h3><h4 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h4><p>首先明确，造成ANR的主要是事件没有在规定时间内分发。只有当应用程序的UI线程响应超时才会引起ANR，超时产生原因一般有两种。</p><ul><li>当前的事件没有机会得到处理，例如UI线程正在响应另一个事件，当前事件由于某种原因被阻塞了。</li><li>当前的事件正在处理，但是由于耗时太长没能及时完成。</li></ul><h5 id="ANR-类型"><a href="#ANR-类型" class="headerlink" title="ANR 类型"></a>ANR 类型</h5><ul><li>ServiceTimeOut:<ol><li>前台服务20s</li><li>后台服务200s</li></ol></li><li>BroadcaseQueue Timeout:<ol><li>前台广播 10S</li><li>后台广播 60S</li></ol></li><li>ContentProvider Timeout：10S</li><li><strong>InputDispatching</strong> Timeout: 5S</li></ul><h6 id="分析一次ANR过程"><a href="#分析一次ANR过程" class="headerlink" title="分析一次ANR过程"></a>分析一次ANR过程</h6><p>无论是四大组件或者进程等只要发生ANR，最终都会调用***AMS.appNotResponding()***方法</p><blockquote><p>以Service TimeOut为例：</p></blockquote><p><img src="https://imgur.com/download/TlAl6TI"></p><p>ActivityServices类中：</p><p>####### 埋入炸弹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">realStartServiceLocked</span><span class="params">(ServiceRecord r, ProcessRecord app, <span class="type">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//发送delay消息(SERVICE_TIMEOUT_MSG) 在这里埋入炸弹</span></span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;create&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//最终执行服务的onCreate()方法</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bumpServiceExecutingLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> fg, String why)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleServiceTimeoutLocked</span><span class="params">(ProcessRecord proc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc.executingServices.size() == <span class="number">0</span> || proc.thread == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = proc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当超时后仍没有remove该SERVICE_TIMEOUT_MSG消息，则执行service Timeout流程</span></span><br><span class="line">    <span class="comment">//同时判断根据是否是前台进程来设置超时时间为20s与200s</span></span><br><span class="line">    mAm.mHandler.sendMessageAtTime(msg,</span><br><span class="line">        proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看见发送了一个delay的消息一旦达到超时时间就会触发，那提前拆除这个消息的地方就是在<strong>onCreate</strong>方法后紧接调用<strong>system_server</strong> 的 <code>serviceDoneExecuting</code></p><p>####### 拆除炸弹</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> inDestroying, <span class="type">boolean</span> finishing)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="literal">null</span>) &#123;</span><br><span class="line">            r.app.execServicesFg = <span class="literal">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当前服务所在进程中没有正在执行的service</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当service启动完成后，则移除service创建超时的消息否则就会触发。</p><p><img src="https://imgur.com/download/RJV1zGJ"></p><p>####### 引爆炸弹</p><p>在<code>system_server</code>进程中有一个Handler线程, 名叫”<code>ActivityManager</code>”.当倒计时结束便会向该Handler线程发送 一条信息 <em><strong>SERVICE_TIMEOUT_MSG</strong></em> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MainHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;</span><br><span class="line">                ...</span><br><span class="line">        mServices.serviceTimeout((ProcessRecord)msg.obj);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">serviceTimeout</span><span class="params">(ProcessRecord proc)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (anrMessage != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当存在timeout的service，则执行appNotResponding</span></span><br><span class="line">        mAm.appNotResponding(proc, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>, anrMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">appNotResponding</span><span class="params">(ProcessRecord app, ActivityRecord activity, ActivityRecord parent, <span class="type">boolean</span> aboveSystem, <span class="keyword">final</span> String annotation)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Bring up the infamous（声名狼藉）App Not Responding dialog</span></span><br><span class="line">     <span class="comment">//弹出ANR对话框</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        msg.what = SHOW_NOT_RESPONDING_MSG;</span><br><span class="line">        msg.obj = map;</span><br><span class="line">        msg.arg1 = aboveSystem ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        map.put(<span class="string">&quot;app&quot;</span>, app);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;activity&quot;</span>, activity);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//向ui线程发送，内容为SHOW_NOT_RESPONDING_MSG的消息</span></span><br><span class="line">        mUiHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过一系列的跟踪，终于看见了一直以来深恶痛觉的ANR错误的由来。其中也夹杂着各种信息收集trace等，如果展开篇幅太长，我也参考了这里：</p><ul><li><a href="http://gityuan.com/2016/12/02/app-not-response/">袁辉辉-理解Android ANR的信息收集过程</a></li><li><a href="http://gityuan.com/2016/07/02/android-anr/">袁辉辉-理解Android ANR的触发原理</a></li></ul><hr><h4 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h4><p>ActivityThread的<code>main</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">        thread.attach(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://imgur.com/download/cdK21XK" alt="-c"></p><p>Looper是一个整体概念，ANR主要是执行到某一环节执行耗时的一种监控。所以有了这个区别，发现应该更侧重于<strong>Looper为何不会导致CPU占用率过高？</strong></p><p>由于Looper消息底层是native的<code>epoll_wait</code></p><ul><li>Looper::pollInner:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mEpollFd = <span class="built_in">epoll_create</span>(EPOLL_SIZE_HINT);</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">epoll_ctl</span>(mEpollFd,EPOLL_CTL_ADD,mWakeEventFd, &amp;eventItem);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line"><span class="type">int</span> eventCount = <span class="built_in">epoll_wait</span>(mEpollFd.eventItems,EPOLL_MAX_EVENTS,timeoutMills);</span><br></pre></td></tr></table></figure><p><img src="https://imgur.com/download/Le11BPp" alt="-c"></p><blockquote><p>IO多路复用部分会有一个监控的红黑树，开始时对epoll监听描述符做了一个配置连接的管道，如果事件就绪会移动到就绪列表，绿色的部分，然后去通知<code>epoll_wait</code>。这时如果Looper卡在了<code>epoll_wait</code>则会把它唤醒，去处理消息。</p></blockquote><hr><h3 id="消息屏障是什么？"><a href="#消息屏障是什么？" class="headerlink" title="消息屏障是什么？"></a>消息屏障是什么？</h3><p>在Android的消息机制中，其实有三种消息: <strong>普通消息</strong>、<strong>异步消息</strong>及<strong>消息屏障</strong></p><p><strong>消息屏障</strong>也是一种消息，但是它的<code>target</code>为 null。可以通过<code>MessageQueue</code>中的<strong>postSyncBarrier</strong>方法发送一个消息屏障（该方法为私有，需要反射调用）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">(<span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line">        <span class="comment">//按照时间顺序将消息插入到消息队列中</span></span><br><span class="line">         ......</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消息循环中，如果<strong>第一条</strong>消息就是<strong>屏障消息</strong>，就往后遍历，看看<strong>有没有异步消息</strong>: 如果没有，则无限<strong>休眠</strong>，等待被唤醒 如果<strong>有</strong>，就看离这个消息被触发时间还有多久，<strong>设置一个超时时间</strong>，继续休眠</p><p>异步消息和普通消息一样，只不过它被设置<code>setAsynchronous</code> 为<strong>true</strong>。有了这个标志位，消息机制会对它有些特别的处理，使<strong>异步消息具有优先处理的权利</strong>。</p><p>这时候我们回顾将消息添加到消息队列中时，可以发现， <em><strong>其实并不是每一次添加消息时，都会唤醒线程</strong></em> 。 当该消息插入到队列头时，会唤醒该线程； 当该消息 <em><strong>没有插入到队列头</strong></em> ，但队列 <em><strong>头是屏障</strong></em> ，且该消息是队列中 <strong>靠前</strong>的一个<strong>异步消息</strong>，则会<strong>唤醒</strong>线程，执行该消息。</p><p>调用<code>MessageQueue.removeSyncBarrier</code> 方法可以移除指定的消息屏障。</p><p><a href="https://juejin.im/post/5d3ad2ec6fb9a07ef81a4460">掘金 - Android Handler那些事儿</a></p><h3 id="Handler-队列优化"><a href="#Handler-队列优化" class="headerlink" title="Handler 队列优化"></a>Handler 队列优化</h3><h4 id="互斥消息取消"><a href="#互斥消息取消" class="headerlink" title="互斥消息取消"></a>互斥消息取消</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Category</span>&#123;</span><br><span class="line">RENDER,START,STOP</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MessageType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> Message.obtain(handler, STOP_MAP.what);</span><br><span class="line">        message.obj = STOP_MAP.category;</span><br><span class="line">        <span class="keyword">for</span> (Category category : Category.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span>（category.ordinal() &lt;= STOP_MAP.category.ordinal()）&#123;</span><br><span class="line">            <span class="comment">//当满足条件时清除其他消息，有优先级</span></span><br><span class="line">        handler.removeCallbacksAndMessages(category);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            handler.sendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复用消息"><a href="#复用消息" class="headerlink" title="复用消息"></a>复用消息</h4><p>调用<strong>Message</strong> 的**obtain()**方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">     * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="literal">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MessageQueue.<span class="type">IdleHandler</span> <span class="variable">idleHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>.IdleHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//处理事情</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//false 代表只在空闲时执行一次,执行完移除,true会多次触发</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(idleHandler);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>Glide 3.X</code>中用此方法来移除gc调用的图片弱引用，4.X中移除。</p><h4 id="独享Looper"><a href="#独享Looper" class="headerlink" title="独享Looper"></a>独享Looper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">HandlerThread</span> <span class="variable">handlerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;Token-Thread&quot;</span>)</span><br><span class="line">handlerThread.start();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">tokenHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(handlerThread.getLooper());</span><br></pre></td></tr></table></figure><h2 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h2><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2020年05月22日17:50:30</td><td>初版整理常用复习知识点</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机制 </tag>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bitmap过滤有效信息</title>
      <link href="/2020/04/01/Bitmap%E8%BF%87%E6%BB%A4%E6%9C%89%E6%95%88%E4%BF%A1%E6%81%AF/"/>
      <url>/2020/04/01/Bitmap%E8%BF%87%E6%BB%A4%E6%9C%89%E6%95%88%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.2</p></blockquote><p>[TOC]</p><h1 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h1><p>最近在和产品一起讨论我们新设备的亮点功能上尝试探讨，是否可以将导航过程中的路口放大图通过蓝牙传递到我们的hud上。可是由于成本因素考虑，硬件的限制条件比较苛刻。留给我们的显示区域的分辨率只有<code>128*71</code>的大小，而且文件内存只能控制在寥寥2k以内，最初时候甚至不支持加载图片。中间也经历了几次尝试从黑白到彩色，己经波折与尝试终于有了一个不错的效果展示以此记录这次过程。</p><h2 id="采用黑白方案过程："><a href="#采用黑白方案过程：" class="headerlink" title="采用黑白方案过程："></a>采用黑白方案过程：</h2><blockquote><p>协定的是客户端将图片的特征数据提取并简化成点阵，然后采用压缩的形式再传给客户端。分成数据提取，与信息表示两个部分。</p></blockquote><h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>首先想到的方案是通过Bitmap来过滤特征的像素值，然后进一步去掉其他无关像素点。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/H6vlKhP71OM3Xkm.png" alt="image.png-c"></p><p>首次过滤效果是这样，上面是原高德地图SDK返回的路口放大图信息，下图是通过Bitmap像素遍历值并替换需要元素拿到的转换图片。</p><h3 id="初步过程"><a href="#初步过程" class="headerlink" title="初步过程"></a>初步过程</h3><p>初步看来主要信息轮廓都在，看上去只要再压缩完成后去传输就行。<br>当时想的方案是颜色加坐标，然后传输过去，<code>HUD端</code>那边接收再按行绘制出来。</p><p>可在实际压缩至小的分辨率之后发现锯齿比想象中严重虽然分辨率低，但是由于单纯用像素匹配黄色导航箭头可能效果还好，但对于路的边缘有很多误差，甚至像一些建筑物桥梁等根本看不出来是什么，而且还有其他问题。</p><p>首先虽然这张图的像素可以替换成简单的四个色值，但是压缩后在所难免产生色彩的偏移：</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/MbKYhRFCUHl2Azr.png" alt="原始调整颜色-c"></p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/6tFjYzmNXaZUlyV.png" alt="原始压缩效果-c"></p><p>可以看到道路的周围对于这种哪怕非常清晰的原图压缩后也没有很理想的效果。这个对于锯齿的处理，想用简单的连线来代替可处理的判断逻辑比想象中要复杂，如何判断周围的像素要相连，如何判断不相连，压缩之后的图片色彩偏移后 白色与灰色值的判定依旧不是那么清晰。</p><p>到这里，似乎问题变得不好处理起来。日常大多处理的东西很少会需要这种精准度的匹配，相关问题组里面也没有人涉及。我的组长只是想到看能不能用OpenCV 来试着处理，可自己从来没有过经验。硬着头皮试试看吧。</p><h3 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h3><p>终于在一次偶然机会，发现了一种术语叫<code>特征提取</code>。其中的<code>坎尼运算</code>对于描述图像轮廓很有帮助，这是OpenCV中比较常用的特征提取算法。大体是用线条来绘制轮廓而不在描述全部特征的一种方式，也算是边缘检测的一种方法。</p><p>在摸索了几天OpenCV的基础使用后，我开始集成进Demo去尝试处理。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/cLzOBhqWMnEmef6.png" alt="坎尼运算-c"></p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/GikUeKfdauLDy8q.png" alt="坎尼运算2-c"></p><p>我想或许这是我想要的方案，但这又产生了另一个问题，这只有轮廓却完全是黑白色的体现。但我可以手动再填充一次，同时坎尼运算有两个阈值设置为了简而言之就是这两个阈值算子决定了轮廓绘制的有多详细。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/BwnNp7SLDsV1ThQ.png" alt="坎尼运算3-c"></p><p>以上便方便切较为精准的匹配了特征，那么下一步就是希望降低压缩后的颗粒感。（因为分辨率非常小，又为了突出主体在研究的过程中我加上了一部分裁剪的方法来适当去掉无关内容，比如蓝天那些远景图。原理也比较简单，就是从黄色箭头处的位置适当保留高度，而不是全部的高度这样压缩后的图片主要能容就会更大一些。）</p><h3 id="压缩与填充"><a href="#压缩与填充" class="headerlink" title="压缩与填充"></a>压缩与填充</h3><p>在尝试各种自带方法效果不理想后，奈何对于计算机图像视觉根本于我不着边际，又开始了各种谷歌尝试找到一种方法，于是OpenCV中的一种压缩方式引起了我的注意，这种采用的<code>像素面积关系重采样</code>能较好的拟合这种锯齿行为。同时其中的<code>二值化</code>处理也为压缩后的图片产生色彩偏移带来了可行性，在这过程中也加了一些处理为了使得锯齿更小，同时加入了高斯模糊以及锐化等辅助处理工作。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/7DvRFHPcVWhoG1E.png" alt="OpenCv压缩-c"></p><ul><li><a href="https://zhuanlan.zhihu.com/p/38493205">OpenCV里的INTER_AREA究竟是在做啥？</a></li></ul><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/AKF53sgVyMdZU9G.png" alt="image.png-c"></p><p>最终处理的图片可以看到在经过这些处理后的图像抗锯齿的效果好了很多，之前左边毛躁的边缘开始类似两条线去收尾。至此在黑白色彩方案里终于可以有一个可预期的效果。</p><p><strong>最终展示效果：</strong></p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/GawyqJiAgnlLMDS.png" alt="最终效果-c"></p><h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><p>处理数据的过程也是一个反复推到重试的过程，刚开始制定的想法就是颜色的二进制值去表示，对方（<code>HUD端</code>）再去绘制。<br>但很快发现了一个问题，分辨率是固定的也就是 <code>128 * 71</code>的大小，那么我就要有这么多个点，也就是要有这么多的数据。<br>如果用<code>RGB</code>来表示那么就是三个数 再乘以像素的大小。</p><blockquote><p>（4字节 + 4字节 + 4字节）* 128 * 71 &#x3D; 109056 字节 ≈ 106k</p></blockquote><p>那么一定是不能按照类似加载到内存大小的形式来表示数据了。</p><p>我们初步想的方案准备用一字节来表示颜色，因为颜色种类只有四种以内：<br>分别是建筑的灰色1，指示的黄色2，道路绘制的白色3，以及无关的黑色内容4。</p><blockquote><p>1字节 * 128 * 71 &#x3D; 18176 字节  ≈ 8.8K</p></blockquote><p> 这样颜色的表示瞬间降低了下来，可这个大小仍旧与实际需要想去甚远。类似<code>jpeg</code> 之类的图片在我保存到硬盘上只有2k到6k大小而且人家的颜色还不止这么点，然后去<br> 翻资料找到一个<code>游程编码</code>(Run-length encoding,简称RLE)压缩的方式。</p><p> <a href="https://en.wikipedia.org/wiki/Run-length_encoding">Wiki-Run-length encoding</a></p><p> <img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/kWrvElzKedu7F2x.png" alt="image.png-c"></p><p> 简而言之就是把数据按照<strong>线性</strong>的序列分为<strong>连续</strong>和<strong>不连续</strong>的两种情况。假设我的图片是<code>10*10</code> 在第一行的像素是这样：</p><blockquote><p>[黑，黑，黑，黑，黑，黄，黄，白，白，白]</p></blockquote><p>那么我可以表示成：</p><blockquote><p>黑[5],黄[2],白[3] </p></blockquote><p>原本一行的内容是 10字节，但现在只需要6字节，这还是因为长度比较少，极端情况一行都是黑色可以用2字节表示。<br>这个过程也是在和我的组长讨论后看上去比较简单可行的方式。<br>后来发现传统的方式是偏向<strong>横向压缩</strong>，对我们的图像更加偏向<strong>纵向线条</strong>，所以后来换成了纵向的<strong>RLE</strong>方式，不过那是后来的事情了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取到像素坐标点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bitmap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, List&lt;Point&gt;&gt; <span class="title function_">getCoordinateData</span><span class="params">(Bitmap bitmap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap == <span class="literal">null</span>) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;getCoordinateData() called with: bitmap is null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得缩放后的宽高</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> bitmap.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> bitmap.getHeight();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;getRegenBitmap after compress: width = &quot;</span> + width + <span class="string">&quot;,height = &quot;</span> + height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 判断颜色比较遍历像素 并填充替换=====</span></span><br><span class="line">        <span class="comment">// 保存所有的像素的数组，图片宽×高</span></span><br><span class="line">        <span class="type">int</span>[] pixels = <span class="keyword">new</span> <span class="title class_">int</span>[width * height];</span><br><span class="line"></span><br><span class="line">        bitmap.getPixels(pixels, <span class="number">0</span>, width, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> pixels.length;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, List&lt;Point&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        List&lt;Point&gt; listY = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Point&gt; listW = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Point&gt; listG = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Point point;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">clr</span> <span class="operator">=</span> pixels[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">red</span> <span class="operator">=</span> Color.red(clr);</span><br><span class="line">            <span class="type">int</span> <span class="variable">green</span> <span class="operator">=</span> Color.green(clr);</span><br><span class="line">            <span class="type">int</span> <span class="variable">blue</span> <span class="operator">=</span> Color.blue(clr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isArrow(red, green, blue)) &#123; <span class="comment">//箭头黄色</span></span><br><span class="line">                pixels[i] = Color.YELLOW;</span><br><span class="line">                point = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">                point.y = i / width;</span><br><span class="line">                point.x = i % width;</span><br><span class="line">                listY.add(point);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWhite(red, green, blue)) &#123;<span class="comment">//线条白色</span></span><br><span class="line"><span class="comment">//                pixels[i] = Color.WHITE;</span></span><br><span class="line">                pixels[i] = Color.GRAY;</span><br><span class="line">                point = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">                point.y = i / width;</span><br><span class="line">                point.x = i % width;</span><br><span class="line">                listG.add(point);</span><br><span class="line"><span class="comment">//                listW.add(point);</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBuilding(red, green, blue)) &#123;<span class="comment">//建筑灰色</span></span><br><span class="line">                pixels[i] = Color.GRAY;</span><br><span class="line">                point = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">                point.y = i / width;</span><br><span class="line">                point.x = i % width;</span><br><span class="line">                listG.add(point);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlue(red, green, blue)) &#123; <span class="comment">//道路黑色</span></span><br><span class="line">                pixels[i] = Color.BLACK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//其他默认黑色</span></span><br><span class="line">                pixels[i] = Color.BLACK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        ImageUtils.save(Bitmap.createBitmap(pixels, width, height, Bitmap.Config.RGB_565),</span></span><br><span class="line"><span class="comment">//                (PathUtils.getInternalAppCachePath() + File.separator + &quot;cross1.png&quot;)</span></span><br><span class="line"><span class="comment">//                , Bitmap.CompressFormat.PNG);</span></span><br><span class="line">        map.put(<span class="number">1</span>, listY);</span><br><span class="line">        map.put(<span class="number">2</span>, listW);</span><br><span class="line">        map.put(<span class="number">3</span>, listG);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RLE行程压缩算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RLEPoint</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//为了确保只有1字节，点的个数最多127</span></span><br><span class="line">        <span class="keyword">private</span> Point startPoint;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLen</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Point <span class="title function_">getStartPoint</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startPoint;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&#123;len = &quot;</span> + len + <span class="string">&quot;, start:&quot;</span> + startPoint + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用RLE行程长度编码压缩，(按照纵坐标来压)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> originPoints</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, List&lt;RLEPoint&gt;&gt; <span class="title function_">covertRLEPoint</span><span class="params">(Map&lt;Integer, List&lt;Point&gt;&gt; originPoints)</span> &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;RLEPoint&gt;&gt; dest = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, List&lt;Point&gt;&gt;&gt; iterator = originPoints.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, List&lt;Point&gt;&gt; entry = iterator.next();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            List&lt;Point&gt; points = entry.getValue();</span><br><span class="line"></span><br><span class="line">            dest.put(key, convertPoint2RLE(points));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扩展RLE, 相同长度的再合并, 减少那些散点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> originRLEPoints</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, List&lt;RLEPointsExt&gt;&gt; <span class="title function_">covertRLEPointExt</span><span class="params">(Map&lt;Integer, List&lt;RLEPoint&gt;&gt; originRLEPoints)</span> &#123;</span><br><span class="line">        Map&lt;Integer, List&lt;RLEPointsExt&gt;&gt; dest = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, List&lt;RLEPoint&gt;&gt;&gt; iterator = originRLEPoints.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, List&lt;RLEPoint&gt;&gt; entry = iterator.next();</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            List&lt;RLEPoint&gt; points = entry.getValue();</span><br><span class="line"></span><br><span class="line">            dest.put(key, convertRLEPoint2Ext(points));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在经过整理后再去最终得到压缩后的集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取到需要的像素坐标点</span></span><br><span class="line">       Map&lt;Integer, List&lt;Point&gt;&gt; picData = CrossBitmapUtil.getCoordinateData(newBitmap);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**使用RLE行程长度来对像素坐标点进行编码压缩(按照纵坐标来压)**/</span></span><br><span class="line">       Map&lt;Integer, List&lt;CrossBitmapUtil.RLEPoint&gt;&gt; rlePoints = CrossBitmapUtil.covertRLEPoint(picData);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**扩展RLE, 相同长度的再合并, 减少那些散点**/</span></span><br><span class="line">       Map&lt;Integer, List&lt;CrossBitmapUtil.RLEPointsExt&gt;&gt; rleDataExt = CrossBitmapUtil.covertRLEPointExt(rlePoints);</span><br><span class="line"></span><br><span class="line">       Set&lt;Integer&gt; keySet = rleDataExt.keySet();</span><br><span class="line">       size += keySet.size(); <span class="comment">/** NByte: Color **/</span></span><br><span class="line"></span><br><span class="line">       Collection&lt;List&lt;CrossBitmapUtil.RLEPointsExt&gt;&gt; values = rleDataExt.values();</span><br><span class="line">       <span class="keyword">for</span> (List&lt;CrossBitmapUtil.RLEPointsExt&gt; segments : values) &#123;<span class="comment">//RLE Ext segments</span></span><br><span class="line">           size += <span class="number">1</span>;<span class="comment">/** 1Byte: segments **/</span></span><br><span class="line">           <span class="keyword">for</span> (CrossBitmapUtil.RLEPointsExt ext : segments) &#123;</span><br><span class="line">               size += <span class="number">1</span>;<span class="comment">/** 1Byte: RLE Len **/</span></span><br><span class="line">               size += <span class="number">2</span>;<span class="comment">/** 2Byte: Point Count **/</span></span><br><span class="line">               size += <span class="number">2</span> * ext.getPoints().size();  <span class="comment">/** NByte: Points **/</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="采用彩色方案的过程"><a href="#采用彩色方案的过程" class="headerlink" title="采用彩色方案的过程:"></a>采用彩色方案的过程:</h2><p>在几经波折后我们的硬件系统终于升高，可以满足加载<code>jepg</code>图片格式，给了我们直接传输图片的可能。<br> 我们拿到的图片是从高德SDK的路口放大图回调中获取的分辨率是<code>500*320</code>,这个分辨率的图片可以很清晰的展示图像。举例其中一个：</p><p> <img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/8C9hfnb6FdKqpWS.png" alt="cross_1.png-c"></p><p> 直接调用自带方式压缩至指定分辨率尝试：</p><p> <img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/9A8Bzb24GKemWj1.png" alt="image.png-c"></p><p>可以看到效果是不错的，可是当我转存文件大小时发现文件大小是<code>9.2k</code>大小，可是这个大小对于时效性比较高的信息，我们设备的蓝牙传输过程会变长导致可能这张图片可能要很久才能显示出来，这就需要进一步压缩质量提高传输速度。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/LJWBhalEy3oxPNT.png" alt="image.png-c"></p><p>之后因为已经因为之前集成了OpenCV所以就尝试用OpenCV的方式对比了一下在质量为15的情况下图片对比：</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/ucNfktiB2MpyQr4.png" alt="image.png-c"></p><p>除了最直观的大小压缩不同外，OpenCV的<code>INTER_AREA</code>方法还是克服了一些干扰的波纹情况，这里为了便捷我还是放到颗粒感比较强的时候。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实经过整体过程后发现逻辑串通起来没有当初感觉的那么复杂，但是这个其中反反复复验证的过程或许才是最有意义的收获。又尝试着拓宽一些使用方式，对图像处理以及蓝牙之间的数据协议制定都有了新的认识。也为后续去做高德与谷歌的识别奠定了一些图像基础，等有空再整理一篇。</p><h2 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h2><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2020年04月01日23:27:47</td><td>初版整理过程</td></tr><tr><td>version 0.2</td><td>2020年07月22日17:31:26</td><td>添加彩色图片过程，格式微调</td></tr><tr><td>version 0.3</td><td>2022年02月08日17:49:01</td><td>更换图床为Github</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> Bitmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析HashMap（上）</title>
      <link href="/2020/01/08/%E6%B5%85%E6%9E%90HashMap/"/>
      <url>/2020/01/08/%E6%B5%85%E6%9E%90HashMap/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.2</p></blockquote><p>[TOC]</p><h3 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h3><p>HashMap是平时工作开发经常接触的数据结构，但很多时候疏于查看原理，在使用过程中会发生一些问题。最近根据自己所学与参考记录一下。结合其他相近数据结构<code>HashTable</code>，<code>LinkedHashMap</code>,<code>ConcurrentHashMap</code>等展开分析梳理。</p><blockquote><p>Java中对Map定义了接口<code>java.util.Map</code>，主要有<code>HashMap</code>，<code>HashTable</code>,<code>LinkedHashMap</code>,<code>TreeMap</code>四种常用实现类。继承关系如图所示（我盗用的美团的）</p></blockquote><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/HRMhQLwpZkEXTVW.jpg" alt="常见Map实现类继承关系图"></p><p>简单区分一下各自的特点：</p><ol><li><strong>HashMap</strong>：根据键的哈希值来存储数据，内部大体是<strong>数组+链表</strong>结构，很多情况下可以直接从数组的位置直接获取到值，因此有很快的访问速度。同时允许<strong>至多一条</strong>键为<code>null</code>的数据存入，而值的null不限制。缺点是虽然访问速度很快，但是遍历的顺序是不确定的，也不保证在结构变动后元素顺序不变化，所以<code>HashMap</code>如果直接用来表示顺序很多情况是不满足的，同时它的每个操作也不是线程安全，在并发情况容易产生问题，<code>JDK 1.8</code>之前甚至可能产生<strong>死循环</strong>（头插法变动导致环产生），但可以用<code>Collections</code>类中的<code>synchronizedMap()</code>来包装实现线程安全的能力，本质上也是采用<code>synchronized</code>来加锁。</li><li><strong>HashTable</strong>：相较于线程不安全的<code>HashMap</code>,<code>HashTable</code>在以前编程初期经常用来当做解决各种奇怪问题的解药。由于内部对数据结构修改的方法都是用<code>synchronized</code>修饰，所以是<strong>线程安全</strong>的，同一时间只有一个线程能进行写操作，所以并发性受到限制。在<code>JDK 1.5</code>后用<code>ConcurrentHashMap</code>类来代替，相较于暴力的大段加锁，<code>ConcurrentHashMap</code>采用分段锁等优化（<code>ConcurrentHashMap</code>本身的优化也具有迭代性是一个持续性的表现比如对分段锁的懒加载，volatile等操作）</li><li><strong>LinkedHashMap</strong>：是<code>HashMap</code>的子类，通过引入新的辅助<strong>双向链表</strong>使得结构支持表示顺序，如<strong>插入顺序</strong>或<strong>访问顺序</strong>。其中将构造函数<code>LinkedHashMap(int initialCapacity,                   float loadFactor,                   boolean accessOrder)</code>中传入 <code>accessOrder</code> 为 <code>true</code>时支持按照访问顺序遍历的特性，基于这个数据结构的天然特性安卓的很多LRU缓存机制都能见到它的身影。</li><li><strong>TreeMap</strong>：实现了<code>SortedMap</code>接口，会根据键值的hashCode做排序，默认是<strong>升序</strong>，也可以指定排序的比较器，在迭代时可以按照需要的情况遍历数据。同时由于涉及排序，所以key一定要实现<code>Comparable</code>接口，或者在构造时传入自定义的比较器<code>Comparator</code>，否则会抛出<code>java.lang.ClassCastException</code>异常。</li></ol><p>在介绍上面四种常见Map类型时我们发现很多情况这个为了实现这种映射关系时都必须要保证一个大前提，那就是<strong>key的值要是不可变的</strong>。简而言之就是在他们存入Map后，它的<code>hashCode</code>一定不能变更，否则很可能下次查找就找不到需要的数据位置。所以我打算从<code>hashCode</code>讲起。</p><h3 id="如何确定哈希值"><a href="#如何确定哈希值" class="headerlink" title="如何确定哈希值"></a>如何确定哈希值</h3><p>在开发过程中，我们在覆写对象<code>equals（）</code>方法后常常需要覆写<code>hashCode()</code>，那么不覆写会产生什么问题呢？</p><p>我们知道在Java中如果不覆写对象的<code>equals（）</code>方法，在用<code>equals（）</code>进行比较时默认使用内存地址进行比较的，那很多情况物理上是不一样的对象但逻辑上可能是相同的对象。比如从反序列化中读取到的数据，这个是新的对象，但逻辑上可能和我们实际来说是一个。这个时候如果我们覆写了<code>equals（）</code>方法，加入了具体的判断逻辑，比如:<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/dFEkrS2tsxBIeH9.jpg" alt="没覆写equals方法比较地址引用"></p><p>如果加入覆写逻辑则可以为相同：<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/jwX7ch5L2d3f9Uv.jpg" alt="覆写equals逻辑比较覆写方法"></p><p>那为什么还要覆写<code>hashCode</code>呢？<br>这是由于<code>java.lang.Object</code>中对于<code>hashCode</code>的约定：<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/VkpaBl796gG52ih.jpg"></p><p>简而言之就是：运行期间如果两个对象的<code>equals</code>判定为一样，那么<code>hashCode</code>一定一样，反之如果<code>equals</code>不一样，那么<code>hashCode</code>一定不一样，同时在对象比较的方法内信息如果没有改动的话必须每次<code>hashCode</code>值还是一样。</p><p>所以当我们改动了判定的信息条件时，也必须改动合理的<code>hashCode</code>判断方法以确保我们符合这个定义。但同时需要谨慎区分，如果<code>equals</code>一样那么两个对象一定一样。但由于存在<strong>哈希碰撞</strong>，反之我们并不能确保相同的<code>hashCode</code>代表同一个对象。</p><blockquote><p>哈希的计算方式一定要尽量散列，让不同对象尽可能产生不同的值来减少碰撞，这样才能用此来当做一种消息摘要来快速比对是否是同一个内容。</p></blockquote><p>好在这种头疼的问题大多数情况不用我们考虑，默认的<code>hashCode()</code>方法已经能满足我们大部分情况。但思考一个问题，既然是随机散列，那么就一定可能产生负数，而我们知道在数组中是必须从0开始的自然数，很多时候还需要做进一步处理，比如<code>HashTable</code>中会将<code>hashCode</code>再与一个大素数计算得到正数再放入数组中。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/nOgJtVTjDUPck8v.jpg"></p><p>这样我们便能通过简单的一次计算快速得到数据在数组中的存储位置，以此来提高访问性能。</p><h3 id="大体结构"><a href="#大体结构" class="headerlink" title="大体结构"></a>大体结构</h3><p>从实现上来说，<code>HashMap</code>的结构是<strong>数组+ （链表&#x2F;红黑树）结合</strong><br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/G8AVthCgfSI1dzL.jpg"></p><p>这里是<code>JDK 1.8</code> ，之前没有转换红黑树的过程。<br>其中<code>HashMap</code>一个重要的字段就是 <code>Node[] table</code>即哈希桶数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>&#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123; ... &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上没一个<code>Node</code>都是一个键值对，而上图的每一个黑色点便是一个<code>Node</code>对象。</p><h3 id="存储过程概述"><a href="#存储过程概述" class="headerlink" title="存储过程概述"></a>存储过程概述</h3><p>当有元素进来，会进行判断是否存在，如果不存在，则直接将元素放入对应的数组中去。但当已经有数据时，就有了<code>Hash碰撞</code>。常见的解决方法有几种：开放地址，再哈希，链地址等等。<a href="https://blog.csdn.net/zeb_perfect/article/details/52574915">解决Hash碰撞冲突方法总结</a></p><p><code>HashMap</code>采用了链地址法，在每个元素上都追加了一个链表结构，以此来存储相同哈希值的元素。所以在早先版本如果没有红黑树的转换，极端情况当所有数据的哈希值都一样的情况下，<code>HashMap</code>会退化为单链表，查找速度也从<code>O(1)</code>退化为<code>0（N）</code>。</p><blockquote><p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。</p></blockquote><p>同时对于<code>JDK 1.8</code>中当一个链表元素超过8个的时候还会进行红黑树转化即<code>treeify</code>过程来增强性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="type">int</span> modCount;  </span><br><span class="line"><span class="type">int</span> size;  </span><br></pre></td></tr></table></figure><p><code>HashMap</code>默认开辟的存储空间为16，<code>theshold = length * loadFactor</code> 当存储到12后开始进行<strong>扩容</strong>，大小就是之前的<strong>两倍</strong>。扩容过程意味着需要时间，开辟新的空间并拷贝过去。所以意味着我们尽量避免扩容的发生，又不想浪费太多空间。<code>0.75</code>是默认的负载因子，通常可以比较好的平衡空间与性能，除非特殊需求。</p><p>具体过程分析与区别或许还是需要阅读源码才可以，这部分看了一些但还需要再总结归纳一下有时间写到下篇中分析。</p><p>（未完待续…）</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap</a></li></ul><h3 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h3><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2020年01月08日20:50:03</td><td>初版整理</td></tr><tr><td>version 0.2</td><td>2022年02月08日17:49:01</td><td>更换图床为Github</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令介绍</title>
      <link href="/2019/09/04/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/09/04/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-常用命令介绍"><a href="#Git-常用命令介绍" class="headerlink" title="Git 常用命令介绍"></a>Git 常用命令介绍</h1><blockquote><p>version 0.4</p></blockquote><p>[TOC]</p><h2 id="1-基础说明"><a href="#1-基础说明" class="headerlink" title="1. 基础说明"></a>1. 基础说明</h2><h3 id="git-介绍"><a href="#git-介绍" class="headerlink" title="git 介绍"></a>git 介绍</h3><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000">Git简介</a></p><h3 id="git-常见概念"><a href="#git-常见概念" class="headerlink" title="git 常见概念"></a>git 常见概念</h3><ul><li><code>commit</code>: 提交</li><li><code>commitId</code>: 提交对应的哈希值</li><li><code>branch</code>: 分支</li><li><code>HEAD</code>: 头指针</li><li><code>origin</code>: 远端</li><li><code>conflict</code>：冲突</li><li><code>merge</code>: 合并</li><li><code>rebase</code>：变基</li><li><code>fetch</code>: 更新</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="/media/15676511913048.jpg"></p><p><strong>Git 可以大概分为三个区</strong><br>Git 本地数据管理，大概可以分为三个区，<code>工作区</code>,<code>暂存区</code>和<code>版本库</code>。</p><ul><li><p><code>工作区</code>（Working Directory）<br>是我们直接编辑的地方，例如 Android Studio 打开的项目，记事本打开的文本等，肉眼可见，直接操作。</p></li><li><p><code>暂存区</code>（Stage 或 Index）<br>数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。</p></li><li><p><code>版本库</code>（commit History）<br>存放已经提交的数据，push 的时候，就是把这个区的数据 push 到远程仓库了。</p></li></ul><h3 id="add命令"><a href="#add命令" class="headerlink" title="add命令"></a>add命令</h3><ul><li><p><code>git add . </code>：他会监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区，包括文件内容修改(modified)以及新文件(new)，但不包括被删除的文件。（当前目录与子目录）</p></li><li><p><code>git add -u </code>：他仅监控已经被add的文件（即tracked file），他会将被修改的文件提交到暂存区。add -u 不会提交新文件（untracked file）。（git add –update的缩写）</p></li><li><p><code>git add -A</code> ：是上面两个功能的合集（git add –all的缩写）（所有目录）</p></li></ul><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><ul><li><a href="https://github.com/github/gitignore">Github:gitignore</a></li></ul><h3 id="commit-checkout"><a href="#commit-checkout" class="headerlink" title="commit&#x2F;checkout"></a>commit&#x2F;checkout</h3><ul><li>检出分支</li><li>检出文件</li><li>还原文件</li></ul><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p><code>git diff [&lt;options&gt;] [&lt;commit&gt;] [--] [&lt;path&gt;...]</code></p><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><ul><li><code>git reset</code> : 清空git add 的文件</li><li><code>git reset HEAD</code>：默认mixed模式</li></ul><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_f7b0d1ce6201da58cdcd2c983a16ed1c.jpg"></p><h3 id="clone-fetch-pull"><a href="#clone-fetch-pull" class="headerlink" title="clone &amp; fetch &amp; pull"></a>clone &amp; fetch &amp; pull</h3><ul><li><code>git clone [-b &lt;name&gt;] &lt;repository&gt; [&lt;directory&gt;]</code></li><li><code>fetch</code>: </li><li><code>pull</code>: fetch + merge</li></ul><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><ul><li><p><code>git stash save &quot;save message&quot;</code>  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</p></li><li><p><code>git stash list</code>  ：查看stash了哪些存储</p></li><li><p><code>git stash show</code> ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加<code>stash@&#123;$num&#125;</code>，比如第二个 <code>git stash show stash@&#123;1&#125;</code></p></li><li><p><code>git stash show -p</code> : 显示第一个存储的改动，如果想显示其他存存储，命令：<code>git stash show  stash@&#123;$num&#125;  -p</code> ，比如第二个：<code>git stash show  stash@&#123;1&#125;  -p</code></p></li><li><p><code>git stash apply</code> :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@{0}，如果要使用其他个，<code>git stash apply stash@&#123;$num&#125;</code> ， 比如第二个：<code>git stash apply stash@&#123;1&#125;</code></p></li><li><p><code>git stash pop</code> ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@{0}，如果要应用并删除其他stash，命令：git stash pop stash@{$num} ，比如应用并删除第二个：git stash pop stash@{1}</p></li><li><p><code>git stash drop stash@&#123;$num&#125;</code> ：丢弃stash@{$num}存储，从列表中删除这个存储</p></li><li><p><code>git stash clear</code> ：删除所有缓存的stash</p></li></ul><h2 id="2-merge-rebase"><a href="#2-merge-rebase" class="headerlink" title="2. merge &amp; rebase"></a>2. merge &amp; rebase</h2><table><thead><tr><th align="center">说明&#x2F;方式</th><th align="center">merge</th><th align="center">rebase</th></tr></thead><tbody><tr><td align="center">特点</td><td align="center">自动创建一个新的commit,如果合并的时候遇到冲突，仅需要修改后重新commit</td><td align="center">会合并之前的commit历史</td></tr><tr><td align="center">优点</td><td align="center">记录了真实的commit情况，包括每个分支的详情</td><td align="center">得到更简洁的项目历史，去掉了merge commit</td></tr><tr><td align="center">缺点</td><td align="center">因为每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。</td><td align="center">如果合并出现代码问题不容易定位，因为re-write了history</td></tr></tbody></table><p>合并时如果出现冲突需要按照如下步骤解决：</p><ul><li>修改冲突部分</li><li>git add</li><li>git rebase –continue&#x2F;skip</li><li>不要在git add 之后习惯性的执行 git commit命令</li></ul><p><a href="http://gitbook.liuhui998.com/4_2.html">GitBook- rebase&amp;merge</a></p><h2 id="3-rebase-常见功能"><a href="#3-rebase-常见功能" class="headerlink" title="3. rebase 常见功能"></a>3. rebase 常见功能</h2><p><strong>梳理分支（合并提交，调整顺序，剔除等）</strong></p><h3 id="git-pull-–rebase"><a href="#git-pull-–rebase" class="headerlink" title="git pull –rebase"></a>git pull –rebase</h3><blockquote><p>当我们从远程拉代码的时候如果使用：git pull –rebase，则会以rebase的方式进行更新，而不是默认的merge。</p></blockquote><h3 id="git-rebase-–interactive"><a href="#git-rebase-–interactive" class="headerlink" title="git rebase –interactive"></a>git rebase –interactive</h3><p><code>git rebase [-i | --interactive] [&lt;options&gt;] [--exec &lt;cmd&gt;] [--onto &lt;newbase&gt;]                [&lt;upstream&gt; [&lt;branch&gt;]]</code></p><ul><li><code>p</code>：保留当前commit，不做处理。</li><li><code>r</code>：修改commit message。(<code>git commit --amend</code>)</li><li><code>e</code>：修改这个commit作的修改。比如某个commit漏掉了什么配置，想要再提交新的文件; 或者删除一些无用代码，等等都可以用这个命令。</li><li><code>s</code>：保留这个commit的修改，但是把它合并到前一个commit中。</li><li><code>d</code>：删除commit</li></ul><h3 id="不要在远程推送分支使用rebase操作"><a href="#不要在远程推送分支使用rebase操作" class="headerlink" title="不要在远程推送分支使用rebase操作"></a>不要在远程推送分支使用rebase操作</h3><p><a href="https://hellofrank.github.io/2018/04/27/Git-Rebase-%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99%E9%97%AE%E9%A2%98/">Git Rebase 黄金法则问题</a></p><h2 id="4-patch-cherry-pick"><a href="#4-patch-cherry-pick" class="headerlink" title="4. patch &amp; cherry-pick"></a>4. patch &amp; cherry-pick</h2><h3 id="patch-和diff-的区别"><a href="#patch-和diff-的区别" class="headerlink" title="patch 和diff 的区别"></a>patch 和diff 的区别</h3><p><a href="https://blog.csdn.net/liuhaomatou/article/details/54410361">如何使用git 生成patch 和打入patch</a></p><p>Git 提供了两种补丁方案，一是用git diff生成的UNIX标准补丁.diff文件，二是git format-patch生成的Git专用.patch 文件。<br><strong>.diff文件只是记录文件改变的内容，不带有commit记录信息,多个commit可以合并成一个diff文件。</strong><br><strong>.patch文件带有记录文件改变的内容，也带有commit记录信息,每个commit对应一个patch文件。</strong></p><p><a href="https://juejin.im/post/5b5851976fb9a04f844ad0f4">Git 打补丁– patch 和 diff 的使用</a></p><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><ul><li><p><code>git cherry-pick [--edit] [-n] [-m parent-number] [-s] [-x] [--ff]  [-S[&lt;keyid&gt;]] &lt;commit&gt;...</code></p></li><li><p><code>git cherry-pick &lt;commitId&gt;...</code></p></li></ul><p><a href="https://learngitbranching.js.org/?NODEMO">git 沙盒模式</a></p><h2 id="5-杂项"><a href="#5-杂项" class="headerlink" title="5. 杂项"></a>5. 杂项</h2><h3 id="协同工作流程"><a href="#协同工作流程" class="headerlink" title="协同工作流程"></a>协同工作流程</h3><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_bfd7665eab204f38b5b1986c361612b1.jpg"></p><p><a href="http://www.fwhyy.com/2018/06/Use-the-Merge-Request-working-mode-in-GitLab-in-the-team/">在团队中使用GitLab中的Merge Request工作模式</a></p><p><a href="https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md">Git工作流指南 - GitHub</a></p><h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><p><code>git revert &lt;commitId&gt;</code></p><h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h3><p>初始化<br><code>git submodule init</code><br>添加子仓库<br><code>git submodule add ssh://git@139.219.128.51:5837/zhengrong/CRBluetoothCore_android.git</code><br>更新子仓库<br><code>git submodule foreach git pull</code></p><p><a href="https://segmentfault.com/a/1190000003076028">使用Git Submodule管理子模块</a></p><h3 id="提交规范"><a href="#提交规范" class="headerlink" title="提交规范"></a>提交规范</h3><p> <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">Angular 团队的规范</a></p><ul><li>标题行: 必填, 描述主要修改类型和内容</li><li>主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等</li><li>页脚注释: 放 Breaking Changes 或 Closed Issues</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>(<span class="tag">&lt;<span class="name">scope</span>&gt;</span>): <span class="tag">&lt;<span class="name">subject</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BLANK</span> <span class="attr">LINE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BLANK</span> <span class="attr">LINE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://juejin.im/post/5b5d50bd5188251b3e646c5c">如何优雅地pull request</a></li><li><a href="https://juejin.im/post/5afc5242f265da0b7f44bee4">优雅的提交你的 Git Commit Message</a></li></ul><h3 id="辅助插件类"><a href="#辅助插件类" class="headerlink" title="辅助插件类"></a>辅助插件类</h3><ul><li><p>.gitconfig</p></li><li><p><a href="https://github.com/tj/git-extras/blob/master/Commands.md">GitHub:git-extras</a></p></li><li><p><a href="https://github.com/git-chglog/git-chglog">Github:git-chglog</a>:<br><code>git-chglog v1.10.8..v1.11.0 -&gt; CHANGELOG.md</code></p></li></ul><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_a30c37dcfe360d5768ac6c294f43bdf5.jpg" alt="git log"></p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/upload_0006f5062812cd866318a12fc317632b.jpg" alt="changlog"></p><h2 id="6-更新日志："><a href="#6-更新日志：" class="headerlink" title="6. 更新日志："></a>6. 更新日志：</h2><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2019年09月03日21:32:43</td><td>初版</td></tr><tr><td>version 0.2</td><td>2019年09月04日12:34:34</td><td>完善杂项介绍</td></tr><tr><td>version 0.3</td><td>2019年09月05日10:36:54</td><td>添加基础说明，添加部分杂项</td></tr><tr><td>version 0.4</td><td>2022年02月08日17:49:01</td><td>更换图床为Github</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓全局单例刷新Token</title>
      <link href="/2019/03/20/%E5%AE%89%E5%8D%93%E5%85%A8%E5%B1%80%E5%8D%95%E4%BE%8B%E5%88%B7%E6%96%B0Token/"/>
      <url>/2019/03/20/%E5%AE%89%E5%8D%93%E5%85%A8%E5%B1%80%E5%8D%95%E4%BE%8B%E5%88%B7%E6%96%B0Token/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.5</p></blockquote><p>[TOC]</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前阶段公司的业务比较忙,很长时间没有整理出来什么博客.最近刚空出些时间,简单再整理一些记录.</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因:"></a>产生原因:</h2><p>客户端是被动向服务器查询登录状态,一些网络请求需要一个刷新token来验证客户端是否处于登录态,是则可以进行用户操作,否则做登出操作.</p><p>刚开始直接单纯的每个请求刷新token,刷新token,然后请求是没什么问题的.</p><p>但是随着版本迭代,任务增多,有些时候,比如app首次启动, 会进行一些列用户相关操作, 比如拉取用户信息, 拉取特定的活动项目,这样一个刷新token的操作可能会并发, 而我们的服务端刷新token每次可能都会不一样,这就产生了一些问题. 以下会展开示意.</p><h2 id="之前的方案-并发刷新token"><a href="#之前的方案-并发刷新token" class="headerlink" title="之前的方案(并发刷新token)"></a>之前的方案(并发刷新token)</h2><p>为了简化理解我画了几张图,来说明情况,为了表示并发,我用RequestA,RequestB,RequestC分别表示三个请求,Server表示服务端</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/5c91aaea82080.png" alt="~~理想状态~~刷新token"></p><p>可以看见理想状态下,其实是没什么问题,请求都能正常收到与发送,但前提是他们是只有<strong>当A请求完全完成后</strong>B的后续请求,刷新token才不会受到干扰.</p><h2 id="实际情况"><a href="#实际情况" class="headerlink" title="实际情况"></a>实际情况</h2><p>然而,提到了随着业务增多,实际中大多请求都是并发的,于是乎就有可能有下面的情况.</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/5c91aaea9b360.png" alt="实际刷新token"></p><p>可以看到,实际中,很有可能产生,A,B同时刷新token,而在A拿到新<strong>Token A</strong>去再一次请求时,B已经从服务器拿到了<strong>Token B</strong>导致了A请求又一次失败,随着并发的增多这种失败的可能性越来越多.</p><h2 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h2><p>我所想的是全局有一个单例的线程来掌管整个Token的刷新,并且这个token的刷新不是并发,而是队列,但是又不能让之后的请求变成队列. 否则简单的将所有请求变成队列即可,但实际情况我们根本不会让请求都是串行,无论从用户体验还是代码的书写上都是不好的.</p><p>所以在与iOS端讨论后,我们决定使用单一管理,并可阻塞的队列方式来管理token的请求过程,确保app内不会并发发送请求token的过程.</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/5c94407d7401e.png" alt="修改后刷新机制.png"></p><p>改进后就是主要几点:</p><ol><li>当A请求过期后,需要向<code>TokenManager</code>去请求token.</li><li><code>TokenManager</code>会阻塞住队列,让后来的B请求等待.</li><li>当刷新完成后,通知所有队列中的对象,因为这个<code>TokenManager</code>只负责刷新返回token一个职责</li><li>所有请求拿到新的token,再来并发执行而互不影响.</li></ol><h2 id="代码概要"><a href="#代码概要" class="headerlink" title="代码概要"></a>代码概要</h2><p>主要是实现一个任务队列,并要求阻塞, 因为刷新token也是一个异步请求,所以可以用<code>wait()</code>来阻塞住,当一次请求完成后,使用<code>notify()</code>来让队列继续执行,然后再加入一个超时规则,一段时间内,不会重新刷新token,加快之后的token请求</p><p>那么在安卓中,<code>HandlerThread</code>内部已经有了一个loop的实现,就很方便处理这中情景,而不必要自己去写一些任务队列与Loop,简化代码量.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单独开辟一个线程来处理looper</span></span><br><span class="line">tokenThread = <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;token-handlerThread&quot;</span>);</span><br><span class="line">tokenThread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Handler来处理消息</span></span><br><span class="line"> mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(tokenThread.getLooper()) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.obj != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                    <span class="keyword">case</span> WITH_RETRY:</span><br><span class="line">                        doGetOrRefreshTokenWithRetry(msg.arg1, (RefreshTokenListener) msg.obj);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> FORCE:</span><br><span class="line">                        doForceRefreshToken((RefreshTokenListener) msg.obj);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NORMAL:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        doGetOrRefreshToken((RefreshTokenListener) msg.obj);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                AILog.d(TAG, <span class="string">&quot;getTokenHandler : msg is null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>   初始化Handler去操作不同的请求方式</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接获取或刷新token</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doGetOrRefreshToken</span><span class="params">(RefreshTokenListener listener)</span> &#123;</span><br><span class="line">    <span class="comment">//AILog.d(TAG, &quot;doGetOrRefreshToken: &quot;);</span></span><br><span class="line">    <span class="keyword">if</span> (checkIsTokenExpired()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用CountDownLatch来阻塞</span></span><br><span class="line">            <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">            MobileAccount.getInst().refreshToken(mContext, <span class="keyword">new</span> <span class="title class_">MobileAccount</span>.RefreshCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(<span class="type">int</span> code, String refreshedToken)</span> &#123;</span><br><span class="line">                    userUpload(refreshedToken);</span><br><span class="line">                    lastToken = refreshedToken;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                        listener.onSuccess(refreshedToken);</span><br><span class="line">                    &#125;</span><br><span class="line">                    lastRefreshTime = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">//去掉阻塞</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLogout</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">                    AILog.e(TAG, <span class="string">&quot;doGetOrRefreshToken doLogout() called with: code = [&quot;</span> + code + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                        listener.doLogout(code);</span><br><span class="line">                    &#125;</span><br><span class="line">                    clear();</span><br><span class="line">                    <span class="comment">//去掉阻塞</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="type">int</span> errorCode)</span> &#123;</span><br><span class="line">                    AILog.e(TAG, <span class="string">&quot;doGetOrRefreshToken onError() called with: errorCode = [&quot;</span> + errorCode + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="literal">null</span>) &#123;</span><br><span class="line">                        listener.onError(errorCode);</span><br><span class="line">                    &#125;</span><br><span class="line">                    clear();</span><br><span class="line">                    <span class="comment">//去掉阻塞</span></span><br><span class="line">                    latch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//阻塞线程,并设置超时等待</span></span><br><span class="line">            waitUntilNotify(latch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//AILog.d(TAG, &quot;doGetOrRefreshToken with not fresh: &quot; + lastToken);</span></span><br><span class="line">        <span class="comment">//直接获得</span></span><br><span class="line">        listener.onSuccess(lastToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><del>当任务执行到访问网络刷新token时,通过信号量<code>wait()</code>阻塞住任务,当收到回调时<code>notify()</code>去执行,为了防止超时,内部起了一个定时器.</del>(已弃用Lock方式，发现有极少情况可能在加锁之前请求已经过来，导致锁一直不释放)</p><p>采用CountDownLatch来阻塞，防止之前如果速度过快导致lock时已经notify的过程，同时提升可读性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">waitUntilNotify</span><span class="params">(CountDownLatch latch)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (latch != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断是否还需要加锁</span></span><br><span class="line">            <span class="keyword">if</span> (latch.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                        latch.await();</span></span><br><span class="line">                    latch.await(REFRESH_EXPIRED_TIME, TimeUnit.SECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>阻塞当前线程，并等待一定时长，防止过多请求服务器导致token快速过期。以上是核心部分的简要说明。</p><p>外部通过<code>RefreshTokenListener</code>来处理token的回调,做相应的处理.<br>相对于外部请求,依然是无感知<code>TokenManager</code>的存在.</p><p>外部调用时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TokenManager.getInstance().getToken(<span class="keyword">new</span> <span class="title class_">TokenManager</span>.RefreshTokenListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doLogOut</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="更新说明"><a href="#更新说明" class="headerlink" title="更新说明:"></a>更新说明:</h2><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2019年03月20日11:29:20</td><td>初版</td></tr><tr><td>version 0.2</td><td>2019年03月22日09:56:52</td><td>修改TokenManager图表</td></tr><tr><td>version 0.3</td><td>2019年03月28日10:21:02</td><td>优化代码</td></tr><tr><td>version 0.4</td><td>2020年04月28日18:12:59</td><td>改用CountDownLatch简化</td></tr><tr><td>version 0.5</td><td>2022年02月08日17:49:01</td><td>更换图床为Github</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为macOS开启局域网ss</title>
      <link href="/2019/01/15/%E4%B8%BAmacOS%E5%BC%80%E5%90%AF%E5%B1%80%E5%9F%9F%E7%BD%91ss/"/>
      <url>/2019/01/15/%E4%B8%BAmacOS%E5%BC%80%E5%90%AF%E5%B1%80%E5%9F%9F%E7%BD%91ss/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.2</p></blockquote><h2 id="1-通过-brew-安装-privoxy"><a href="#1-通过-brew-安装-privoxy" class="headerlink" title="1. 通过 brew 安装 privoxy"></a>1. 通过 brew 安装 privoxy</h2><p><code>brew install privoxy</code></p><p>安装后查看安装目录</p><p><code>brew privoxy list</code></p><p>打开目录并编辑config文件</p><p><code>open /usr/local/etc/privoxy/config</code></p><h2 id="2-添加需要映射的端口"><a href="#2-添加需要映射的端口" class="headerlink" title="2. 添加需要映射的端口"></a>2. 添加需要映射的端口</h2><p>本地ss端口<br><code>forward-socks5t   /               127.0.0.1:1086 .</code>(注意要有默认的点)</p><p>转发的端口</p><p><code>listen-address  0.0.0.0:6666</code></p><h3 id="3-运行privoxy"><a href="#3-运行privoxy" class="headerlink" title="3. 运行privoxy"></a>3. 运行privoxy</h3><p><code>sudo /usr/local/Cellar/privoxy/3.0.26/sbin/privoxy /usr/local/etc/privoxy/config </code></p><h3 id="4-添加开机启动"><a href="#4-添加开机启动" class="headerlink" title="4. 添加开机启动"></a>4. 添加开机启动</h3><p>将变量添加到 <code>.bash_profile</code> 中: </p><p><code>export PATH=$PATH:/usr/local/Cellar/privoxy/3.0.26/sbin/</code></p><p>新建一个文本文档, 将如下添加后, 修改后缀名为.sh</p><blockquote></blockquote><p># 添加开机启动:<br>ln -sfv &#x2F;usr&#x2F;local&#x2F;opt&#x2F;privoxy&#x2F;*.plist ~&#x2F;Library&#x2F;LaunchAgents<br># 开启 Privoxy:<br>launchctl load ~&#x2F;Library&#x2F;LaunchAgents&#x2F;homebrew.mxcl.privoxy.plist<br># 如果不需要用 launchctl 就直接运行:<br>privoxy &#x2F;usr&#x2F;local&#x2F;etc&#x2F;privoxy&#x2F;config</p><p>在终端运行 :</p><p>eg: <code>sh test.sh</code></p><h2 id="5-查看是否已经开启"><a href="#5-查看是否已经开启" class="headerlink" title="5. 查看是否已经开启"></a>5. 查看是否已经开启</h2><p><code>netstat -na | grep 6666</code></p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/FzwTQU.png" alt="监听端口"></p><p>如上, 已经成功监听</p><h2 id="6-更新说明"><a href="#6-更新说明" class="headerlink" title="6. 更新说明:"></a>6. 更新说明:</h2><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2019年01月15日16:10:55</td><td>初版</td></tr><tr><td>version 0.2</td><td>2022年02月08日17:49:01</td><td>更换图床为Github</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git日常(二)----常用git 命令</title>
      <link href="/2018/11/01/git%E6%97%A5%E5%B8%B8-%E4%BA%8C-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/11/01/git%E6%97%A5%E5%B8%B8-%E4%BA%8C-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.2</p></blockquote><p>[TOC]</p><h2 id="1-日志类"><a href="#1-日志类" class="headerlink" title="1. 日志类"></a>1. 日志类</h2><blockquote><p>显示每次更新的文件修改统计信息</p></blockquote><p><code>git log --stat</code></p><blockquote><p>显示最近两次提交</p></blockquote><p><code>git log -p -2</code></p><blockquote><p>根据自定义格式过滤日志</p></blockquote><p><code>git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</code></p><blockquote><p>使用ASCII表示简单git图</p></blockquote><p><code>git log --pretty=format:&quot;%h %s&quot; --graph</code></p><blockquote><p>显示最近一周的提交</p></blockquote><p><code>git log --since=1.weeks</code></p><blockquote><p>显示指定作者的提交</p></blockquote><p><code>git log --author=xuxin</code></p><blockquote><p>显示指定区间段的提交</p></blockquote><p><code>git log --author=xuxin --since=&quot;2018-04-01&quot; --before=&quot;2018-10-01&quot;</code></p><blockquote><p>显示提交但未合并的信息</p></blockquote><p><code>git log --pretty=&quot;%h - %s&quot; --author=xuxin --since=&quot;2018-04-01&quot; \    --before=&quot;2018-10-08&quot; --no-merges -- t/</code></p><h2 id="2-检索类"><a href="#2-检索类" class="headerlink" title="2. 检索类"></a>2. 检索类</h2><blockquote><p>根据commit信息搜索提交</p></blockquote><p><code>git log -g --grep=&quot;KEYWORD&quot;</code><br><code>git log --all --grep=&#39;KEYWORD&#39;</code></p><blockquote><p>查找有关的关键字</p></blockquote><p><code>git log --all --pretty=\&quot;format:%Cgreen%H %Cblue%s\n%b%Creset\&quot; --name-status --grep KEYWORD</code></p><blockquote><p>根据CommitID查看所属分支</p></blockquote><p><code>git branch -a --contains CommitID</code></p><h2 id="3-操作类"><a href="#3-操作类" class="headerlink" title="3. 操作类"></a>3. 操作类</h2><blockquote><p>(未使用add)放弃本地所有更改</p></blockquote><p><code>git checkout .</code></p><blockquote><p>撤销特定文件 (<strong>注意<code>--</code></strong> )</p></blockquote><p><code>git checkout -- filepathname</code></p><blockquote><p>(已经使用add)放弃本地所有更改</p></blockquote><p><code>git reset --hard HEAD^</code></p><blockquote><p>回退到任意版本</p></blockquote><p><code>git reset --hard CommitID</code></p><blockquote><p>修改错误的提交</p></blockquote><p><code>git commit --amend</code></p><blockquote><p>查看某人提交的代码</p></blockquote><p><code>git log --author=&quot;xuxin&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -</code></p><blockquote><p>统计每个人提交的代码</p></blockquote><p><code>git log --format=&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#39;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#39; -; done</code></p><blockquote><p>查看提交者 前五名</p></blockquote><p><code>git log --pretty=&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 5</code></p><h2 id="4-注"><a href="#4-注" class="headerlink" title="4. 注:"></a>4. 注:</h2><blockquote><p>添加到全局变量中的代码(注意author修改)</p></blockquote><p><code>git config --global alias.lm  &quot;log --no-merges --color --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;xuxin&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></p><p><code>git config --global alias.lms  &quot;log --no-merges --color --stat --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;xuxin&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></p><p><code>git config --global alias.ls &quot;log --no-merges --color --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></p><p><code>git config --global alias.lss &quot;log --no-merges --color --stat --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code></p><p><code>git config --global alias.find &quot;log --all --pretty=\&quot;format:%Cred%cd\n%Cgreen%H %Cblue%s\n%b%Creset\&quot; --name-status --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --grep&quot;</code></p><blockquote><p>gitconfig中代码:</p></blockquote><p><code>[alias]     lm = log --no-merges --color --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;xuxin&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit     find = log --all --pretty=\&quot;format:%Cred%cd\n%Cgreen%H %Cblue%s\n%b%Creset\&quot; --name-status --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --grep     lss = log --no-merges --color --stat --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit     lms = log --no-merges --color --stat --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;xuxin&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit     ls = log --no-merges --color --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit</code></p><h3 id="4-2-参考"><a href="#4-2-参考" class="headerlink" title="4.2 参考:"></a>4.2 参考:</h3><ul><li><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">git 查看提交历史</a></p></li><li><p><a href="https://www.cnblogs.com/bellkosmos/p/5923439.html">git log命令全解析</a></p></li><li><p><a href="https://www.cnblogs.com/qufanblog/p/7606105.html">git 放弃本地修改</a></p></li><li><p><a href="https://www.jianshu.com/p/8fd14064c201">git代码行统计命令集</a></p></li></ul><h3 id="4-3-更新说明"><a href="#4-3-更新说明" class="headerlink" title="4.3 更新说明:"></a>4.3 更新说明:</h3><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 0.1</td><td>2018年10月09日15:45:06</td><td>初版</td></tr><tr><td>version 0.2</td><td>2018年10月24日15:51:51</td><td>添加代码统计命令</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git日常(一)----基础篇</title>
      <link href="/2018/09/30/git%E6%97%A5%E5%B8%B8-%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/2018/09/30/git%E6%97%A5%E5%B8%B8-%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 0.1</p></blockquote><p>[TOC]</p><h1 id="git-多用户配置流程"><a href="#git-多用户配置流程" class="headerlink" title="git 多用户配置流程"></a>git 多用户配置流程</h1><h2 id="1-生成自定义密钥文件"><a href="#1-生成自定义密钥文件" class="headerlink" title="1. 生成自定义密钥文件"></a>1. 生成自定义密钥文件</h2><p>进入目录<br><code>cd ~/.ssh/</code> 或 <code>cd /Users/arno/.ssh</code>  或  <code>cd .ssh</code></p><p>根据用户邮箱生成不同的key文件<br><code>ssh-keygen -t rsa -C &quot;davidxuxin@qq.com&quot;</code><br><code>ssh-keygen -t rsa -C &quot;xin.xu@carrbot.com&quot;</code></p><p>key分别设置别名 如: github_id_rsa,ileja_id_rsa</p><h2 id="2-将生成的key填入到相应"><a href="#2-将生成的key填入到相应" class="headerlink" title="2. 将生成的key填入到相应"></a>2. 将生成的key填入到相应</h2><p><a href="https://github.com/settings/keys">github</a> 或 <a href="http://code.cheluobo.cn/profile/keys">gitlab</a> 的SSH密钥中</p><p><code>cat github_id_rsa</code><br><code>cat ileja_id_rsa</code></p><h2 id="3-在-ssh目录下创建config-文件"><a href="#3-在-ssh目录下创建config-文件" class="headerlink" title="3. 在.ssh目录下创建config 文件"></a>3. 在.ssh目录下创建config 文件</h2><p><code>vim config</code></p><p>填写相关配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#github</span><br><span class="line">Host github.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">User daivdxuxin@qq.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">Port 443</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br><span class="line"></span><br><span class="line"># 该文件用于配置私钥对应的服务器</span><br><span class="line"># 配置公司账户(xin.xu@carrobot.com)</span><br><span class="line">Host git@code.cheluobo.cn</span><br><span class="line">HostName http://github.com</span><br><span class="line">User xin.xu@carrbot.com</span><br><span class="line">Port 5837</span><br><span class="line">IdentityFile ~/.ssh/ileja_id_rsa</span><br></pre></td></tr></table></figure><h2 id="4-在agent中添加自定义的key"><a href="#4-在agent中添加自定义的key" class="headerlink" title="4. 在agent中添加自定义的key"></a>4. 在agent中添加自定义的key</h2><p>后台启动ssh-agent<br><code>eval &quot;$(ssh-agent -s)&quot;</code></p><p>将自定义的key添加到agent中<br><code>ssh-add ~/.ssh/github_id_rsa</code><br><code>ssh-add ~/.ssh/ileja_id_rsa</code></p><h2 id="5-测试连接"><a href="#5-测试连接" class="headerlink" title="5. 测试连接"></a>5. 测试连接</h2><p><code>ssh -T git@github.com</code> 或 <code>ssh -vT git@github.com</code></p><p><code>git clone -b branch_meebot_1.5.0 git@42.159.143.73:guilbert/carrobot_lite_android.git</code></p><h2 id="6-常见问题解答"><a href="#6-常见问题解答" class="headerlink" title="6. 常见问题解答"></a>6. 常见问题解答</h2><ul><li><a href="https://help.github.com/categories/authenticating-to-github/">Github-常见SSH密钥问题</a></li><li><a href="https://help.github.com/articles/reviewing-your-ssh-keys/">Github-查看SSH密钥</a></li><li><a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/#adding-your-ssh-key-to-the-ssh-agent">Github-添加SSH 到ssh-agent</a></li><li><a href="https://help.github.com/articles/troubleshooting-ssh/">Github-SSH故障排除</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用日志过滤手册</title>
      <link href="/2018/05/11/%E5%B8%B8%E7%94%A8%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4%E6%89%8B%E5%86%8C/"/>
      <url>/2018/05/11/%E5%B8%B8%E7%94%A8%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="常用日志过滤手册-v0-1"><a href="#常用日志过滤手册-v0-1" class="headerlink" title="常用日志过滤手册 v0.1"></a>常用日志过滤手册 v0.1</h2><p>命令格式:</p><pre><code>[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</code></pre><h3 id="1-显示日志"><a href="#1-显示日志" class="headerlink" title="1. 显示日志"></a>1. 显示日志</h3><pre><code>adb logcat</code></pre><h3 id="2-过滤优先级"><a href="#2-过滤优先级" class="headerlink" title="2.  过滤优先级"></a>2.  过滤优先级</h3><table><thead><tr><th>标签</th><th>说明 (级别低-&gt;高)</th></tr></thead><tbody><tr><td>V</td><td>Verbos(级别最低)</td></tr><tr><td>D</td><td>Debug</td></tr><tr><td>I</td><td>Info</td></tr><tr><td>W</td><td>Warning</td></tr><tr><td>E</td><td>Error</td></tr><tr><td>F</td><td>Fatal</td></tr><tr><td>S</td><td>Silent(级别最高)</td></tr></tbody></table><p>按照某级别过滤日志:</p><pre><code>adb logcat *:W</code></pre><p>会将 <code>Warning</code>、<code>Error</code>、<code>Fatal</code> 和 <code>Silent</code> 日志输出。</p><h3 id="3-配合正则筛选日志"><a href="#3-配合正则筛选日志" class="headerlink" title="3. 配合正则筛选日志"></a>3. 配合正则筛选日志</h3><pre><code>adb logcat -v threadtime |grep --color = auto -iE &quot;XXX|YYY&quot;</code></pre><p>会将匹配 <code>XXX </code>和 <code>YYY </code>忽略大小写的匹配日志输出</p><h3 id="4-正则筛选日志文件-txt文件"><a href="#4-正则筛选日志文件-txt文件" class="headerlink" title="4. 正则筛选日志文件(txt文件)"></a>4. 正则筛选日志文件(txt文件)</h3><pre><code>grep --color=auto -iE &quot;XXX|YYY&quot; e:\desktop\1.txt</code></pre><p>会将 <code>1.txt</code> 匹配 <code>XXX </code>和 <code>YYY </code>忽略大小写的匹配日志输出</p><h3 id="5-根据正则关键字查看某一文件并输出到新的文件中"><a href="#5-根据正则关键字查看某一文件并输出到新的文件中" class="headerlink" title="5. 根据正则关键字查看某一文件并输出到新的文件中"></a>5. 根据正则关键字查看某一文件并输出到新的文件中</h3><pre><code>grep -rni &quot;OfflineChild&quot; 原始文件目录及名字 |tee 新文件目录及名字</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> adb </tag>
            
            <tag> logcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VPS快速部署手册</title>
      <link href="/2018/01/12/VPSSetting/"/>
      <url>/2018/01/12/VPSSetting/</url>
      
        <content type="html"><![CDATA[<h1 id="VPS快速部署手册"><a href="#VPS快速部署手册" class="headerlink" title="VPS快速部署手册"></a>VPS快速部署手册</h1><ul><li><p>version 0.1<br>基础配置<br>2018年1月10日17:40:33</p></li><li><p>version 0.2<br>添加了本地化,以及部分说明<br>2018年1月12日14:51:29</p></li></ul><blockquote><p><strong>注:本手册每个模块互相独立,按需参考即可</strong></p></blockquote><h2 id="1-部署SSR"><a href="#1-部署SSR" class="headerlink" title="1. 部署SSR"></a>1. 部署SSR</h2><blockquote><h3 id="1-1-安装依赖软件"><a href="#1-1-安装依赖软件" class="headerlink" title="1.1 安装依赖软件"></a>1.1 安装依赖软件</h3></blockquote><blockquote><p><strong>环境 Ubuntu 16.04.3 LTS</strong></p></blockquote><p>更新软件源</p><pre><code>apt-get update</code></pre><p>安装python pip</p><pre><code>apt-get install python-pip</code></pre><p>升级pip</p><pre><code>pip install --upgrade pip</code></pre><p>安装中文语言包</p><pre><code>apt-get install language-pack-zh-hant</code></pre><blockquote><h3 id="1-2-安装SSR"><a href="#1-2-安装SSR" class="headerlink" title="1.2 安装SSR"></a>1.2 安装SSR</h3></blockquote><p>安装SSR</p><pre><code>pip install shadowsocks</code></pre><p>配置ss json文件(参考1.3)</p><pre><code>vim /etc/shadowsocks.json</code></pre><p>使用screen开启服务</p><pre><code>screen -S ssr</code></pre><p>开启ss服务</p><pre><code>ssserver -c /etc/shadowsocks.json</code></pre><p>返回</p><pre><code>C -a-d</code></pre><p>重新连接开启ssr服务的screen</p><pre><code>screen -r ssr</code></pre><blockquote><h3 id="1-3-ssr配置文件"><a href="#1-3-ssr配置文件" class="headerlink" title="1.3 ssr配置文件"></a>1.3 ssr配置文件</h3></blockquote><pre><code>    &#123;    &quot;server&quot;:&quot;服务器外网ip&quot;, //&quot;server&quot;:&quot;198.96.88.112&quot;,    &quot;local_address&quot;:&quot;127.0.0.1&quot;,    &quot;local_port&quot;:1080,    &quot;timeout&quot;:300,    &quot;port_password&quot;:&#123;    &quot;端口号&quot;:&quot;密码&quot;,//(&quot;8888&quot;,&quot;123456&quot;)    &quot;端口号&quot;:&quot;密码&quot;//(&quot;&quot;8889&quot;,&quot;123457&quot;)    &#125;,    &quot;method&quot;:&quot;rc4-md5&quot;,//加密规则    &quot;protocol&quot;: &quot;origin&quot;,//混淆插件    &quot;protocol_param&quot;: &quot;&quot;,    &quot;obfs&quot;: &quot;plain&quot;,    &quot;obfs_param&quot;: &quot;&quot;,    &quot;workers&quot;: 1&#125;</code></pre><h2 id="2-NextCloud安装"><a href="#2-NextCloud安装" class="headerlink" title="2. NextCloud安装"></a>2. NextCloud安装</h2><blockquote><p>2.1 基础软件安装</p></blockquote><p>Apache 安装</p><pre><code>sudo apt-get install apache2</code></pre><p>MySQL 安装</p><pre><code>sudo apt-get install mysql-server mysql-client</code></pre><p>PHP 安装</p><pre><code>sudo apt-get install phpmyadmin</code></pre><blockquote><p>2.2 安装Nextcloud</p></blockquote><pre><code>//下载文件wget https://download.nextcloud.com/server/releases/nextcloud-12.0.4.tar.bz2//解压文件bz2格式tar -xjvf nextcloud-12.0.4.tar.bz2//解压文件zip格式unzip nextcloud-12.0.4.zip//将文件拷贝至服务器目录cp -r nextcloud /var/www/html///修改nextcloud权限</code></pre><blockquote><p>2.3 启用额外插件</p></blockquote><p>重新启动模块</p><pre><code>sudo a2enmod rewritesudo a2enmod headers</code></pre><p>zip模块</p><pre><code>apt-get install php-zip</code></pre><p>curl模块</p><pre><code>apt-get install php-curl</code></pre><p>修改php.ini文件</p><pre><code>vim /etc/php/7.0/apache2/php.ini</code></pre><p>修改以下内容</p><pre><code>;extension=php_mbstring.dll ==&gt;extension=php_mbstring.dll</code></pre><p>修改apache2.conf文件</p><pre><code>vim /etc/apache2/apache2.conf</code></pre><p>修改以下内容</p><pre><code>&lt;Directory /var/www/&gt;Options Indexes FollowSymLinksAllowOverride None ==&gt; AllowOverride AllRequire all granted&lt;/Directory&gt;</code></pre><p>重启Apache</p><pre><code>/etc/init.d/apache2 restart</code></pre><blockquote><p>2.4 配置文件位置</p></blockquote><p>Apache2配置文件</p><pre><code>vim /etc/apache2/apache2.conf</code></pre><p>php配置文件路径</p><pre><code>vim /etc/php/7.0/apache2/php.ini</code></pre><p>apache2启动</p><pre><code>/etc/init.d/apache2 start/etc/init.d/apache2 restart/etc/init.d/apache2 stop</code></pre><p>移除文件 </p><pre><code>rm -rf /var/www/html/nextcloud/</code></pre><h2 id="3-本地化Ubuntu"><a href="#3-本地化Ubuntu" class="headerlink" title="3.本地化Ubuntu"></a>3.本地化Ubuntu</h2><h3 id="3-1-安装中文支持及语言包"><a href="#3-1-安装中文支持及语言包" class="headerlink" title="3.1 安装中文支持及语言包"></a>3.1 安装中文支持及语言包</h3><p>安装中文语言包</p><pre><code>apt-get install language-pack-zh-hant language-pack-zh-hans</code></pre><p>配置相关环境变量：</p><pre><code>vim /etc/environment</code></pre><p>在文件中增加语言和编码的设置：</p><pre><code>LANG=&quot;zh_CN.UTF-8&quot;LANGUAGE=&quot;zh_CN:zh:en_US:en&quot;</code></pre><p>如:</p><pre><code>LANG=&quot;zh_CN.UTF-8&quot;LANGUAGE=&quot;zh_CN:zh:en_US:en&quot;PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games&quot;</code></pre><p>重新设置本地配置：</p><pre><code>dpkg-reconfigure locales</code></pre><h3 id="3-2-更改时区"><a href="#3-2-更改时区" class="headerlink" title="3.2 更改时区"></a>3.2 更改时区</h3><p>选择时区</p><pre><code>tzselect</code></pre><p>复制文件到&#x2F;etc目录下</p><pre><code>sudo cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</code></pre><p>如改为中国北京时间,直接输入以下(重新连接会消失)</p><pre><code>TZ=&#39;Asia/Beijing&#39;; export TZ</code></pre><p>配置时间文件(重新连接不会消失)</p><pre><code>//选择Asia - Shanghaidpkg-reconfigure tzdata</code></pre><p>重启VPS</p><pre><code>reboot</code></pre>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spicy</title>
      <link href="/2017/12/22/Spicy/"/>
      <url>/2017/12/22/Spicy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 1.3</p></blockquote><h1 id="Spicy-Android端信息展示软件"><a href="#Spicy-Android端信息展示软件" class="headerlink" title="Spicy (Android端信息展示软件)"></a>Spicy (Android端信息展示软件)</h1><p> 最近感觉自己实际编码经验太少，花了大概三周跟着慕课去学习完成这个demo练习，收获很多。除了组件化思想外，同时也练习了下mvp模式和许多开发中的小技巧，整体完成下来还是有很多收获。</p><h2 id="功能概览"><a href="#功能概览" class="headerlink" title="功能概览"></a>功能概览</h2><p>多图加载,动态添加布局,视频播放，组件化开发，封装了通用sdk，并采用mvp重构。集成推送分享，生成扫描二维码，图表生成，评论，搜索登录,版本更新等功能。</p><p><img src="https://i.imgur.com/5vF88Fd.gif"><br>大图浏览</p><p><img src="https://i.imgur.com/yfzxRB4.png"><br>二维码生成</p><p><img src="https://i.imgur.com/4ERxjzG.png"><br>未启动状态推送</p><p><img src="https://i.imgur.com/0JIWwEq.gif"><br>视频播放</p><p><img src="https://i.imgur.com/lgmEDR4.png"><br>walle多渠道打包</p><p>项目地址:<a href="https://gitee.com/arnofrost/Spicy">Spicy</a></p><h3 id="更新说明："><a href="#更新说明：" class="headerlink" title="更新说明："></a>更新说明：</h3><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 1.0</td><td>2017-12-6 16:36:20</td><td>软件初步搭建</td></tr><tr><td>version 1.1</td><td>2017-12-22 10:02:13</td><td>第一个正式发行版完成</td></tr><tr><td>version 1.2</td><td>2022年02月08日17:49:01</td><td>更换图床为Github</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View绘制机制</title>
      <link href="/2017/11/09/View%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/11/09/View%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="View的绘制机制"><a href="#View的绘制机制" class="headerlink" title="View的绘制机制"></a>View的绘制机制</h1><h2 id="1-view树的绘制流程"><a href="#1-view树的绘制流程" class="headerlink" title="1. view树的绘制流程"></a>1. view树的绘制流程</h2><p>(当Activity接收到用户触摸焦点的时候, 会被请求去绘制布局;请求是由安卓Framework层去处理绘制,从根节点去对布局进行测量和绘制ViewRoot类中)</p><pre><code>measure -&gt; layout -&gt; draw</code></pre><p>measure: 是否重新计算视图大小; </p><blockquote><p>(递归)view 会对所有子元素进行测量, 测量过程从父的ViewGroup传递到子View里面, 经过子元素的递归, 测量好所有子元素的长度, 再进行递归, 反复之后就完成了ViewGroup的测量;</p></blockquote><p>layout: 是否需要重新安置视图位置;</p><p>draw: 是否需要重绘;</p><h2 id="2-measure"><a href="#2-measure" class="headerlink" title="2. measure"></a>2. measure</h2><h3 id="2-1-ViewGroup-LayoutParams"><a href="#2-1-ViewGroup-LayoutParams" class="headerlink" title="2.1 ViewGroup.LayoutParams:"></a>2.1 ViewGroup.LayoutParams:</h3><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208181358.png"></p><p>用来指定视图的高度和宽度</p><h3 id="2-2-MeasureSpec-测量规格"><a href="#2-2-MeasureSpec-测量规格" class="headerlink" title="2.2 MeasureSpec(测量规格):"></a>2.2 MeasureSpec(测量规格):</h3><p>32位int值 , 最高两位表示SpecMode是模式占位符, 后面30位表示测量规格的大小;</p><blockquote><p>在一个空间measure过程中, 会将这个View的LayoutParams结合父容器生成一个MeasureSpec, MeasureSpec就会规定好怎样去测量这个View容器的大小, 返回给父容器, 父容器根据这个去测量大小</p></blockquote><table><thead><tr><th>模式名称</th><th>模式数值</th><th>实际数值</th></tr></thead><tbody><tr><td>UNSPECIFIED</td><td>00</td><td>000000000000000000001111011000</td></tr><tr><td>EXACTLY</td><td>01</td><td>000000000000000000001111011000</td></tr><tr><td>AT_MOST</td><td>10</td><td>000000000000000000001111011000</td></tr></tbody></table><pre><code>UNSPECIFIED: 不确定, 父控件不会对子控件有任何约束, 只要小于手机屏幕宽和高;EXACTLY: 父容器会对子视图确定一个大小, 无论子视图有多大, 都必须限定在父容器给定的范围内;AT_MOST : 父容器为所有子视图指定一个最大的尺寸, 子视图所有的大小都必须在这个范围内;</code></pre><h3 id="2-3-measure-重要的回调方法"><a href="#2-3-measure-重要的回调方法" class="headerlink" title="2.3 measure 重要的回调方法:"></a>2.3 measure 重要的回调方法:</h3><p>measure(): 调用onMeasure();<br>树遍历所有子结点;</p><p>onMeasure(): 将所有测量的规格传递给setMeasuredDimension();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line"><span class="comment">// setMeasuredDimension是用来通知测量结束的, 必须调用</span></span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setMeasuredDimension(): 完成整个测测量过程;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method must be called by &#123;<span class="doctag">@link</span> #onMeasure(int, int)&#125; to store the</span></span><br><span class="line"><span class="comment">     * measured width and measured height. Failing to do so will trigger an</span></span><br><span class="line"><span class="comment">     * exception at measurement time.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> measuredWidth The measured width of this view.  May be a complex</span></span><br><span class="line"><span class="comment">     * bit mask as defined by &#123;<span class="doctag">@link</span> #MEASURED_SIZE_MASK&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #MEASURED_STATE_TOO_SMALL&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> measuredHeight The measured height of this view.  May be a complex</span></span><br><span class="line"><span class="comment">     * bit mask as defined by &#123;<span class="doctag">@link</span> #MEASURED_SIZE_MASK&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #MEASURED_STATE_TOO_SMALL&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setMeasuredDimension</span><span class="params">(<span class="type">int</span> measuredWidth, <span class="type">int</span> measuredHeight)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">optical</span> <span class="operator">=</span> isLayoutModeOptical(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">            <span class="type">Insets</span> <span class="variable">insets</span> <span class="operator">=</span> getOpticalInsets();</span><br><span class="line">            <span class="type">int</span> <span class="variable">opticalWidth</span>  <span class="operator">=</span> insets.left + insets.right;</span><br><span class="line">            <span class="type">int</span> <span class="variable">opticalHeight</span> <span class="operator">=</span> insets.top  + insets.bottom;</span><br><span class="line"></span><br><span class="line">            measuredWidth  += optical ? opticalWidth  : -opticalWidth;</span><br><span class="line">            measuredHeight += optical ? opticalHeight : -opticalHeight;</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimensionRaw(measuredWidth, measuredHeight);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注: 如果父视图发现子视图传递的大小可能不对时候, 会再次请求子视图进行测量, 如果给定的数值超过了规定大小或者太小, 父视图会赋值给AT_MOST 或者 EXACTLY的形式,再次对子视图进行测量</p></blockquote><h2 id="3-layout"><a href="#3-layout" class="headerlink" title="3. layout"></a>3. layout</h2><p>会根据测量所得到的尺寸来确定layout摆放的位置, 子视图的具体位置是相对于父视图而言的, 必须实现onLayout(), 重新摆放;</p><p>layout(): 调用onLayout();</p><p>onLayout(): 一定要实现;<br>可以去分析LinearLayout中的实现;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called from layout when this view should</span></span><br><span class="line"><span class="comment">    * assign a size and position to each of its children.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * Derived classes with children should override</span></span><br><span class="line"><span class="comment">    * this method and call layout on each of</span></span><br><span class="line"><span class="comment">    * their children.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> changed This is a new size or position for this view</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left Left position, relative to parent</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> top Top position, relative to parent</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right Right position, relative to parent</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> bottom Bottom position, relative to parent</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>是一个树形结构, 依次从ViewGroup进行位置摆放</p><h2 id="4-draw"><a href="#4-draw" class="headerlink" title="4. draw"></a>4. draw</h2><p>两个比较容易混淆的回调方法:</p><h3 id="4-1-invalidate-请求安卓系统"><a href="#4-1-invalidate-请求安卓系统" class="headerlink" title="4.1 invalidate(): 请求安卓系统;"></a>4.1 invalidate(): 请求安卓系统;</h3><pre><code>如果视图大小没有发生变化, 则不会调用layout放置过程;</code></pre><h3 id="4-2-requestLayout-当布局方向变化-尺寸变化就回去调用"><a href="#4-2-requestLayout-当布局方向变化-尺寸变化就回去调用" class="headerlink" title="4.2 requestLayout(): 当布局方向变化, 尺寸变化就回去调用;"></a>4.2 requestLayout(): 当布局方向变化, 尺寸变化就回去调用;</h3><pre><code>会触发measure, layout过程, 但不会调用draw方法</code></pre>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机制 </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广播</title>
      <link href="/2017/11/09/%E5%B9%BF%E6%92%AD/"/>
      <url>/2017/11/09/%E5%B9%BF%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="1-广播"><a href="#1-广播" class="headerlink" title="1. 广播"></a>1. 广播</h2><h3 id="1-1-广播定义"><a href="#1-1-广播定义" class="headerlink" title="1.1 广播定义"></a>1.1 广播定义</h3><p>(类似观察者模式)<br>在Android中，Broadcast是一种广泛运用的在应用程序之间的传输信息的机制， Android中我们要发送的广播内容是一个Intent，这个Itent中可以携带我们要传送的数据。</p><p>*1. 广播实现的不同程序间的数据传输与共享（只要和发送广播的Action相同的接收者都可以接收到）<br>*2. 广播接收者通知作用（在程序中通过广播接收者来更新UI，避免了Service与Activity进行交互）</p><h3 id="1-2-广播场景"><a href="#1-2-广播场景" class="headerlink" title="1.2 广播场景"></a>1.2 广播场景</h3><p>A. 同一App内具有多个进程的不同组件之间的消息通信<br>B. 不同App间的组件之间消息通信(推广运营)</p><h3 id="1-3-广播种类"><a href="#1-3-广播种类" class="headerlink" title="1.3 广播种类"></a>1.3 广播种类</h3><ol><li>Nromal Broadcast : Context.sendBroadcast(普通广播)</li><li>System Broadcast: Context.sendOrderedBroadcast(有序广播\系统广播)</li><li>Local  Broadcast: 只在自身App内传播(本地广播)</li></ol><h2 id="2-实现广播-receiver-接收Broadcast"><a href="#2-实现广播-receiver-接收Broadcast" class="headerlink" title="2. 实现广播-receiver(接收Broadcast)"></a>2. 实现广播-receiver(接收Broadcast)</h2><p>1.静态注册: 注册完成就一直运行(Manifest文件中,Activity销毁仍能接收广播,缺点:不灵活)<br>2. 动态注册,跟随Activity的生命周期(onDestroy中要销毁,跟随Activity)</p><p>区别: 动态在代码中调用 registerReceiver<br>        静态在Manifest里写入</p><p>| 实现方式&#x2F;区别 | 声明| 生命周期|<br>|—|—|—|—|—|—|<br>| 动态注册| registerReceiver| 跟随Activity|<br>| 静态注册| Manifest| 被销毁了仍能运行接收|</p><h2 id="3-广播实现机制"><a href="#3-广播实现机制" class="headerlink" title="3. 广播实现机制"></a>3. 广播实现机制</h2><h3 id="3-1-自定义广播接收者BroadcastReceiver-并复写onReceive-方法"><a href="#3-1-自定义广播接收者BroadcastReceiver-并复写onReceive-方法" class="headerlink" title="3.1  自定义广播接收者BroadcastReceiver,并复写onReceive()方法;"></a>3.1  自定义广播接收者BroadcastReceiver,并复写onReceive()方法;</h3><h3 id="3-2-通过Binder机制想-AMS-Activity-Manager-Service-进行注册"><a href="#3-2-通过Binder机制想-AMS-Activity-Manager-Service-进行注册" class="headerlink" title="3.2. 通过Binder机制想*AMS(Activity Manager Service) 进行注册;"></a>3.2. 通过Binder机制想*AMS(Activity Manager Service) 进行注册;</h3><h3 id="3-3-广播发送这通过Binder机制向AMS发送广播"><a href="#3-3-广播发送这通过Binder机制向AMS发送广播" class="headerlink" title="3.3  广播发送这通过Binder机制向AMS发送广播;"></a>3.3  广播发送这通过Binder机制向AMS发送广播;</h3><h3 id="3-4-AMS查找符合相应条件-IntentFilter-Permission等-的BroadcastReceiver-将广播发送到BroadcastReceiver-一般情况下是Activity-相应的消息循环队列中"><a href="#3-4-AMS查找符合相应条件-IntentFilter-Permission等-的BroadcastReceiver-将广播发送到BroadcastReceiver-一般情况下是Activity-相应的消息循环队列中" class="headerlink" title="3.4  AMS查找符合相应条件(IntentFilter&#x2F;Permission等) 的BroadcastReceiver, 将广播发送到BroadcastReceiver(一般情况下是Activity) 相应的消息循环队列中;"></a>3.4  AMS查找符合相应条件(IntentFilter&#x2F;Permission等) 的BroadcastReceiver, 将广播发送到BroadcastReceiver(一般情况下是Activity) 相应的消息循环队列中;</h3><h3 id="3-5-消息循环执行拿到此广播-回调BroadcastReceiver中的onReceive-方法"><a href="#3-5-消息循环执行拿到此广播-回调BroadcastReceiver中的onReceive-方法" class="headerlink" title="3.5  消息循环执行拿到此广播, 回调BroadcastReceiver中的onReceive()方法;"></a>3.5  消息循环执行拿到此广播, 回调BroadcastReceiver中的onReceive()方法;</h3><blockquote><p>*AMS:AMS是作为管理Android系统组件的核心服务，他在SystemServer执行run()方法的时候被创建，并运行在独立的进程中。具体来说就是SystemServer管理着Android中所有的系统服务，这些系统服务的生命周期回调都由SystemServer去调度负责。</p></blockquote><h2 id="4-LoacalBroadcastManager详解"><a href="#4-LoacalBroadcastManager详解" class="headerlink" title="4. LoacalBroadcastManager详解"></a>4. LoacalBroadcastManager详解</h2><h3 id="4-1-使用它发送的广播将只在自身内传播-不必担心泄露隐私数据"><a href="#4-1-使用它发送的广播将只在自身内传播-不必担心泄露隐私数据" class="headerlink" title="4.1 使用它发送的广播将只在自身内传播, 不必担心泄露隐私数据;"></a>4.1 使用它发送的广播将只在自身内传播, 不必担心泄露隐私数据;</h3><h3 id="4-2-其他App无法对你的App发送该广播"><a href="#4-2-其他App无法对你的App发送该广播" class="headerlink" title="4.2 其他App无法对你的App发送该广播"></a>4.2 其他App无法对你的App发送该广播</h3><p> 因为你的App根本不可能收到其他非自身应用发送的广播, 避免了安全漏洞的利用;(防止其他人获取到action 并篡改, 如植入广告等)</p><h3 id="4-3-比系统全局广播更高效"><a href="#4-3-比系统全局广播更高效" class="headerlink" title="4.3 比系统全局广播更高效;"></a>4.3 比系统全局广播更高效;</h3><p>在LocalBroadcastReceiver中三个集合类:</p><h4 id="4-3-1-mReceivers"><a href="#4-3-1-mReceivers" class="headerlink" title="4.3.1 mReceivers:"></a>4.3.1 mReceivers:</h4><p>是一个HashMap,key是receiver , value是intentfilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt; mReceivers</span><br></pre></td></tr></table></figure><h4 id="4-3-2-mActions"><a href="#4-3-2-mActions" class="headerlink" title="4.3.2 mActions:"></a>4.3.2 mActions:</h4><p>key是Action, value 是arrylist ,是对应的receiverRecord</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; mActions</span><br></pre></td></tr></table></figure><h4 id="4-3-3-mPendingBroadcasts"><a href="#4-3-3-mPendingBroadcasts" class="headerlink" title="4.3.3 mPendingBroadcasts:"></a>4.3.3 mPendingBroadcasts:</h4><p>存储BroadcastRecord对象的(intent和receivers) 作用:存储和发送广播的action匹配的ReceiverRecord的集合,在执行时会遍历的集合里面广播接收器(存储了广播接收器的存储器)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mPendingBroadcasts</span><br><span class="line">            = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;BroadcastRecord&gt;();</span><br></pre></td></tr></table></figure><h4 id="4-3-4-注册方法-registerReceiver"><a href="#4-3-4-注册方法-registerReceiver" class="headerlink" title="4.3.4 注册方法:registerReceiver"></a>4.3.4 注册方法:registerReceiver</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Register a receive for any local broadcasts that match the given IntentFilter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receiver The BroadcastReceiver to handle the broadcast.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filter Selects the Intent broadcasts to be received.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #unregisterReceiver</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">            <span class="type">ReceiverRecord</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReceiverRecord</span>(filter, receiver);</span><br><span class="line">            ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver);</span><br><span class="line">            <span class="keyword">if</span> (filters == <span class="literal">null</span>) &#123;</span><br><span class="line">                filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;IntentFilter&gt;(<span class="number">1</span>);</span><br><span class="line">                mReceivers.put(receiver, filters);</span><br><span class="line">            &#125;</span><br><span class="line">            filters.add(filter); <span class="comment">//添加过滤规则</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;filter.countActions(); i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> filter.getAction(i);</span><br><span class="line">                ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action);</span><br><span class="line">                <span class="keyword">if</span> (entries == <span class="literal">null</span>) &#123;</span><br><span class="line">                    entries = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ReceiverRecord&gt;(<span class="number">1</span>);</span><br><span class="line">                    mActions.put(action, entries);</span><br><span class="line">                &#125;</span><br><span class="line">                entries.add(entry);<span class="comment">//将里面的Filter分别建立了Arraylist映射,通过广播接收器来接收</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-5-unregisterReceiver"><a href="#4-3-5-unregisterReceiver" class="headerlink" title="4.3.5 unregisterReceiver:"></a>4.3.5 unregisterReceiver:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unregister a previously registered BroadcastReceiver.  &lt;em&gt;All&lt;/em&gt;</span></span><br><span class="line"><span class="comment">     * filters that have been registered for this BroadcastReceiver will be</span></span><br><span class="line"><span class="comment">     * removed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> receiver The BroadcastReceiver to unregister.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #registerReceiver</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">            ArrayList&lt;IntentFilter&gt; filters = mReceivers.remove(receiver);</span><br><span class="line">            <span class="keyword">if</span> (filters == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;filters.size(); i++) &#123;</span><br><span class="line">                <span class="type">IntentFilter</span> <span class="variable">filter</span> <span class="operator">=</span> filters.get(i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;filter.countActions(); j++) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> filter.getAction(j);</span><br><span class="line">                    ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action);</span><br><span class="line">                    <span class="keyword">if</span> (receivers != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;receivers.size(); k++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (receivers.get(k).receiver == receiver) &#123;</span><br><span class="line">                                receivers.remove(k);<span class="comment">//将myreceiver中的广播接收器删除</span></span><br><span class="line">                                k--;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (receivers.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            mActions.remove(action);<span class="comment">//把mActions中集合类删除</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-3-6-sendBroadcast"><a href="#4-3-6-sendBroadcast" class="headerlink" title="4.3.6 sendBroadcast:"></a>4.3.6 sendBroadcast:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (receivers != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;receivers.size(); i++) &#123;</span><br><span class="line">                        receivers.get(i).broadcasting = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mPendingBroadcasts.add(<span class="keyword">new</span> <span class="title class_">BroadcastRecord</span>(intent, receivers));<span class="comment">//过滤之后的广播记录</span></span><br><span class="line">                    <span class="keyword">if</span> (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123;<span class="comment">//判断是否有消息</span></span><br><span class="line">                        mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-LocalBroadcastMananger-高效的原因"><a href="#4-4-LocalBroadcastMananger-高效的原因" class="headerlink" title="4.4 LocalBroadcastMananger 高效的原因"></a>4.4 LocalBroadcastMananger 高效的原因</h3><h4 id="4-4-1-内部通过HandlersendBroadcast-方法"><a href="#4-4-1-内部通过HandlersendBroadcast-方法" class="headerlink" title="4.4.1 内部通过HandlersendBroadcast()方法"></a>4.4.1 内部通过HandlersendBroadcast()方法</h4><p>主要是它内部通过HandlersendBroadcast()方法含义并非平时所用,它的sendBroadcast()方法其实是通过handler发送一个Message实现的;</p><h4 id="4-3-2-内部通过Handler来实现广播发送"><a href="#4-3-2-内部通过Handler来实现广播发送" class="headerlink" title="4.3.2 内部通过Handler来实现广播发送"></a>4.3.2 内部通过Handler来实现广播发送</h4><p>既然是它内部通过Handler来实现广播发送的,那么相比系统广播通过Binder实现肯定高效,同事用Handler来实现,别的应用无法像我们的应用发送该广播,而我们的应用内发送的广播也不会离开我们的应用;</p><h4 id="4-3-3-LocalBroadcastMananger-内部协作"><a href="#4-3-3-LocalBroadcastMananger-内部协作" class="headerlink" title="4.3.3 LocalBroadcastMananger 内部协作"></a>4.3.3 LocalBroadcastMananger 内部协作</h4><p>主要是靠这两个集合:mReceivers和mActions, 还有一个List集合mPedingBroadcasts,  这个主要就是存储待接收的广播对象;</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机制 </tag>
            
            <tag> 广播 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HandlerThread</title>
      <link href="/2017/11/08/HandlerThread/"/>
      <url>/2017/11/08/HandlerThread/</url>
      
        <content type="html"><![CDATA[<h1 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h1><h2 id="1-Handler是什么"><a href="#1-Handler是什么" class="headerlink" title="1.Handler是什么?"></a>1.Handler是什么?</h2><h3 id="1-1-handlerThread产生背景"><a href="#1-1-handlerThread产生背景" class="headerlink" title="1.1 handlerThread产生背景"></a>1.1 handlerThread产生背景</h3><p>开启Thread子线程进行耗时操作</p><p>多次创建和销毁线程是很消耗系统资源的</p><p>(通过阻塞等待)</p><blockquote><p>handler + thread + looper</p></blockquote><p>一个内部有looper的thread </p><p>(普通handler如果创建在子线程, 由于handler消息处理需要一个messagequeen的looper, 但默认创建子线程时候没有looper就会发生异常报错;<br>如果想在子线程中创建一个handler就必须手动初始化looper,调用looper.loop()方法开启循环)</p><h3 id="1-2-handlerThread-的特点"><a href="#1-2-handlerThread-的特点" class="headerlink" title="1.2 handlerThread 的特点"></a>1.2 handlerThread 的特点</h3><ul><li>HandlerThread 本质上是一个线程类, 它继承了Thread;</li><li>HandlerThread 有自己的内部Looper对象, 可以进行looper循环;</li><li>通过获取HandlerThread的looper对象传递给Handler对象,可以在handleMessage()方法中执行异步任务;</li><li>有点是不会有阻塞, 减少了对性能的消耗;</li><li>缺点是不能同时进行多任务的处理, 需要等待进行处理, 处理效率较低;</li><li>与线程池注重并发不同, HandlerThread是一个串行队列, HandlerThread背后只有一个线程;</li></ul><h2 id="2-HandlerThread源码解析"><a href="#2-HandlerThread源码解析" class="headerlink" title="2. HandlerThread源码解析"></a>2. HandlerThread源码解析</h2><h3 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1  构造方法"></a>2.1  构造方法</h3><p>构造方法里可设置名称和优先级;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HandlerThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    mPriority = Process.THREAD_PRIORITY_DEFAULT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a HandlerThread.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> priority The priority to run the thread at. The value supplied must be from </span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> android.os.Process&#125; and not from java.lang.Thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HandlerThread</span><span class="params">(String name, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    mPriority = priority;<span class="comment">//设置优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-onLooperPrepared-空方法"><a href="#2-2-onLooperPrepared-空方法" class="headerlink" title="2.2 onLooperPrepared()空方法"></a>2.2 onLooperPrepared()空方法</h3><p>可以在需要的时候去复写它, 它执行在loop之前;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Call back method that can be explicitly overridden if needed to execute some</span></span><br><span class="line"><span class="comment">    * setup before Looper loops.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLooperPrepared</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-run-方法"><a href="#2-3-run-方法" class="headerlink" title="2. 3 run()方法;"></a>2. 3 run()方法;</h3><p>synchronized: 当有两个并发线程访问同一个对象, 一个时间内只能有一个线程得到执行;<br>而另一个线程也要执行, 就必须等待另一个线程也执行完;(这里通知的是getLooper()中的wait())</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mTid = Process.myTid();</span><br><span class="line">        Looper.prepare();<span class="comment">//  初始化looper</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;<span class="comment">// 保证线程间数据安全</span></span><br><span class="line">            mLooper = Looper.myLooper();</span><br><span class="line">            notifyAll();<span class="comment">// 通知当前等待的线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        Process.setThreadPriority(mPriority);<span class="comment">// 给线程设定优先级(可以解决内存泄露*1)</span></span><br><span class="line">        onLooperPrepared();</span><br><span class="line">        Looper.loop();<span class="comment">// 开启循环</span></span><br><span class="line">        mTid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-getLooper"><a href="#2-4-getLooper" class="headerlink" title="2.4 getLooper():"></a>2.4 getLooper():</h3><p>在获取mylooper时候存在一个同步问题, 只有当上面线程创建成功, looper对象也创建成功时, 才会通知下面的;wait();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment">     * or for any reason isAlive() returns false, this method will return null. If this thread</span></span><br><span class="line"><span class="comment">     * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Looper <span class="title function_">getLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="literal">null</span>) &#123; <span class="comment">// 如果looper没创建成功则一直阻塞</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();<span class="comment">// 被run()方法中的notifyAll()通知</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mLooper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-quit"><a href="#2-5-quit" class="headerlink" title="2.5 quit():"></a>2.5 quit():</h3><p>退出消息循环, 退出线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Quits the handler thread&#x27;s looper.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Causes the handler thread&#x27;s looper to terminate without processing any</span></span><br><span class="line"><span class="comment">    * more messages in the message queue.</span></span><br><span class="line"><span class="comment">    * &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Any attempt to post messages to the queue after the looper is asked to quit will fail.</span></span><br><span class="line"><span class="comment">    * For example, the &#123;<span class="doctag">@link</span> Handler#sendMessage(Message)&#125; method will return false.</span></span><br><span class="line"><span class="comment">    * &lt;/p&gt;&lt;p class=&quot;note&quot;&gt;</span></span><br><span class="line"><span class="comment">    * Using this method may be unsafe because some messages may not be delivered</span></span><br><span class="line"><span class="comment">    * before the looper terminates.  Consider using &#123;<span class="doctag">@link</span> #quitSafely&#125; instead to ensure</span></span><br><span class="line"><span class="comment">    * that all pending work is completed in an orderly manner.</span></span><br><span class="line"><span class="comment">    * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> True if the looper looper has been asked to quit or false if the</span></span><br><span class="line"><span class="comment">    * thread had not yet started running.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> #quitSafely</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">quit</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> getLooper();</span><br><span class="line">       <span class="keyword">if</span> (looper != <span class="literal">null</span>) &#123;</span><br><span class="line">           looper.quit();</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-quitSafely"><a href="#2-6-quitSafely" class="headerlink" title="2.6 quitSafely():"></a>2.6 quitSafely():</h3><p>退出消息循环, 退出线程(效率上不是很高, 但更安全)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Quits the handler thread&#x27;s looper safely.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Causes the handler thread&#x27;s looper to terminate as soon as all remaining messages</span></span><br><span class="line"><span class="comment">    * in the message queue that are already due to be delivered have been handled.</span></span><br><span class="line"><span class="comment">    * Pending delayed messages with due times in the future will not be delivered.</span></span><br><span class="line"><span class="comment">    * &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment">    * Any attempt to post messages to the queue after the looper is asked to quit will fail.</span></span><br><span class="line"><span class="comment">    * For example, the &#123;<span class="doctag">@link</span> Handler#sendMessage(Message)&#125; method will return false.</span></span><br><span class="line"><span class="comment">    * &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment">    * If the thread has not been started or has finished (that is if</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #getLooper&#125; returns null), then false is returned.</span></span><br><span class="line"><span class="comment">    * Otherwise the looper is asked to quit and true is returned.</span></span><br><span class="line"><span class="comment">    * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> True if the looper looper has been asked to quit or false if the</span></span><br><span class="line"><span class="comment">    * thread had not yet started running.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">quitSafely</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">Looper</span> <span class="variable">looper</span> <span class="operator">=</span> getLooper();</span><br><span class="line">       <span class="keyword">if</span> (looper != <span class="literal">null</span>) &#123;</span><br><span class="line">           looper.quitSafely();</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机制 </tag>
            
            <tag> HandlerThread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntentService</title>
      <link href="/2017/11/07/IntentService/"/>
      <url>/2017/11/07/IntentService/</url>
      
        <content type="html"><![CDATA[<h1 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h1><h1 id="1-IntentService是什么"><a href="#1-IntentService是什么" class="headerlink" title="1. IntentService是什么"></a>1. IntentService是什么</h1><h2 id="1-1-特殊的Service"><a href="#1-1-特殊的Service" class="headerlink" title="1.1 特殊的Service"></a>1.1 特殊的Service</h2><p>&#x2F;&#x2F;继承了Service,可以执行<strong>高优先级</strong>的任务, 封装了HandlerThread和Handler</p><ul><li>本质上是一种特殊的Service, 继承自Service并且本身就是一个抽象类</li><li>它的内部通过HandlerThread 和 Handler 实现异步操作</li></ul><blockquote><p>是继承并处理<strong>异步同步请求</strong>的一个类, 在IntentService内有一个工作线程来处理耗时操作, 启动IntentService的方式和启动传统的Service一样, 同时, 当任务执行完后, IntentService 会自动停止, 而不需要我们手动去控制stopSelf(), 另外, 可以启动IntentService多次, 而每一个耗时操作都会以工作队列的方式在IntentService的onHandlerIntent回调方法中执行, 并且 , 每次只会执行一个工作线程, 执行完第一个再执行第二个;(<strong>串行</strong>)</p></blockquote><h2 id="2-IntentService使用方法"><a href="#2-IntentService使用方法" class="headerlink" title="2. IntentService使用方法"></a>2. IntentService使用方法</h2><h3 id="2-1-必须实现两个方法"><a href="#2-1-必须实现两个方法" class="headerlink" title="2.1 必须实现两个方法"></a>2.1 必须实现两个方法</h3><p>(创建IntentService时, 只需要实现onHandleIntent和构造方法, onHandleIntent为异步方法, 可以执行耗时操作)</p><p>写一个类继承IntentService</p><p>构造方法: 传入线程名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">IntentService</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    mName = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onHandleIntent()</code>: 进行Itent的耗时操作 后intent里携带信息, 并startService(intent),<br>最后MyIntentService.setUpdate(this);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(<span class="meta">@Nullable</span> Intent intent)</span></span><br></pre></td></tr></table></figure><h2 id="3-IntentService源码解析"><a href="#3-IntentService源码解析" class="headerlink" title="3. IntentService源码解析"></a>3. IntentService源码解析</h2><h3 id="3-1-onCreate"><a href="#3-1-onCreate" class="headerlink" title="3.1 onCreate()"></a>3.1 onCreate()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></span><br><span class="line">        <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></span><br><span class="line">        <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>.onCreate();</span><br><span class="line">        <span class="type">HandlerThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;IntentService[&quot;</span> + mName + <span class="string">&quot;]&quot;</span>);<span class="comment">// 创建了HandlerThread来进行异步消息传递</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        mServiceLooper = thread.getLooper();<span class="comment">// 传递的是HandlerThread的loop对象;</span></span><br><span class="line"><span class="comment">// (由于looper 对象和 HandlerThread绑定,而HandlerThread又是一个异步线程,把HandlerThread 持有的 looper 传递给 ServiceHandler</span></span><br><span class="line">这样ServiceHandler就变成了处理异步线程的执行类)</span><br><span class="line">        mServiceHandler = <span class="keyword">new</span> <span class="title class_">ServiceHandler</span>(mServiceLooper);<span class="comment">// 一个继承了Handler的Handler</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>intentService启动后还会调用onStartCommand();</p><h3 id="3-2-onStartCommand"><a href="#3-2-onStartCommand" class="headerlink" title="3.2 onStartCommand():"></a>3.2 onStartCommand():</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * You should not override this method for your IntentService. Instead,</span></span><br><span class="line"><span class="comment">     * override &#123;<span class="doctag">@link</span> #onHandleIntent&#125;, which the system calls when the IntentService</span></span><br><span class="line"><span class="comment">     * receives a start request.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> android.app.Service#onStartCommand</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onStartCommand</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="type">int</span> flags, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        onStart(intent, startId);<span class="comment">//实际操作都在onStart</span></span><br><span class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-onStart"><a href="#3-4-onStart" class="headerlink" title="3.4 onStart():"></a>3.4 onStart():</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="type">int</span> startId)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mServiceHandler.obtainMessage();</span><br><span class="line">        msg.arg1 = startId;</span><br><span class="line">        msg.obj = intent;</span><br><span class="line">        mServiceHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-ServiceHandler类"><a href="#3-5-ServiceHandler类" class="headerlink" title="3.5 ServiceHandler类:"></a>3.5 ServiceHandler类:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ServiceHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ServiceHandler</span><span class="params">(Looper looper)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            onHandleIntent((Intent)msg.obj);</span><br><span class="line">            stopSelf(msg.arg1);<span class="comment">// 如果没有参数会立即停止, 如果有参数会等待所有消息都处理完之后才会终止任务</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```java</span><br><span class="line">onHandleIntent: 是一个抽象方法, 在创建IntentService时一定要实现该方法(异步方法)</span><br><span class="line">如果执行完会立刻销毁, 当有多个服务时会明确到执行完最后一个服务才会销毁;</span><br><span class="line">stopSelf加参数;</span><br><span class="line"></span><br><span class="line">**(Service里不能做耗时操作, 而IntentService可以执行耗时操作)**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked on the worker thread with a request to process.</span></span><br><span class="line"><span class="comment">     * Only one Intent is processed at a time, but the processing happens on a</span></span><br><span class="line"><span class="comment">     * worker thread that runs independently from other application logic.</span></span><br><span class="line"><span class="comment">     * So, if this code takes a long time, it will hold up other requests to</span></span><br><span class="line"><span class="comment">     * the same IntentService, but it will not hold up anything else.</span></span><br><span class="line"><span class="comment">     * When all requests have been handled, the IntentService stops itself,</span></span><br><span class="line"><span class="comment">     * so you should not call &#123;<span class="doctag">@link</span> #stopSelf&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intent The value passed to &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *               android.content.Context#startService(Intent)&#125;.</span></span><br><span class="line"><span class="comment">     *               This may be null if the service is being restarted after</span></span><br><span class="line"><span class="comment">     *               its process has gone away; see</span></span><br><span class="line"><span class="comment">     *               &#123;<span class="doctag">@link</span> android.app.Service#onStartCommand&#125;</span></span><br><span class="line"><span class="comment">     *               for details.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">onHandleIntent</span><span class="params">(<span class="meta">@Nullable</span> Intent intent)</span>;</span><br></pre></td></tr></table></figure><p>本质上就是一个封装了HandlerThread 和 handler的异步框架</p><p>每次去实现时一定实现onHandleIntent()在里面进行耗时操作, 会按照顺序执行</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机制 </tag>
            
            <tag> IntentService </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AsyncTask</title>
      <link href="/2017/11/07/AsyncTask/"/>
      <url>/2017/11/07/AsyncTask/</url>
      
        <content type="html"><![CDATA[<h1 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h1><h2 id="1-什么是-AsyncTask"><a href="#1-什么是-AsyncTask" class="headerlink" title="1. 什么是 AsyncTask"></a>1. 什么是 AsyncTask</h2><h3 id="1-1-AsyncTask-是安卓提供的轻量异步类-抽象-可以继承AsyncTask-在类中可以进行异步操作-并提供接口反馈当前异步执行的程度或进度。"><a href="#1-1-AsyncTask-是安卓提供的轻量异步类-抽象-可以继承AsyncTask-在类中可以进行异步操作-并提供接口反馈当前异步执行的程度或进度。" class="headerlink" title="1.1 AsyncTask 是安卓提供的轻量异步类(抽象), 可以继承AsyncTask,在类中可以进行异步操作, 并提供接口反馈当前异步执行的程度或进度。"></a>1.1 AsyncTask 是安卓提供的轻量异步类(抽象), 可以继承AsyncTask,在类中可以进行异步操作, 并提供接口反馈当前异步执行的程度或进度。</h3><blockquote><p>本质上就是一个封装了线程池和handler的异步框架,主要用来执行异步任务,由于集成了handler,通过handler发送消息,它很方便的在工作线程和UI线程之间切换<br>(最好做耗时比较短的,长的还是用线程池)</p></blockquote><h2 id="2-AsyncTask的使用方法"><a href="#2-AsyncTask的使用方法" class="headerlink" title="2. AsyncTask的使用方法"></a>2. AsyncTask的使用方法</h2><p>2.1 三个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AsyncTask</span>&lt;Params, Progress, Result&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOG_TAG</span> <span class="operator">=</span> <span class="string">&quot;AsyncTask&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CPU_COUNT</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"><span class="comment">// We want at least 2 threads and at most 4 threads in the core pool, // preferring to have 1 less than the CPU count to avoid saturating // the CPU with background work  private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_POOL_SIZE</span> <span class="operator">=</span> CPU_COUNT * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">KEEP_ALIVE_SECONDS</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadFactory</span> <span class="variable">sThreadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">mCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;AsyncTask #&quot;</span> + mCount.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Params:执行时传入的参数;<br>Progress:在后台执行时的进度;<br>Result:当任务执行完毕后的结果返回;</p><hr><p>2.2 五个方法</p><p>耗时操作没进行前,在UI线程汇中调用onPreExecute();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPreExecute</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在后台执行时调用doInBackground();计算结果必须有一个返回,并会被传到onPost()中;<br>也可以调用publishProgress();返回进度显示<br>    @WorkerThread<br>    protected abstract Result doInBackground(Params… params);<br>在每次onProgressUpdate()调用完后会执行onProgressUpdate();通过progressbar.setProgress(value)动态显示进度条;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onProgressUpdate</span><span class="params">(Progress... values)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后所有doInBackground之后会通过result来传递给onPostExecute()并调用;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onPostExecute</span><span class="params">(Result result)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-AsyncTask内部原理"><a href="#3-AsyncTask内部原理" class="headerlink" title="3. AsyncTask内部原理"></a>3. AsyncTask内部原理</h2><p>3.1 AsyncTask的本质是一个静态的线程池,AsyncTask派生出的子类可以实现不同的异步任务, 这些任务都是提交到静态的线程池中执行;</p><p>3.2 线程池中的工作线程执行doInBackground(mParans)方法执行异步任务;</p><p>3.3 当任务状态改变之后,工作线程会向UI线程发送消息,AsyncTask内部的InternalHandler响应这些消息, 并调用相关的回调函数;</p><h2 id="4-AsyncTask注意事项"><a href="#4-AsyncTask注意事项" class="headerlink" title="4. AsyncTask注意事项"></a>4. AsyncTask注意事项</h2><p>4.1 内存泄露 </p><p>被声明为Activity的非静态的内部类,会持有外部类的引用;</p><blockquote><p>设为静态 static;<br>或者持有弱引用;<br>或在外部onDestroy里用cancle;</p></blockquote><p>4.2 生命周期<br>必须在activity生命周期销毁时销毁AsyncTask</p><p>4.3 结果丢失原因</p><p>如被杀掉,或者屏幕旋转时onPostExcute不会更新界面</p><p>4.4 并行OR串行</p><table><thead><tr><th>版本</th><th>执行方式</th></tr></thead><tbody><tr><td>&lt;&#x3D; 1.6</td><td>串行</td></tr><tr><td>&gt;&#x3D; 1.6 &amp;&amp; &lt; 2.3</td><td>并行</td></tr><tr><td>&gt;&#x3D; 2.3</td><td>串行</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AsyncTask </tag>
            
            <tag> 机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio 工程jar包重复引入报错</title>
      <link href="/2017/10/27/AndroidStudio%20%E5%B7%A5%E7%A8%8Bjar%E5%8C%85%E9%87%8D%E5%A4%8D%E5%BC%95%E5%85%A5%E6%8A%A5%E9%94%99/"/>
      <url>/2017/10/27/AndroidStudio%20%E5%B7%A5%E7%A8%8Bjar%E5%8C%85%E9%87%8D%E5%A4%8D%E5%BC%95%E5%85%A5%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h2 id="app-transformClassesWithJarMergingForDebug"><a href="#app-transformClassesWithJarMergingForDebug" class="headerlink" title="app:transformClassesWithJarMergingForDebug"></a>app:transformClassesWithJarMergingForDebug</h2><hr><p>工程中，如果我们叫A，要引用的两个三方库分别叫B和C。</p><p>其中B包含了若干小jar包，比如其中有一个叫d，C中也包含了同样的jar包d。</p><p>那么我们直接应用这两个库的时候，编译过程会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Execution failed <span class="keyword">for</span> task <span class="string">&#x27;:app:transformClassesWithJarMergingForDebug&#x27;</span>.</span><br></pre></td></tr></table></figure><p>那么我们只需要在其中库中「去掉」jar包的引用，或者说过滤掉。</p><p>可以切换到「Project」视图， 查看比较两者间有什么库是一样的名字。这里我举了个例子：</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208181535.png" alt="rxjava包冲突"></p><p>在MANIFEST.MF文件中,找到要过滤的包名: <strong>io.reactivex.java</strong></p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208181544.png" alt="Bundle-SymbolicName的字段"></p><p>在gradle文件中，引用工程后面添加过滤的包名。这里我将rx有关的都过滤了，（使用的是AS3.0有了新的关键字implementation<a href="https://stackoverflow.com/questions/44493378/whats-the-difference-between-implementation-and-compile-in-gradle">具体看这里</a>）</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208181554.png" alt="添加group"></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">&#x27;cn.bmob.android:bmob-sdk:3.5.5&#x27;</span>) &#123;</span><br><span class="line">    exclude <span class="attr">group:</span> <span class="string">&#x27;io.reactivex&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">compile(<span class="string">&#x27;com.kymjs.rxvolley:rxvolley:1.1.4&#x27;</span>) &#123;</span><br><span class="line">    exclude <span class="attr">group:</span> <span class="string">&#x27;io.reactivex&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新编译一下，就可以正常运行了。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂类解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度地图集成的小问题</title>
      <link href="/2017/10/27/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E9%9B%86%E6%88%90%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2017/10/27/%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E9%9B%86%E6%88%90%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="模拟器运行时候JS不加载或白屏"><a href="#模拟器运行时候JS不加载或白屏" class="headerlink" title="模拟器运行时候JS不加载或白屏"></a>模拟器运行时候JS不加载或白屏</h2><hr><p>之前用百度地图的时候都是直接Copy过来其他项目的地方，因为好业务逻辑相同，也简单了不少。但是偶然在运行中发现了这样一个问题。我用的是SDK 25（7.1）的模拟器，在我点击跳转到页面的时候显示了空白，同时我的日志输出了这样一段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chromium: [ERROR:interface_registry.cc(<span class="number">104</span>)] Failed to locate a binder <span class="keyword">for</span> interface: autofill::mojom::PasswordManagerDriver</span><br></pre></td></tr></table></figure><p>上网查阅资料里好多人说的是权限没获取到，又或是服务器资源不好。但这个页面短暂空白后，又出现了地图列表，看起来似乎是JS没有加载。可是我的代码里已经有了这些东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webView.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">webView.getSettings().setJavaScriptCanOpenWindowsAutomatically(<span class="literal">true</span>);</span><br><span class="line">webView.getSettings().setDomStorageEnabled(<span class="literal">true</span>);</span><br><span class="line">webView.getSettings().setLoadsImagesAutomatically(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>这个时候还是Stack Overflow上能看出些门道， 同时我注意到还有另外一条信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unrecognized GLES max version string in extensions: ANDROID_EMU_CHECKSUM_HELPER_v1 ANDROID_EMU_dma_v1 </span><br></pre></td></tr></table></figure><p>由于是使用虚拟机，我意识到可能还有显示渲染的不兼容。</p><p>然后我试着找了一个x86版本的虚拟机安装上去，画面又显示回来了。</p><p>目前在Stack Overflow上没有找到什么能解决的办法。</p><h2 id="无法在AndroidManifest-xml中获取com-baidu-android-lbs-API-KEY的值"><a href="#无法在AndroidManifest-xml中获取com-baidu-android-lbs-API-KEY的值" class="headerlink" title="无法在AndroidManifest.xml中获取com.baidu.android.lbs.API_KEY的值"></a>无法在AndroidManifest.xml中获取com.baidu.android.lbs.API_KEY的值</h2><hr><p>按照文档上的说明，我在AndroidManifest文件中配置meta-data应该是可以的，但是读取不到，后来发现原来key 不应该是api_key而是com.baidu.lbsapi.API_KEY，这个问题还是要细心注意一下。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集成 </tag>
            
            <tag> 百度地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ListView和RecyclerView中item中宽度不占满的一种可能</title>
      <link href="/2017/10/25/ListView%E5%92%8CRecyclerView%E4%B8%ADitem%E4%B8%AD%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%8D%A0%E6%BB%A1%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%83%BD/"/>
      <url>/2017/10/25/ListView%E5%92%8CRecyclerView%E4%B8%ADitem%E4%B8%AD%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%8D%A0%E6%BB%A1%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="ListView和RecyclerView中item中宽度不占满的一种可能"><a href="#ListView和RecyclerView中item中宽度不占满的一种可能" class="headerlink" title="ListView和RecyclerView中item中宽度不占满的一种可能"></a>ListView和RecyclerView中item中宽度不占满的一种可能</h2><p>开发中遇到一个问题，用到一个简单的ListView，我在item里写了match_parent属性，但是在运行中却并没有占满一整行，就导致了布局有问题。</p><p>在使用ListView的Adapter中,我们在getView方法里是这样的写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> View <span class="title function_">getView</span><span class="params">(<span class="type">int</span> position, View convertView, ViewGroup parent)</span> &#123;   </span><br><span class="line">   <span class="keyword">if</span> (convertView == <span class="literal">null</span>) &#123;  </span><br><span class="line">        convertView = inflate(R.layout.item_lv_test, <span class="literal">null</span>); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">return</span> convertView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的第二个参数是放parent，通常情况下之前一直在用null，但是这次却行不通了。问题在其实还真就在于这个null上。</p><p>点进去去看了下源码，发现inflate里还有一个方法。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208181126.png"></p><p>查阅资料，发现了我代码的问题。</p><h2 id="1-如果设置为null："><a href="#1-如果设置为null：" class="headerlink" title="1.如果设置为null："></a>1.如果设置为null：</h2><p>根布局设置的高度是不起作用的，即使根布局是一个控件，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;abc&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这时200dp不起作用，而是根据里面的文字大小来决定item的高度,比如如下起作用:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;abc&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:textSize</span>=<span class="string">&quot;200dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>根布局是一个layout的情况下，根布局的高度也不起作用，而是里面子控件的高度起作用，比如下面item的高度是100dp：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;300dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   true<span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">       true<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       true<span class="attr">android:layout_height</span>=<span class="string">&quot;100dp&quot;</span></span></span><br><span class="line"><span class="tag">       true<span class="attr">android:text</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果里面的内容设置为match_parent,效果跟第一个一样，根据文字大小来决定item高度，因为parent设置的高度没用，所以里面子空间match_parent也没用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;300dp&quot;</span>&gt;</span></span><br><span class="line">   true<span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">      true <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      true <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">      true <span class="attr">android:text</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="对传null总结："><a href="#对传null总结：" class="headerlink" title="对传null总结："></a>对传null总结：</h3><p>设置为null时，因为没有父亲，根布局的layout_height没有作用，子布局的layout_height为绝对值时有用，为相对值（match_parent,wrap_content）时没用，里面内容的高度决定了item的高度（根部局为普通空间时，控件内容决定item高度，根布局为layout时，子控件设置的绝对高度或子控件的内容决定item高度）</p><h2 id="2-如果传入三个参数"><a href="#2-如果传入三个参数" class="headerlink" title="2.如果传入三个参数##"></a>2.如果传入三个参数##</h2><p>如果parent设置为getview传入的parent（第三个参数false），则根布局设置的高度就有用了：</p><p>比如上面第一个就是200dp了</p><p>如果这时候，根部局设置为match_parent，则根据里面内容来适配，比如以下item高度跟上面第一个一样，为文字的高度：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   true<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   true<span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">   true<span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">       true<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       true<span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       true<span class="attr">android:text</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以下高度变成了200dp:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   true<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   true<span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line">   true<span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">       true<span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       true<span class="attr">android:layout_height</span>=<span class="string">&quot;200dp&quot;</span></span></span><br><span class="line"><span class="tag">       true<span class="attr">android:text</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样这个在RecyclerView中也是，总结起来是自己当初用的时候太过着急没仔细看看这个方法是什么用的。以此来记录这次小坑。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ListView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows中的一些快捷键</title>
      <link href="/2017/10/25/Windows%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2017/10/25/Windows%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Winodws快捷键"><a href="#Winodws快捷键" class="headerlink" title="Winodws快捷键"></a>Winodws快捷键</h2><p>根据Microsoft官网:2017年10月18日 - 修订版本： 8<br>(这篇文章中的信息适用于:<br>Windows 10, Windows 8.1, Windows 7)</p><h2 id="复制、粘贴及其他常规的键盘快捷方式"><a href="#复制、粘贴及其他常规的键盘快捷方式" class="headerlink" title="复制、粘贴及其他常规的键盘快捷方式"></a>复制、粘贴及其他常规的键盘快捷方式</h2><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Ctrl + X</td><td align="left">剪切选定项</td></tr><tr><td align="left">Ctrl + C（或 Ctrl + Insert）</td><td align="left">复制选定项</td></tr><tr><td align="left">Ctrl + V（或 Shift + Insert）</td><td align="left">粘贴选定项</td></tr><tr><td align="left">Ctrl + Z</td><td align="left">撤消操作</td></tr><tr><td align="left">Alt + Tab</td><td align="left">在打开的应用之间切换</td></tr><tr><td align="left">Alt + F4</td><td align="left">关闭活动项，或者退出活动应用</td></tr><tr><td align="left">Windows 徽标键  + L</td><td align="left">锁定你的电脑</td></tr><tr><td align="left">Windows 徽标键  + D</td><td align="left">显示和隐藏桌面</td></tr><tr><td align="left">F2</td><td align="left">重命名选定项</td></tr><tr><td align="left">F3</td><td align="left">在文件资源管理器中搜索文件或文件夹</td></tr><tr><td align="left">F4</td><td align="left">在文件资源管理器中显示地址栏列表</td></tr><tr><td align="left">F5</td><td align="left">刷新活动窗口</td></tr><tr><td align="left">F6</td><td align="left">循环浏览窗口中或桌面上的屏幕元素</td></tr><tr><td align="left">F10</td><td align="left">激活活动应用中的菜单栏</td></tr><tr><td align="left">Alt + F8</td><td align="left">在登录屏幕上显示你的密码</td></tr><tr><td align="left">Alt + Esc</td><td align="left">按项目打开顺序循环浏览</td></tr><tr><td align="left">Alt + 带下划线的字母</td><td align="left">执行该字母相关的命令</td></tr><tr><td align="left">Alt + Enter</td><td align="left">显示所选项目的属性</td></tr><tr><td align="left">Alt + 空格键</td><td align="left">打开活动窗口的快捷方式菜单</td></tr><tr><td align="left">Alt + 向左键</td><td align="left">返回</td></tr><tr><td align="left">Alt + 向右键</td><td align="left">前进</td></tr><tr><td align="left">Alt + Page Up</td><td align="left">向上移动一个屏幕</td></tr><tr><td align="left">Alt + Page Down</td><td align="left">向下移动一个屏幕</td></tr><tr><td align="left">Ctrl + F4</td><td align="left">关闭活动文档（在可全屏显示并允许你同时打开多个文档的应用中）</td></tr><tr><td align="left">Ctrl + A</td><td align="left">选择文档或窗口中的所有项目</td></tr><tr><td align="left">Ctrl + D（或 Delete）</td><td align="left">删除所选的项目，将其移至回收站</td></tr><tr><td align="left">Ctrl + R（或 F5）</td><td align="left">刷新活动窗口</td></tr><tr><td align="left">Ctrl + Y</td><td align="left">恢复操作</td></tr><tr><td align="left">Ctrl + 向右键</td><td align="left">将光标移动到下一个字词的起始处</td></tr><tr><td align="left">Ctrl + 向左键</td><td align="left">将光标移动到上一个字词的起始处</td></tr><tr><td align="left">Ctrl + 向下键</td><td align="left">将光标移动到下一段落的起始处</td></tr><tr><td align="left">Ctrl + 向上键</td><td align="left">将光标移动到上一段落的起始处</td></tr><tr><td align="left">Ctrl + Alt + Tab</td><td align="left">使用箭头键在所有打开的应用之间进行切换</td></tr><tr><td align="left">Ctrl + Alt + Shift + 箭头键</td><td align="left">当组或磁贴的焦点放在“开始”菜单上时，可将其朝指定方向移动</td></tr><tr><td align="left">Ctrl + 箭头键（移至某个项目）+ 空格键</td><td align="left">选择窗口中或桌面上的多个单独项目</td></tr><tr><td align="left">Ctrl + Shift（及箭头键）</td><td align="left">选择文本块</td></tr><tr><td align="left">Ctrl + Esc</td><td align="left">打开“开始”屏幕</td></tr><tr><td align="left">Ctrl + Shift + Esc</td><td align="left">打开任务管理器</td></tr><tr><td align="left">Ctrl + Shift</td><td align="left">如果多种键盘布局可用，则可切换键盘布局</td></tr><tr><td align="left">Ctrl + 空格键</td><td align="left">打开或关闭的中文输入法编辑器 (IME)</td></tr><tr><td align="left">Shift + F10</td><td align="left">显示所选项目的快捷方式菜单</td></tr><tr><td align="left">按 Shift 与任何箭头键</td><td align="left">在窗口中或桌面上选择多个项目，或在文档中选择文本</td></tr><tr><td align="left">Shift + Delete</td><td align="left">删除选定项，无需先移动到回收站</td></tr><tr><td align="left">向右键</td><td align="left">打开右侧的下一个菜单，或打开子菜单</td></tr><tr><td align="left">向左键</td><td align="left">打开左侧的下一个菜单，或关闭子菜单</td></tr><tr><td align="left">Esc</td><td align="left">停止或离开当前任务</td></tr></tbody></table><h2 id="Windows-徽标键键盘快捷方式"><a href="#Windows-徽标键键盘快捷方式" class="headerlink" title="Windows 徽标键键盘快捷方式"></a>Windows 徽标键键盘快捷方式</h2><hr><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Windows 徽标键</td><td align="left">打开或关闭“开始”屏幕</td></tr><tr><td align="left">Windows 徽标键  + A</td><td align="left">打开操作中心</td></tr><tr><td align="left">Windows 徽标键  + B</td><td align="left">将焦点放在通知区域上</td></tr><tr><td align="left">Windows 徽标键  + C</td><td align="left">在侦听模式下打开 Cortana</td></tr><tr><td align="left">Windows 徽标键  + Shift + C</td><td align="left">打开超级按钮菜单</td></tr><tr><td align="left">Windows 徽标键  + D</td><td align="left">显示和隐藏桌面</td></tr><tr><td align="left">Windows 徽标键  + Alt + D</td><td align="left">显示和隐藏桌面上的日期和时间</td></tr><tr><td align="left">Windows 徽标键  + E</td><td align="left">打开文件资源管理器</td></tr><tr><td align="left">Windows 徽标键  + F</td><td align="left">打开反馈中心并获取屏幕截图</td></tr><tr><td align="left">Windows 徽标键  + G</td><td align="left">打开游戏栏（当游戏处于打开状态时）</td></tr><tr><td align="left">Windows 徽标键  + H</td><td align="left">开始听写</td></tr><tr><td align="left">Windows 徽标键  + I</td><td align="left">打开“设置”</td></tr><tr><td align="left">Windows 徽标键  + J</td><td align="left">请将焦点设置到可用的 Windows 提示。</td></tr><tr><td align="left">Windows 徽标键  + K</td><td align="left">打开“连接”快速操作</td></tr><tr><td align="left">Windows 徽标键  + L</td><td align="left">锁定你的电脑或切换帐户</td></tr><tr><td align="left">Windows 徽标键  + M</td><td align="left">最小化所有窗口</td></tr><tr><td align="left">Windows 徽标键  + O</td><td align="left">锁定设备方向</td></tr><tr><td align="left">Windows 徽标键  + P</td><td align="left">选择演示显示模式</td></tr><tr><td align="left">Windows 徽标键  + R</td><td align="left">打开“运行”对话框</td></tr><tr><td align="left">Windows 徽标键  + S</td><td align="left">打开“搜索”</td></tr><tr><td align="left">Windows 徽标键  + T</td><td align="left">循环浏览任务栏上的应用</td></tr><tr><td align="left">Windows 徽标键  + U</td><td align="left">打开“轻松使用设置中心”</td></tr><tr><td align="left">Windows 徽标键  + V</td><td align="left">循环浏览通知</td></tr><tr><td align="left">Windows 徽标键  + Shift + V</td><td align="left">以相反顺序循环浏览通知</td></tr><tr><td align="left">Windows 徽标键  + X</td><td align="left">打开“快速链接”菜单</td></tr><tr><td align="left">Windows 徽标键  + Y</td><td align="left">在 Windows Mixed Reality 与桌面之间切换输入</td></tr><tr><td align="left">Windows 徽标键  + Z</td><td align="left">以全屏模式显示应用中可用的命令</td></tr><tr><td align="left">Windows 徽标键  + 句点 (.) 或分号 (;)</td><td align="left">打开表情符号面板</td></tr><tr><td align="left">Windows 徽标键  + 逗号 (,)</td><td align="left">临时速览桌面</td></tr><tr><td align="left">Windows 徽标键  + Pause 键</td><td align="left">显示“系统属性”对话框</td></tr><tr><td align="left">Windows 徽标键  + Ctrl + F</td><td align="left">搜索电脑（如果已连接到网络）</td></tr><tr><td align="left">Windows 徽标键  + Shift + M</td><td align="left">还原桌面上的最小化窗口</td></tr><tr><td align="left">Windows 徽标键  + 数字</td><td align="left">打开桌面，然后启动固定到任务栏的应用（位于数字所指明的位置）。如果应用已处于运行状态，则切换至该应用。</td></tr><tr><td align="left">Windows 徽标键  + Shift + 数字</td><td align="left">打开桌面，然后启动固定到任务栏的应用新实例（位于数字所指明的位置）</td></tr><tr><td align="left">Windows 徽标键  + Ctrl + 数字</td><td align="left">打开桌面，然后切换至固定到任务栏的应用的最后活动窗口（位于数字所指明的位置）</td></tr><tr><td align="left">Windows 徽标键  + Alt + 数字</td><td align="left">打开桌面，然后打开固定到任务栏的应用的“跳转列表”（位于数字所指明的位置）</td></tr><tr><td align="left">Windows 徽标键  + Ctrl + Shift + 数字</td><td align="left">打开桌面，然后以管理员身份打开位于任务栏上指定位置的应用新实例</td></tr><tr><td align="left">Windows 徽标键  + Tab</td><td align="left">打开任务视图</td></tr><tr><td align="left">Windows 徽标键  向上键</td><td align="left">最大化窗口</td></tr><tr><td align="left">Windows 徽标键  向下键</td><td align="left">删除屏幕上的当前应用并最小化桌面窗口</td></tr><tr><td align="left">Windows 徽标键  + 向左键</td><td align="left">最大化屏幕左侧的应用或桌面窗口</td></tr><tr><td align="left">Windows 徽标键  + 向右键</td><td align="left">最大化屏幕右侧的应用或桌面窗口</td></tr><tr><td align="left">Windows 徽标键  + Home</td><td align="left">最小化活动桌面窗口之外的所有窗口（在第二个笔划时还原所有窗口）</td></tr><tr><td align="left">Windows 徽标键  + Shift + 向上键</td><td align="left">将桌面窗口拉伸至屏幕顶部和底部</td></tr><tr><td align="left">Windows 徽标键  + Shift + 向下键</td><td align="left">在垂直方向上还原&#x2F;最小化活动桌面窗口，而宽度保持不变</td></tr><tr><td align="left">Windows 徽标键  Shift + 向左键或向右键</td><td align="left">将桌面上的应用或窗口从一台显示器移动至另一台显示器</td></tr><tr><td align="left">Windows 徽标键  + 空格键</td><td align="left">切换输入语言和键盘布局</td></tr><tr><td align="left">Windows 徽标键  + Ctrl + 空格键</td><td align="left">对之前选择的输入所做的更改</td></tr><tr><td align="left">Windows 徽标键 + Ctrl + Enter</td><td align="left">打开“讲述人”</td></tr><tr><td align="left">Windows 徽标键  + 正斜杠 (&#x2F;)</td><td align="left">开始输入法复原流程</td></tr><tr><td align="left">Windows 徽标键  + Ctrl + V</td><td align="left">打开肩式分接设备</td></tr></tbody></table><h2 id="命令提示符键盘快捷方式"><a href="#命令提示符键盘快捷方式" class="headerlink" title="命令提示符键盘快捷方式"></a>命令提示符键盘快捷方式</h2><hr><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Ctrl + C（或 Ctrl + Insert）</td><td align="left">复制选定文本</td></tr><tr><td align="left">Ctrl + V（或 Shift + Insert）</td><td align="left">粘贴选定文本</td></tr><tr><td align="left">Ctrl + M</td><td align="left">输入标记模式</td></tr><tr><td align="left">Alt + 所选择的键</td><td align="left">开始在块模式下选择</td></tr><tr><td align="left">箭头键</td><td align="left">按指定方向移动光标</td></tr><tr><td align="left">Page up</td><td align="left">将光标向上移动一个页面</td></tr><tr><td align="left">Page down</td><td align="left">将光标向下移动一个页面</td></tr><tr><td align="left">Ctrl + Home（标记模式）</td><td align="left">将光标移动到缓冲区起始处</td></tr><tr><td align="left">Ctrl + End（标记模式）</td><td align="left">将光标移动到缓冲区结尾处</td></tr><tr><td align="left">Ctrl + 向上键</td><td align="left">在输出历史记录中上移一行</td></tr><tr><td align="left">Ctrl + 向下键</td><td align="left">在输出历史记录中下移一行</td></tr><tr><td align="left">Ctrl + Home（历史记录导航）</td><td align="left">如果命令行为空，则将视区移动到缓冲区顶部。否则，请删除命令行中光标左侧的所有字符。</td></tr><tr><td align="left">Ctrl + End（历史记录导航）</td><td align="left">如果命令行为空，则将视区移动到命令行。否则，请删除命令行中光标右侧的所有字符。</td></tr></tbody></table><h2 id="对话框键盘快捷方式"><a href="#对话框键盘快捷方式" class="headerlink" title="对话框键盘快捷方式"></a>对话框键盘快捷方式</h2><hr><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">对话框键盘快捷方式</td><td align="left"></td></tr><tr><td align="left">按键</td><td align="left">操作</td></tr><tr><td align="left">F4</td><td align="left">显示活动列表中的项目</td></tr><tr><td align="left">Ctrl + Tab</td><td align="left">在选项卡中向前移动</td></tr><tr><td align="left">Ctrl + Shift + Tab</td><td align="left">在选项卡中向后移动</td></tr><tr><td align="left">Ctrl + 数字（数字 1–9）</td><td align="left">移动到第 n 个选项卡</td></tr><tr><td align="left">Tab</td><td align="left">在选项中向前移动</td></tr><tr><td align="left">Shift + Tab</td><td align="left">在选项中向后移动</td></tr><tr><td align="left">Alt + 带下划线的字母</td><td align="left">执行可与该字母结合使用的命令（或选择该选项）</td></tr><tr><td align="left">空格键</td><td align="left">如果活动选项为复选框，则选择或清除复选框</td></tr><tr><td align="left">Backspace</td><td align="left">如果在“另存为”或“打开”对话框中选择文件夹，则打开上一级别的文件夹</td></tr><tr><td align="left">箭头键</td><td align="left">如果活动选项是一组选项按钮，请选择一个按钮</td></tr></tbody></table><h2 id="文件资源管理器键盘快捷方式"><a href="#文件资源管理器键盘快捷方式" class="headerlink" title="文件资源管理器键盘快捷方式"></a>文件资源管理器键盘快捷方式</h2><hr><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Alt + D</td><td align="left">选择地址栏</td></tr><tr><td align="left">Ctrl + E</td><td align="left">选择搜索框</td></tr><tr><td align="left">Ctrl + F</td><td align="left">选择搜索框</td></tr><tr><td align="left">Ctrl + N</td><td align="left">打开新窗口</td></tr><tr><td align="left">Ctrl + W</td><td align="left">关闭活动窗口</td></tr><tr><td align="left">Ctrl + 鼠标滚轮</td><td align="left">更改文件和文件夹图标的大小和外观</td></tr><tr><td align="left">Ctrl + Shift + E</td><td align="left">显示选定文件夹上所有级别文件夹</td></tr><tr><td align="left">Ctrl + Shift + N</td><td align="left">新建文件夹</td></tr><tr><td align="left">Num Lock + 星号 (*)</td><td align="left">显示选定文件夹下所有子文件夹</td></tr><tr><td align="left">Num Lock + 加号 (+)</td><td align="left">显示选定文件夹中的内容</td></tr><tr><td align="left">Num Lock + 减号 (-)</td><td align="left">折叠选定文件夹</td></tr><tr><td align="left">Alt + P</td><td align="left">显示预览面板</td></tr><tr><td align="left">Alt + Enter</td><td align="left">打开选定项目的“属性”对话框</td></tr><tr><td align="left">Alt + 向右键</td><td align="left">查看下一个文件夹</td></tr><tr><td align="left">Alt + 向上键</td><td align="left">查看该文件夹所在的文件夹</td></tr><tr><td align="left">Alt + 向左键</td><td align="left">查看上一个文件夹</td></tr><tr><td align="left">Backspace</td><td align="left">查看上一个文件夹</td></tr><tr><td align="left">向右键</td><td align="left">显示当前选择内容（如果已折叠），或选择第一个子文件夹</td></tr><tr><td align="left">向左键</td><td align="left">折叠当前所选内容（如果已展开），或选择该文件夹所在的文件夹</td></tr><tr><td align="left">End</td><td align="left">显示活动窗口底部</td></tr><tr><td align="left">Home</td><td align="left">显示活动窗口顶部</td></tr><tr><td align="left">F11</td><td align="left">最大化或最小化活动窗口</td></tr></tbody></table><h2 id="虚拟桌面的键盘快捷方式"><a href="#虚拟桌面的键盘快捷方式" class="headerlink" title="虚拟桌面的键盘快捷方式"></a>虚拟桌面的键盘快捷方式</h2><hr><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Windows 徽标键  + Tab</td><td align="left">打开“任务视图”</td></tr><tr><td align="left">Windows 徽标键  + Ctrl + D</td><td align="left">添加虚拟桌面</td></tr><tr><td align="left">Windows 徽标键  + Ctrl + 向右键</td><td align="left">在你于右侧创建的虚拟桌面之间切换</td></tr><tr><td align="left">Windows 徽标键  + Ctrl + 向左键</td><td align="left">在你于左侧创建的虚拟桌面之间切换</td></tr><tr><td align="left">Windows 徽标键  + Ctrl + F4</td><td align="left">关闭你正在使用的虚拟桌面</td></tr></tbody></table><h2 id="任务栏键盘快捷方式"><a href="#任务栏键盘快捷方式" class="headerlink" title="任务栏键盘快捷方式"></a>任务栏键盘快捷方式</h2><hr><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Shift + 单击任务栏按钮</td><td align="left">打开应用或快速打开另一个应用实例</td></tr><tr><td align="left">Ctrl + Shift + 单击任务栏按钮</td><td align="left">以管理员身份打开应用</td></tr><tr><td align="left">Shift + 右键单击任务栏按钮</td><td align="left">显示应用的窗口菜单</td></tr><tr><td align="left">Shift + 右键单击分组任务栏按钮</td><td align="left">显示组窗口菜单</td></tr><tr><td align="left">Ctrl + 单击分组任务栏按钮</td><td align="left">循环浏览组窗口</td></tr></tbody></table><h2 id="任务栏键盘快捷方式-1"><a href="#任务栏键盘快捷方式-1" class="headerlink" title="任务栏键盘快捷方式"></a>任务栏键盘快捷方式</h2><hr><table><thead><tr><th align="left">快捷键</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">Windows 徽标键  + I</td><td align="left">打开设置</td></tr><tr><td align="left">Backspace</td><td align="left">返回至设置主页</td></tr><tr><td align="left">使用搜索框在任何页面上键入</td><td align="left">搜索设置</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次折腾过程（二）</title>
      <link href="/2017/10/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8A%98%E8%85%BE%E8%BF%87%E7%A8%8B(%E4%BA%8C)/"/>
      <url>/2017/10/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8A%98%E8%85%BE%E8%BF%87%E7%A8%8B(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h2 id="第二次折腾"><a href="#第二次折腾" class="headerlink" title=" 第二次折腾:"></a> 第二次折腾:</h2><p>在稳定的使用一段时间后,有一天突然不能访问了。<br>想到后台看一眼，没想到官网来了这样一段文字。</p><p><img src="https://i.imgur.com/6dteqRt.png"></p><p>为了避免之前其他的提供商那句：“相会有时，后会无期”的话。我还是别等了。</p><h2 id="VPS："><a href="#VPS：" class="headerlink" title="VPS："></a>VPS：</h2><hr><p><img src="https://i.imgur.com/ZW9lkbz.png"></p><p>其实之前没搞VPS是因为需要信用卡或者PayPal，当时还没有。不过现在终于有了，又重新找了找发现有的提供商付款选项里有个支付宝，马云爸爸还是厉害啊。（比特币笑而不语）</p><p><img src="https://i.imgur.com/aaSERVz.png"></p><p>VPS的选择也有很多，可以上知乎看一看。别着急，耐心的看一看你是否都需要那么多配置，你需要为你过剩的CPU，内存以及硬盘空间来买单的。当然，性能越好，可做的事情就越多。你可以搭个服务器，跑点PHP，远程下载balabala的。</p><p>选择好你的服务器确定好系统后，我们可以开始了。（注：这里最好使用Linux 比Windows便宜很多而且Linux毕竟是专门干这种的，而且这里还有一个坑就是可能给你的IP也被*了，具体有没有Ping一下就行了，如果发生了咱态度诚恳点找一下客服给你换个IP解决）</p><p><img src="https://i.imgur.com/MQedmiO.png" alt="这是一个悲伤的故事"></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><hr><p>然后我们需要用到SSH连接工具来登录我们的服务器。</p><p>Mac和Linux下直接在终端中输入命令，连接后直接输入你的登录密码就可以直接连接。<br>在Windows系统下需要专门的客户端来SSH登录VPS。在<a href="http://www.netsarang.com/download/down_form.html?code=522&utm_source=textarea.com&utm_medium=textarea.com&utm_campaign=article">Xshell</a>官网下载。</p><pre><code>ssh root@your_VPS_ipAddress</code></pre><p><strong>安装Shadowsocks：</strong></p><p>Debian &#x2F; Ubuntu:</p><pre><code>apt-get install python-pippip install shadowsocks</code></pre><p>CentOS:</p><pre><code>yum install python-setuptools &amp;&amp; easy_install pippip install shadowsocks</code></pre><p><strong>配置文件：</strong></p><p>使用vim命令来编辑 &#x2F;etc&#x2F;shadowsocks.json</p><pre><code>vim /etc/shadowsocks.json</code></pre><p>如果你不会用vim来保存和编辑的话，去用几分钟学习下简单的使用，这个神器还有有很多故事和强大之处的。</p><pre><code>&#123;&quot;server&quot;:&quot;my_server_ip&quot;,&quot;server_port&quot;:8388,&quot;local_address&quot;: &quot;127.0.0.1&quot;,&quot;local_port&quot;:1080,&quot;password&quot;:&quot;mypassword&quot;,&quot;timeout&quot;:300,&quot;method&quot;:&quot;aes-256-cfb&quot;,&quot;fast_open&quot;: false&#125;</code></pre><table><thead><tr><th>字段名</th><th>意义</th></tr></thead><tbody><tr><td>server</td><td>你的服务器地址</td></tr><tr><td>server_port</td><td>连接你服务器的端口</td></tr><tr><td>local_address</td><td>本地服务器地址</td></tr><tr><td>local_port</td><td>本地端口</td></tr><tr><td>password</td><td>密码</td></tr><tr><td>timeout</td><td>超时时间（秒）</td></tr><tr><td>method</td><td>加密方式（默认：aes-256-cfb）</td></tr><tr><td>fast_open</td><td>TCP快速开启 （true &#x2F; false）</td></tr></tbody></table><p>填写正确后我们保存并退出。</p><p><strong>运行:</strong></p><pre><code>ssserver -c /etc/shadowsocks.json</code></pre><p>如果一切配置顺利，你可以在你的终端看见端口正在启动，然后我们在客户端上按照之前的一样填写好我们的配置就可以了。这里的小细节，不要打错任何东西，否则两边不一致是无论如何都都建立不起来连接的。</p><p><img src="https://i.imgur.com/RV10Sah.png"></p><p>好了，我们又可以愉快的玩耍了~</p><h2 id="又是彩蛋："><a href="#又是彩蛋：" class="headerlink" title="又是彩蛋："></a>又是彩蛋：</h2><hr><p>没错，我们通过自己建立VPS有了一个自己的专属服务器连接，这个的速度和性能完全是根据我们选择去定制的。同时，我们会发现一个小弊端，那么就是我们如何让它一直活动，不能关闭后就不能用了，那也太坑了。</p><p>我们当然可以写一个shell脚本，放在开机自启动。这里有个比较取巧的方法。(感谢我的渣浪好室友,冠希童鞋:手动撒花~)</p><blockquote><h3 id="保持SS运行"><a href="#保持SS运行" class="headerlink" title="保持SS运行"></a>保持SS运行</h3></blockquote><blockquote><p><strong>使用screen命令进行远程回话管理流程：</strong></p><ol><li>ssh登陆到远程机器上</li><li>键入screen建立一个新的会话窗口</li><li>在这个新的会话窗口中运行命令（通常是一些时间较长的任务），键入C-a d，退出并保存该会话窗口<br>（这之后可以退出ssh登陆的终端，下次工作时重新ssh登陆，再进行如下步骤）</li><li>screen -ls列出所有会话</li><li>screen -r id重新连接会话</li><li>使用exit真正退出会话</li></ol></blockquote><p>该命令真正强大之处是退出远程登陆后，<strong>screen依然会替我们管理保存的会话</strong>，在后台执行，我们再次远程登陆后可以恢复任何会话的现场，<strong>适用于时间较长的任务</strong>。</p><p>其中C-a d是<code>ctrl</code> + <code>A</code> + <code>D</code>一起键入。</p><p>这样我们在screen中运行启动命令，然后按<code>ctrl</code> + <code>A</code> + <code>D</code>退出。<br>再断开连接的时候就不会中断这个命令，可以放心的关闭SSH连接了。</p><hr><p><strong>当然正统的方法是这样的：</strong></p><p><strong>添加应用到service：</strong><br>创建脚本 <code>/etc/init.d/shadowsocks</code> 文件（其实也是 <code>/etc/rc.d/init.d/shadowsocks</code> 文件）</p><pre><code>sudo vim /etc/init.d/shadowsocks</code></pre><p>添加以下内容：</p><pre><code>#!/bin/sh## shadowsocks start/restart/stop shadowsocks## chkconfig: 2345 85 15# description: start shadowsocks/ssserver at boot timestart()&#123;        ssserver -c /etc/shadowsocks.json -d start&#125;stop()&#123;        ssserver -c /etc/shadowsocks.json -d stop&#125;restart()&#123;        ssserver -c /etc/shadowsocks.json -d restart&#125;case &quot;$1&quot; instart)        start        ;;stop)        stop        ;;restart)        restart        ;;*)        echo &quot;Usage: $0 &#123;start|restart|stop&#125;&quot;        exit 1        ;;esac</code></pre><p><strong>然后增加这个文件的可执行权限：</strong></p><pre><code>sudo chmod +x /etc/init.d/shadowsocks</code></pre><p>**<br>这样就可以在 shell 中直接运行下面的命令开启程序了（重启和停止同理）：**</p><pre><code>sudo service shadowsocks start</code></pre><blockquote><p>注意：<br>这里以root权限运行的，如果不想以root权限运行可以用 sudo -u {user} {command}。<br>如果不给脚本文件加上其他用户的可执行权限，不带参数运行 service shadowsocks 会提示 unrecognized service。</p></blockquote><p><strong>设置开机启动：</strong><br>在上面脚本没有问题（也就是保留了前面10行，并且语法正确）的情况下，通过下面的命令，就可以设置程序自动启动了</p><pre><code>sudo chkconfig shadowsocks on</code></pre><p>这样程序就会自动启动了。</p><p>结合此处两个解决方案:</p><p><a href="https://www.awaimai.com/439.html">Linux将应用添加到service，并设置自动启动</a></p><p><a href="https://stackoverflow.com/a/20680309/6835285">How do I install chkconfig on Ubuntu?</a></p><hr><blockquote><h3 id="多用户配置"><a href="#多用户配置" class="headerlink" title="多用户配置"></a>多用户配置</h3></blockquote><p>我使用的每个月有2T流量，嗯…单单使用做SS的话，的确过剩了。</p><p>我们可以开辟多个端口，为每个端口使用不同的密码来登录。</p><pre><code>&#123;   &quot;server&quot;:&quot;my_server_ip&quot;,   &quot;local_address&quot;: &quot;127.0.0.1&quot;,   &quot;local_port&quot;:1080,    &quot;port_password&quot;: &#123;      &quot;2333&quot;:&quot;mima12345&quot;,    &quot;6666&quot;:&quot;mima12345&quot; &#125;,   &quot;timeout&quot;:300,   &quot;method&quot;:&quot;aes-256-cfb&quot;,   &quot;fast_open&quot;: false  &#125;</code></pre><p>这其中加密方式 我还是推荐rc4-md5的。或者他们说chacha20对移动端访问速度比较快。</p><p>主要是AES加密太耗时。</p><p>另附地址：<a href="http://calonye.com/22419.html">多用户配置</a></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束:"></a>结束:</h2><hr><p>经过这样我们可以暂时有一个小小的窗户，来继续访问官网的最新技术。</p><p>扔给你个小软件<a href="https://sspai.com/post/38846">HyperApp</a><del>（撒花</del>φ(&gt;ω&lt;*) ）</p><p>至此，我们已经可以实现一个很理想的状态。但是能不能更好地让家里全局的设备，比如Chromecat也支持呢？下一篇我会介绍。</p>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纪念 </tag>
            
            <tag> 符号·人生 </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次折腾过程（一）</title>
      <link href="/2017/10/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8A%98%E8%85%BE%E8%BF%87%E7%A8%8B(%E4%B8%80)/"/>
      <url>/2017/10/24/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8A%98%E8%85%BE%E8%BF%87%E7%A8%8B(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title=" 写在前面:"></a> 写在前面:</h2><p>做安卓的都知道，安卓是归谷歌的。谷歌很多最新的好玩儿有趣的功能，第一时间对移动端的支持大部分也都是在安卓上。身为平常娱乐，有些东西可有可无，也就作罢。但是身为一名开发者，你经常要了解最新的咨询需要上官网，那么这个官网还不能访问，这种情况是不能容忍的。本文是我对这系列折腾过程的记录，当做一个对过去的总结。</p><h2 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h2><hr><blockquote><p>整体软件环境</p></blockquote><p>安卓的开源是便利的，但同样是危险的。当开发者发现安卓的各种可定制的功能时，同样也是对一名开发者或者说一个软件团队的技术与「道德」的考验。</p><p>常驻后台，相互唤醒。国内安卓的App市场里各种应用的审核并不像想想象中那么严，尤其是身为一名开发者后，发现国内环境的确没有Play Store上那种基于机器学习App检测系统更安全。</p><p>如果你可以可以看看QQ在Play Store上的功能要简约明朗很多，我想无论如何Play Store多多少少制约了一下现在这种软件的「店大欺客」的状态，什么微信<strong>必须</strong>给定位权限，支付宝<strong>必须</strong>要给电话拨打权限，否则就不让用。这相当有悖于谷歌的设计动态权限申请的原则。国内虽然也有一大堆「国人习惯」的第三方ROM来制衡这个混乱的生态圈，但这也给很多开发者带来了更多的适配兼容的问题。(´-ι_-｀)</p><blockquote><p>海外连接速度<strong>过慢</strong></p></blockquote><p>作为一个开发者，上到软件的下载，下到linux的代码仓，好多软件的更新支持都需要一个稳定速度的带宽支持。说到这点，就好比我刚开始用AS开发，一个几百兆的gradle文件愣是让我下载了半天时间，除了学校当时网速有点低之外更主要还是本身对海外节点的访问速度。</p><blockquote><p>You Can Learn More And More</p></blockquote><p>我只是一个纯粹的喜爱生活，热爱技术的人，好多东西明明应该是「无害」的，就好比我想看个谷歌IO大会的直播视频，却难以实现。好在谷歌在国内的影响力又渐渐有了些起色，虽然现在也有腾讯的同声转播，但是总感觉哪里有点不一样。</p><h2 id="What？"><a href="#What？" class="headerlink" title="What？"></a>What？</h2><hr><p>最简单的人们听过最多的也就是VPN，这个简单粗暴和正常软件的使用没什么太大难度。很多时候我们只是使用了一个服务商提供的已经设置好的「工具」，来直接使用，多数的直接就是提供商自己的出的软件，定制化不是很高。理论上和SS速度不应该差距太多，但是实际使用中稳定性，速度体验都有很大折扣。当然在企业里VPN这种东西还是很方便的，你可以远程访问内网环境来提交你的文件管理日常等。</p><p>我选择的是Shadowsocks，简称SS。</p><p>简单理解的话，Shadowsocks是将以前通过SSH创建的Socks5协议拆开成Server端和client端，下面这个原理图能简单介绍其翻墙原理，基本上和利用SSH tunnel大致类似：</p><p><img src="https://i.imgur.com/6ZDVSNr.png"></p><blockquote><ol><li>PC客户端（即你的电脑）发出请求基于Socks5协议跟SS-Local端进行通讯，由于这个SS-Local一般是本机或路由器等局域网的其他机器，不经过GFW，所以解决GFW通过特征分析进行干扰的问题。</li><li>SS-Local和SS-Server两端通过多种可选的加密方法进行通讯，经过GFW的时候因为是常规的TCP包，没有明显特征码GFW也无法对通讯数据进行解密，因此通讯放行。</li><li>SS-Server将收到的加密数据进行解密，还原初始请求，再发送到用户需要访问的服务网站，获取响应原路再返回SS-04，返回途中依然使用了加密，使得流量是普通TCP包，并成功穿过GFW防火墙。</li></ol></blockquote><h2 id="How？"><a href="#How？" class="headerlink" title="How？"></a>How？</h2><hr><p><a href="https://github.com/shadowsocksr-backup/shadowsocks-rss">各平台位置</a></p><blockquote><p>（注： 这里的SS和SSR还是有区别的 不过本篇暂且不说。）<br>找到一个稳定的提供商，根据节点信息来填写后连接就好。而且二维码的加入更是降低了用户门槛，很多时候只需要点击客户端的扫描二维码就可以啦！</p></blockquote><p><img src="https://i.imgur.com/09eRspU.png"></p><p>你可以在小伙伴的客户端或者提供商页面找到二维码，其实就是包含我所填入的这些信息的一段内容。</p><p><img src="https://i.imgur.com/CzREqdg.png"></p><p>然后我们直接点击扫描屏幕上的二维码就会拿到识别信息了。如果没有的话，手动填写即可。（这里mac客户端是SS那么没有混淆和协议选项的情况下先不写。或者有的使用的是启动参数，-O -o等）</p><p><img src="https://i.imgur.com/EhZ1piC.png"></p><p>最后我们可以选择服务器来切换不同的节点，同样可以开启全局。也可在需要时开启。</p><p>然后我们就可以愉快的看着我们gradle下载文件的速度变快了不少。</p><h2 id="当然还有彩蛋"><a href="#当然还有彩蛋" class="headerlink" title="当然还有彩蛋"></a>当然还有彩蛋</h2><p>这是折腾过程的第一部分，没有什么复杂的东西，如果你要是动手实现的话，估计几分钟十几分钟就能搞定。当然我们们可以做的还远不止这些。</p><blockquote><h2 id="为软件设置代理"><a href="#为软件设置代理" class="headerlink" title="为软件设置代理"></a>为软件设置代理</h2></blockquote><ol><li>所在的地方大局域网屏蔽了一切和音视频相关的内容网站和信息，连网易云音乐都不让听。小伙伴们可着急了，音乐是动力啊有木有。 </li><li>全局代理虽然简单暴力，让你直接达到直连的效果。但是你会发现会有很多弊端：访问国内网站时候我们仍然会走这个代理模式，这就导致了速度变慢，而且很多提供商每个月的流量也都有限。虽然正常使用下流量基本够用，但是也是浪费了不必要的资源。</li></ol><p>在运行客户端后我们开始，选择设置中为局域网开启代理。</p><p><img src="https://i.imgur.com/a2cbV80.png"></p><p>然后在网易云音乐里的设置里找到下载，填写好本地地址和端口，点击测试发现代理可用，然后重启软件，发现每日推荐又活过来了。</p><p><img src="https://i.imgur.com/yeLt6ag.png"></p><p>以此类推，你会发现好多软件都可以这样设置代理。达到节约流量和不影响你日常的网速效果。</p><blockquote><h2 id="更灵活的配置方式-PAC"><a href="#更灵活的配置方式-PAC" class="headerlink" title="更灵活的配置方式 PAC"></a>更灵活的配置方式 PAC</h2></blockquote><blockquote><p>代理自动配置（英语：Proxy auto-config，简称PAC）是一种网页浏览器技术，用于定义浏览器该如何自动选择适当的代理服务器来访问一个网址。<br>一个PAC文件包含一个JavaScript形式的函数“FindProxyForURL(url, host)”。这个函数返回一个包含一个或多个访问规则的字符串。用户代理根据这些规则适用一个特定的代理器或者直接访问。当一个代理服务器无法响应的时候，多个访问规则提供了其他的后备访问方法。浏览器在访问其他页面以前，首先访问这个PAC文件。PAC文件中的URL可能是手工配置的，也可能是是通过网页的网络代理自动发现协议（WPAD）自动配置的。</p></blockquote><p>简单来说就是国内走国内，国外走代理。<br>你可以在客户端找到这个选项，我们可以设置国内不走这个节点，国外自动走代理。</p><p><img src="https://i.imgur.com/F9WTFks.png"></p><p>这里我用了一个好像不是最优不过也还好：</p><blockquote><p><a href="http://jiasd123.oss-cn-hangzhou.aliyuncs.com/list.txt">http://jiasd123.oss-cn-hangzhou.aliyuncs.com/list.txt</a></p></blockquote><p>同样我们可以自己通过JS编辑规则，来实现更高度的定制化。语法规则和具体，可以查阅这几个参考资料:</p><ul><li><a href="http://www.cnblogs.com/edward2013/p/5560836.html">浅析PAC，教你动手修改你的PAC文件及user-rule文件实现自动代理</a></li><li><a href="https://zhuanlan.zhihu.com/p/22166179?refer=barretlee">详解代理自动配置 PAC-知乎专栏</a></li><li><a href="http://blog.csdn.net/xundh/article/details/48193369">PAC脚本语法（代理自动配置）</a></li></ul><p><img src="https://i.imgur.com/L4unCUQ.png"></p><p>我们还可以通过软件来直接在Chrome上集成这种自动切换的插件。</p><p>比如：<a href="https://switchyomega.com/">proxy-switchyomega</a> </p><p>跟着教程走一遍，你会发现PAC的神器之处。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><hr><p>祝下载不再缓慢，祝git把把顺畅。<br>当然我们只是走了第一步，还有很多可提升的空间，后续我会再写两篇。</p>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纪念 </tag>
            
            <tag> 符号·人生 </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017七夕</title>
      <link href="/2017/08/26/2017%E4%B8%83%E5%A4%95/"/>
      <url>/2017/08/26/2017%E4%B8%83%E5%A4%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对" data-whm="文章校验失败，但您仍能够查看解密后内容">  <script id="hbeData" type="hbeData" data-hmacdigest="985191b67e12e7940bcda966786aa1b91aa012072af4f7d8f659e28bd72dfd27">6f5d2d289be84a86bcae4f8c2d0ceb57ddcb4abe2f5e92d54721cddcec24f9004133369f930615b4e20ece07c7d24c7cfdaea08ea9624014312867ad46df42b527530c5769229c4230c801068ebc82e81724cf352deb7a6ccfd91199272e28de25371cda86e00fc4295801606620287d1787819ed55b0f7746d0b06c4fc44cd47dd8923b5e1f8dc1d86fd3c8f6b616b9a39fd1e80540e4b484fb83712024953ae088d1f149ebeb597043e580019b03915e91e8ec9ee0ef3e1e324faf871c0a77bb68c9677c39b13e10e65930c62c337fe1f787cec8d0f1e586583273afe5ccb10c53cffc9129aacae3ffacb4d363407c06681c6fb2145df9701aaf65c226486e2ceb9e6cb9f8530a325e82e40213956630c2bb3b9d5e05e4daada52b731d0334ea137bd0a41a7456e6f495084958c58820aba42d1af5973668d47ec60083d6a6ef76fc3dbd259d179161b1c7a96b00d88d595dfc50b6e374e892db70ff5efaba54f392ec71f5bc017d474660607a6bc50447672b9b6078259bda753599982817eddd2b941b5c03e38b073ec201361f868aba12bbcc4ff2dbe0309a8dd1a3376de5ce94867d275d33b274b2ef129d52b6445349e50a2997b95a5d124bbac3dd9ef8211718fea4b98e94d3d39624169f3fe9fd1230f14e2efb5358e5eddd3644e662d20655de91b925094677c2e2dabf08e92202252ecc226eb8d098537fefc4a97fe3915a15ddb8f7ce83222617bc2a8a89aebafbf26109ad312371b611510709026c5338b9a5b5df9b6ae779328354e6b0ca64c4aa9a3dcc4f922fc5a43604b7d87dcee3cd569d8057b4a9958aa99a591bf1db8dbd77a49fe25537224eaf9d3a2e5ace2e8ddf7d0ec9d9e3b8e5e76eb7bc1dd7b2d7a0c95d5893b0081dc7e73c6561482e5dc2b516d42abd8a50dd540b165e4da37bc03a35b1048b3af1e1e081d923a0814c109ff33f9abaf9a270073721d35766d9787a18c71bb3e034b4b3d14bf852ba21895e41363ce760e03fd3655c423853fb69045f5738a847adc4d1f9cc79caf6d85522575fef67fc6a8a691bd97b276ba7c975deb684ce1126af5156dbcf090ae61ff3cfbae83c66f9aa74344e28387afc92bd3453c5446966a5d2032e4c9a88e2f6fdceccdf07e51e4e48b66486f0494faaa531066344677a20fc538150f0d7e9e42186d75d6a16378d6c168ec31cdce8b600f9ced5326e84f737a2abcb67573d94b526ab649b853e7458a9ad7866e1a21ecb9357bd47270c0f02363ef773217293f9396eaea53c806038ba9e1253b5fd4b9b85dd887d565382e40ac0dbb9546190cd93dd8c4c176778d32de8809e0d280a05075319e2e7b3cf2003750f0cca06b9f219b8cd43235df711e462bec5f424b8d0fe6435b259ae91b696923bedc83a6350049f45ff25a7ac59aecd2b21677b820f01c4a3e3960c3cdb926b1171f3cbac6149de137d56512e5c4fa2d109a365b6ef674f2666903ed705ce773ff7b3f68a3022d32405a625870c75110f5ad3424dca15820d7564797fd76732a6aa92598a7de0ecc8b53d2b8079b61f87e9f19bc11902548ff0cc601fa9bd13d39ea7f527e2bb5e1ef123bf25361003e70c57f6d801e144c78297e0e2877320afa1c5dd6529dc6e62b5b456d0a0242fef0ff095712ce8674c643000bc5aeb5b0449c3240120865b75a1a4be81310fbf3a835f90df44f2ef1c8504ebd387945c2669bf8560895199525d42f935a5a2633ead64cf65b655e76157c9ecd73b5933fd178d4347e8ef056fc05ceefd7fcc309416cac1e8fb5c220eefb112fcd528c2c107066f4d1dd14c9d387ea7518a6f07354220e259146dc3e9721172026d035230e271301472df8a4093be5fa3fd3ef8133069647a06dbf24a4e979a1800a2f128d02e87ecdfa91701f55e0c1b2b0a1fe84fda39a1c3b64921363bc46ceed50d90cd84b1f3a8410e2c79c948133ea276672603776c36ceddc28d76bef5a56f2dc895b8df9debe5287a072ac7f34d4e0c80bd3e7722e591d71bb13672ca77c7ef6edb71943e8761c816d20f93d20e9131106c113a4313658e379582ac4a6aa172bc7fc5ffc7a33f99f6e9ae396e548120e4756eb0b8d0bdeacea16c4144b7b3d1476a521cca5103e7a9972d0b687f35169892fc7f4a5e6accb3146086228577482dccb1ee5543cc4e0181fd5cda85de130981687c0012588080cc6e69662a9deacabd29cbdbbd4d5450b48e70d45b3aa09952ebeda24e56aa9c53d07539f6097075b20f579be6babce0c7dca005a046e67c01fd0c58de34c2d55b6ef18ee0edf12c265d1c76a1777c86ef3de11bc60263e47d812312e87685b0fd01f41f2bd351396f4c2bf07c19cf7384c75f24e4386552ebc99741b2142b35afa765f1e6b7800747ea672cfd308f7d7fffc016002dd0d37a525522aece42eddfe86f865b56b21d9db31ea540fc3f3db3f0b17dc797edefdef2be278cf37c02eb79864b9c7bec3ead0cd4b445ca9742f216c9540ea83f60cd32856b66794e6b35461cf46590fd96972eb2f63c5f791a9e58124f98b705ad1931ab295a4078e5dedef1e59427537f63817e3a5d6b0d2922c2e57236538ef5924cdd096bdacd4908242f1ce4beebfde55606abd219895d5671785668fbc8b85de3e0d2326798a1f448b7e73e3173121659db20d42426d745e1c16308d9c189af06e3d936876fa6080e306a021006e4aa2773a71acee36885c851e118c0d92d64fee1ad98c910981c3e9191e606ef7b4931dc65184ea7af5d83bd344fdcc837f30369454451d28b46c50db9baf4f076488d540f9f34d615a748b9e9a3d82568d65ef22c8a7a25b1e07ed37db18c5cb20ab66f36bec7e85b610d1f3eb37008348f6c6a39dc633df87420da26610f011b722a4c4d094ad8c2487136a4364ae344b2db2ca8a42a9d31d8ac9ed2eb0854d6d445fbce8fe912d777b3634e59e232d4971bb942e59194a750dc31d82ab428aa1bc9759a9ddefcc32a3db6505095e0ec551c3035560e559f48fd6420e2a75aa2a64feaa01c97872a8bc4a92b63f2f13e65f0f5782843902f7f14f0d22d312d6fefb0cf8b446db41ebc26c98e7d843a1432d9813780552166c21562c6c69f4c56f6e850323772bce439955c87ed5af43c3b0f35d26efa1896ed2bd8d1814dbd73674ceec3583af7b1df7fcf4f7e078111c5832ff8dc70508eb6eb30f3830723d2040b91741a7828b54581f8ea465b45163ffd5d9cfa7033c784b27894378a3a5de96a7914ef8a9e1726a997e56679de9d4c6e1a977cc0609d4de8e80d434625eea6873218ccdf264408cebcc6d2c19f22780d98efbf0c865d973039850044fd3a727bcf8b300b6d7038187cf28c0d14ed759260926b58219691cd55cf4fdb6f195f5a9a079b74e4f21942e48c1b08eee103b965e0c8c54c4911d666038b28fa0e7145b5457c2c86c7b492df02ec31ac1bcb47fe55c349a89b544a870a03bc67c08f354d77d14568aa4d6b665bde65332d3d235251b5dde928073ee1c1a28792bd1178c3fe8b96a1435a689ae45a8facea56785866cb1bd50f922656939424211171ca556d11427d73e3f52c9ceab28519d0510c179637c19e0daf9aa2bfb697d058403fa14fa73371bc4ccdc02ee8a6f690e5cf16786eedbdddf651094853e1661ce9a67939a5f94c748523ebb6be94b5118b20b35ae8e406e49650d3924f69f1202bb90c15d3d34513ab0c072f518e81858c3a98ebd9ff5787320d8c82e75c8b4d1f7754e6b6eae77d98f7efee42f4a3a46867beb5d99c195932f0d9802cd356a91feb57a00e54f5e4e79d20fc08d336a998cdc670387d221220793cee6830a735deeb24c9e9a2321ca291b4b783833bf45625527412617b0592e9162f82bf697f7b906f88e24217af2ac98284b6e3cd7f34f405bc428920f9b93bd8e2b1350bdcb915e033eaffbda5782274482249c49defaef36c8b18a0a0a53eec878487438c2855f7e2e0a7acc93f393db6373555b6e4ed6f1e97720ab0fff98cac33ab05b9bbcf28dc5cfbd6ec6377c77bce14d08a62c16b7ebe915f6057d7bf11971533494b40988ada2434656abbd26024f9100b5aad4a8f8c04630b804a4fed9fb74b25ff41442710a3bd513877534ff859c61b82f3845071cb182fdb38cf317567b277409ad8655c9feb095a533cf62bc1bbdfd768547e0b6c7049c455daec777ca0d3f0a0ed0182615d33fc2acee9851d687fe42225619f6ca055da04b279298dc988c8d3da4baae9c0a495cdcbdce3297ac30e6468b8f2d963213d3f5be40c8c8be88278835444e0113bade348607ec13c283ffe2c7bdc73a800735ad43536d737252d946578fc3e79fae85fba77142d180c40e8d9a356fa7a9481a3a8581e280927b1722d90390a891656124cdc1af441e00f92e5a89ecf461eb97afffb76502e64650c4a8a288ce5d49f9f0b9edaeed01f562ac723ac6b65ad7e6fc3a82d30e31d57e4af2c85d422f2ecc7d3cf5491924cea49abed62b9bdb044f417538a3d3f337068714572d7eb9f3d9aa179ed6f66b635ae0ee0f1ca2e15ac5a0317c89b9a074f4fa66a259877eb99eaf2216d878143081f687890e06f01178098a60f29eea9d7fdc5e8dd57b04aecf341e185701f2644250a21cd5e10b30aa50b67dcceae2cc3038059d15b26bdace1a0b674b4622b9c4d07738ab63af76b747ee850a5e8e5eabbf09970f17664464432ab82ae3c5cf7fb8606c6c7256ec818994954450caa270f9b55f418ae0f651b7bbf251a5f974fdddc92c4220cbd998eeca033fd7d94335189369b3451b0e83a195a533f57b43ae92a609cbd30a6abdcefd932e914bc023473ea1f3aebbb2cfdb5a1955454d08b2a8c9515218ec980029ae0bb32651e0db8ca522b2f269d65a059349d6487611ebfd94e46046ab8b44418cd5a6431128711f5a00747f38b171133c4a9303d0a33db5c2e72b3170c87c89fdb88665838231defee0de687df4a2003f89fcb381c05c2300664902ac1a7d519f08750e9b3a2f57206400ce774756bef7bb72c6e1de59406d82b520ed8a78e3c43c49ea87bcdc31f1415a9301667672decebd17106918041de4807629b8f107452d9ebffff0967efff64f8d32c07d9dfc6259cc580141327e74a38452652b644a7fb463ff4cb9f65859d53bd430be96dd187a11289c4b0359d37e93fc51d9a9f343cae85df04f37dac6a83f1528b7f744ed6fcdd61f642cbf617946388a25c669e4e4a39f389a6a71ccc7ecec6ed05b2a265cd0ab09d2aa7af823db919ca61ca7428096215a1315819d853ab36bb8a52cb3e21c7d33052caa16ec3ff84382f25a3c37880166c8669652b3e8d3d3f89f91d33b69692725aa41dc518384f9c69e738358c3ee3eca924ff1d9dee22ee4d855d1e2d2bada04dce0fcda18749a738789f06f9edb49f2592afcda850d0e7f39e8ad41d7c18e8516ed6b909087b77a2d3dc0870cb94bb85e6902738054256a6196d2e803040c4d9da7f7c819bd28f99352e98ebd578681e22dc41daf7a0cf437f2ae9476c877c9358d234530b7fca03c916ecef30669e390b1a0726ff7240097f5bdea9512ee7188a5db9cc08692f57641d1decf1df701fefe44a3c81f7f641aa575d093a74112d9d3420b7d311273362fea054307099c6756f009555531ef08500b38946932cfa57849f017668feb52251baba3c1785d5d738cee4932722e4812cf83bd07d2d88d79a08ce4022a6d95af8e881d616e842f9560ac86a755094f7f62080bcd50b1170ca266afbb924558c4cf8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请Tong输入密码❤️</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纪念 </tag>
            
            <tag> 符号·人生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio更改R文件位置</title>
      <link href="/2017/06/22/Android%20Studio%E6%9B%B4%E6%94%B9R%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE/"/>
      <url>/2017/06/22/Android%20Studio%E6%9B%B4%E6%94%B9R%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title=" 前言"></a> 前言</h2><p>AndroidStudio（以下简称AS）内置了多种强大的快捷操作，最近项目需要在另一个项目基础上更改，替换包名是个麻烦的工作。安卓程序中的R文件改名的各种坑，导致找不到文件的错误。</p><p>后来发现只需要几个简单的步骤就可以将R文件位置替换好。</p><h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><ul><li>视图切换为<code>Project</code>或者<code>Android</code>，方便查找文件。</li></ul><p><img src="http://i.imgur.com/s9ARji6.png"></p><p>以Android视图为例：</p><ul><li>找到AndroidManifest文件，找到package中的包名并选中</li></ul><p><img src="http://i.imgur.com/nZvPIT3.png"></p><ul><li>右键<br><code>Refactor</code> -&gt; <code>Rename</code> 或者快捷键<code>shift</code> + <code>F6</code></li></ul><p><img src="http://i.imgur.com/ksnKdvK.png"></p><ul><li>点击<code>RenamePackage</code>，然后输入所需的R文件名字，点击<code>Refactor</code> 过程可能会有点卡顿，等待画面加载完毕。<br>（过程中出现的重命名都用<code>Do Refactor</code>）</li></ul><p><img src="http://i.imgur.com/O0eniLK.png"></p><h2 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h2><ul><li>打开对应Module的build.gradle文件,更改相应的applicationId即可。</li></ul><p><img src="http://i.imgur.com/dKAGhzw.png"></p><ul><li>然后点击<code>Build</code> -&gt; <code>Rebuild Project</code>等待Build完成</li></ul><p><img src="http://i.imgur.com/kq155GY.png"></p><ul><li>这时候会发现包名及R文件已经更改。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂类解决 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IC卡破解教程</title>
      <link href="/2017/06/12/IC%E5%8D%A1%E7%A0%B4%E8%A7%A3%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/06/12/IC%E5%8D%A1%E7%A0%B4%E8%A7%A3%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>version 1.3</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　我的学校并不是“211”,“985”之类的重点大学，学校的热水也不是免费。每学期补贴的20多块根本不够用，而且丢了之后也<strong>懒得去买</strong>，关键还是觉得<strong>热水</strong> 这个东西<strong>太奢侈</strong>。走过弯路，不过也算比较顺利的解决了问题。后来我还自己编写了一个带GUI程序和安卓小DEMO软件，直到后来学校把设备都换成<strong>联网</strong>，并且实名制。免费水卡算是告一段落。</p><p>　　好在升级设备前也把水卡钱充的足够多了，我不贪心够用就好，仅仅帮助我女朋友和室友在内的几个人而已。本文是把我理解的一些入门知识梳理开来，特此纪念一下这段大学时光。自学能力有限，不足之处望不吝指正。</p><p>　　我把实现过程分成两个部分，可以先看<strong>原理简介</strong>，也可以直接看<strong>实现过程</strong>。<br><br/></p><h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><p>1.首先介绍一个概念，<a href="http://baike.baidu.com/link?url=7tGP8VDdC3AEO5P7G-1OzIf_yUIdpyQhrKyOknEtkvp25htStZQEPpy1DWFGlcDmq1HonwDLFKglh_qcZ2QVPQfz360hWlkuZjMLyJz1KKJDNieHDLcv1LttPN2bCv3HjR3ItzLgnjPvYdgP1_Ti3zGtlquvP6jvN9KL8tGVvG59QmLxwxNYKPfxCQEj48HNcQ2HbAYhN2184QZd2XOipq">RFID</a></p><p><strong>射频识别</strong>，<em>RFID</em>（Radio Frequency Identification）技术，又称无线射频识别，是一种通信技术，可通过无线电讯号识别特定目标并读写相关数据，无需识别系统与特定目标之间建立机械或光学接触。 </p><p>射频的话，一般是<em>微波</em>，1-100GHz，适用于短距离识别通信。<br>RFID读写器也分移动式的和固定式的，目前RFID技术应用很广，如：图书馆，门禁系统，食品安全溯源等。</p><p>从概念上来讲，RFID类似于<em>条码扫描</em>，对于条码技术而言，它是将已编码的条形码附着于目标物并使用专用的扫描读写器利用光信号将信息由条形磁传送到扫描读写器；</p><p>而RFID则使用专用的RFID<strong>读写器</strong>及专门的可附着于目标物的RFID标签，利用频率信号将信息由RFID标签传送至RFID读写器。</p><p>从结构上讲RFID是一种简单的<strong>无线系统</strong>，只有两个基本器件，该系统用于控制、检测和跟踪物体。系统由一个询问器和很多应答器组成。</p><p>2.简单说下RFID<strong>工作原理:</strong></p><p>卡片由一个卷绕天线和特定用途集成电路模块组成。</p><p>其中，模块由一个高速(106KB波特率)的RF接口。一个控制单元和一个8K位E2PROM组成。读写器向MF1卡发出一组固定频率(13.56MHZ)的电磁波，</p><p>卡片内有一个LC串联谐振电路，其频率与读写器发射的频率相同，</p><p>在电磁波的激励下，LC谐振电路产生共振，从而使谐振电容内有了电荷，</p><p>在这个电容的另一端，接有一个单向导通的电子泵，将电容内的电荷送到模块存储电容内储存，</p><p>当所积累的电荷达到2V以上时，此电容可作为电源向模块电路提供工作电压，将卡内数据发射出去或接收读写器的数据。</p><p>3.<strong>存储结构:</strong></p><p>字节号 | 0 1 2 3 4 5  | 6 7 8 9 | 10 11 12 13 14 15<br>—-|——|—-|—-<br>控制值 | FF FF FF FF FF FF| 07 08 69  |FF FF FF FF FF FF<br>说明| 密码A（0<del>5字节）  |存储控制|密码B（10</del>15字节）</p><p>4.<strong>控制属性：</strong></p><p>每个扇区的用户密码和存取控制条件都是独立设置的，可以根据实际需要设定各自的密码及存取控制。</p><p>在存取控制中，每个块都有三个控制位相对应，用以决定某数据块或控制块的读写条件，定义为：”CXxy”，见表1所示。 </p><p>其中CX代表每块控制位号(C1～C3)，x代表某块所属扇区号(0～15)， y代表该扇区内某块号。例如C1x2 即为x扇区内块2的第1控制位，余此类推。 </p><p>注：控制位的设置存放在存取控制字节中，见表2所示。    　　</p><blockquote><p><strong>表1：控制位定义”CXxy”</strong></p></blockquote><p>块0|C1x0|C2x0|C3x0|用户数据块，(0区0块除外)<br>—|— |—-|—-|<br>块1|C1x1|C2x1|C3x1|用户数据块<br>块2|C1x2|C2x2|C3x2|用户数据块<br>块3|C1x3|C2x3|C3x3|密匙存取控制块</p><blockquote><p><strong>表2:三个控制位在存取控制字节中的位置</strong>(注：” _b” 表示取反)</p></blockquote><p>|位号|bit 7|6|5|4|3|2|1|0<br>—| —| —-|—|—|—|—|—|—<br><strong>字节号</strong>||||||||||<br>字节6||C2x3_b|C2x2_b|C2x1_b|C2x0_b|C1x3_b|C1x2_b|C1x1_b|C1x0_b|<br>字节7||C1x3|C1x2|C1x1|C1x0|C3x3_b|C3x2_b|C3x1_b|C3x0_b|<br>字节8||C3x3|C3x2|C3x1|C3x0|C2x3|C2x2|C2x1|C2x0|<br>字节9||BX7|BX6|BX5|BX4|BX3|BX2|BX1|BX0|<br>所属块||块3控制位|块2控制位|块1控制位|块0控制位|块3控制位|块2控制位|块1控制位|块0控制位|</p><p>关于更多细节知识，点击这里: <a href="http://pan.baidu.com/s/1jHCeVkU">mifare卡的初值说明及使用方法</a></p><br/>### 实现过程<p>　　<br>1.<strong>分清卡的种类：</strong></p><p>　　我们破解卡，首先要分清是什么卡。<a href="http://baike.baidu.com/link?url=7tGP8VDdC3AEO5P7G-1OzIf_yUIdpyQhrKyOknEtkvp25htStZQEPpy1DWFGlcDmq1HonwDLFKglh_qcZ2QVPQfz360hWlkuZjMLyJz1KKJDNieHDLcv1LttPN2bCv3HjR3ItzLgnjPvYdgP1_Ti3zGtlquvP6jvN9KL8tGVvG59QmLxwxNYKPfxCQEj48HNcQ2HbAYhN2184QZd2XOipq">RFID</a>里有很多种卡，IC卡现在最为常见。ID卡过去较为常见，逐渐被淘汰。现多数卡都是IC卡，M1类型的。为了帮助大家识别，介绍个简单方法。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208180721.png"><br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208180836.png"><br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208180847.png"></p><p>　　<br>2.<strong>破解原理：</strong></p><p>IC卡的特点是由16个扇区存储数据（<strong>0~15</strong>，不是16，0扇区是第一个），0扇区用来存储卡号，所以机器上<strong>直接能读取到卡号</strong>。每个扇区的数据有４块，即0~3。前三个用于存储数据，最后一个块用来存放KeyA和KeyB。先不用管有什么区别，只要记住这个就是破解一个扇区的关键就好。 </p><p>　　紧接着如果我们有了<strong>KeyA</strong>就可以更改相应扇区的块里面的值。（这样听起来是不是简单多了？）<br>　　<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208180903.png"></p><p>　　被标为<strong>蓝色的就是KeyA</strong>，后面跟着的ff07 8069是默认控制位，先不用理会，后面的6efd 32e1 1f59就是KeyB。只要我们获得到这个，就可以随意更改其他三个块里面的数据。（其实第四个块，块3也能更改，后面会提到，一般不需要因为你改了，机器不识别也没用0.0）细心的你可能发现这KeyA和KeyB不TM一样嘛！本来应该不一样，这里它俩一样更是降低了安全系数，同时为以后我们穷举破解减少了时间。</p><p>　　这是一个卡<strong>0扇区</strong>的数据，第一行为0块，卡号就是存在这里。</p><p>　　也是识别一张唯一卡的标志，<strong>它是不会被更改的</strong>，就是说你即使知道KeyA也更改不了这个扇区里面的值。这样做的目的当然是有的，就是说如果以后出了问题通过日志记录会知道是哪张卡。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208180912.png"></p><p>　　<br>3.<strong>破解过程：</strong></p><p>　　说了这么多知道了原理，现在终于开始操作了。</p><p>　　连接上ACR122U读卡器到电脑，运行M1卡服务程序。</p><p>　　程序会自动识别出读卡器，初次安装可能会自动安装驱动，稍等一下就行。直到读卡器的灯亮起红色，这时候如果程序没识别读卡器重启一次程序就行。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208180928.png"></p><p>　　这个时候已经识别出读卡器，将需要破解的卡放在上面，读卡器的灯会变成绿色，并会有一声“滴”表示已经检测到卡片。点击开始破解，进入穷举。</p><p>　　等待破解，这个过程看卡加密扇区多少和密码强度有关，只要不是全扇区加密耐心等待一会儿就好。极个别情况，我试过会长时间无响应，再试一次就好。破解完成后读卡器会闪一下，并有一声“滴”。</p><p>　　在软件根目录下会按日期生成dump文件，用ultra edit 或者sublime text之类的编辑软件就能直接打开，看见里面的数据。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208180939.png"></p><p>　　接下来的范畴就是<strong>改数据</strong>，我两次打水后的金额一定不相同。以此找出数据区，推荐使用ultra compare这个软件。省着自己人工找了。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208180949.png"></p><p>　　我比较懒，没拿以前的水卡做对比，这里放了一张我饭卡的。<strong>饭卡联网大家不要动啊！</strong>联网的服务器有数据!<strong>切记！切记！切记！重要的事情说三遍！</strong></p><p>　　我上次卡里有<code>35.47</code>块16进制是<code>0ddb</code>，它存储的是<code>db0d</code>，这里不难看出。下一次消费<code>12</code>，所以是<code>23.47</code>块16进制是<code>092b</code></p><p>　　在后面的<code>0069</code>没弄清，不过每次都不变动，再后面的<code>13b9</code>。<code>13</code>是日期<code>13</code>号，和我们的消费终端位置。<code>b004</code>是<code>04b0</code>换算过来就是<code>1200</code>精确少数点后两位就是<code>12.00</code>块就是我这次消费的金额。在后面<code>0605</code>类似，最后<code>6a7b</code>那里和<code>6aee</code>不同是为了让整个行的异或和校验为<code>00</code>。</p><p>　　这有点类似于一个<strong>密码校验</strong>，不能让人随便改数，当然这个算法我现在通过<strong>多次数据对比</strong>发现了，所以随便改数也就没事了。可以根据实际情况，<strong>多次取值</strong>，一般都可以推算出结构，然后算出来滴。</p><p>　　<br>4.<strong>复制、改值</strong></p><p>　　先说复制，直接把另一个复制软件打开，将uid卡放在上面，dump文件对应好，就直接成功了。没什么技巧，一般都能看懂，注意一点一定要是UID卡，否则会因为0扇区写入不成功出错。</p><p>　　改值，用<strong>PCSC Mifare</strong>。</p><p>　　打开软件，初始化，放上卡片。点击加载秘钥，把从dump文件里要修改的扇区KeyA记住，输入进去。密钥存储编号默认就行。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208181002.png"></p><p>　　点击扇区认证，我是要修改2扇区所以打2，密钥选A</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208181010.png"></p><p>　　如果你前两步没有出问题，那么会显示认证成功！紧接着点读取扇区就会显示这个扇区的数据。</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208181018.png"></p><p>　　点击二进制写扇区将数据<code>9B 07 00 69 15 B9 0B 01 40 06 4B 00 06 05 6A 3A</code>写进去，去掉空格（由于这个里有两个块都存值，所以我勾选两个，一次更改完）<br><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208181025.png"></p><p>　　完事点击二进制读扇区会发现数据已经更改，后一次我是又写回来了，改饭卡<strong>绝对作死</strong>啊！</p><p><img src="https://raw.githubusercontent.com/ArnoFrost/BlogImage/main/img/20220208181033.png"></p><p>　　通过<strong>PCSC</strong>可以修改密钥，自行探索即可。</p><p>注意：经测试发现这个软件只能在xp下好使，所以我把它放进xp虚拟机中运行，应该是软件不兼容后期维护也差着了的缘故。还有如果打不开记得安装framework 2.0框架 </p><p>　　5.<strong>全扇区加密破解</strong></p><p>　　当然上面的方法只适用于非全扇区加密的小打小闹，现在好多公司都是防复制卡，就是全扇区加密。但是通过侦听方式还是可以实现的。这部分比较复杂，自行百度就行，我说的也都大同小异。</p><p>　　pm3的工具比较贵，廉价方案是用侦听卡，前提要有ACR122U读卡器。简单原理就是通过侦听两次通信，得出一个KeyA，相当于有一个扇区已知，再进行破解。这部分内容可自行探索。<br><br/></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>　　花了几个小时，终于整理完了这篇文章也算是有始有终吧。未来估计用到很少，可能就是自己电梯卡用用而已。大四上学期，临近毕业人的心态也有变化。细细想来这算是一个很宝贵的经历。感谢百度，感谢我的室友，感谢我女朋友桐。</p><p>　　2017年6月12日11:08:24:毕业后又整理了一次这个文章，重新提交到博客上。以此纪念我的一段大学Geek时光，纪念当时为了与一个编程兴奋到彻夜未眠的自己。</p><p>　　希望这篇文章能对你有帮助。</p><h2 id="6-更新说明"><a href="#6-更新说明" class="headerlink" title="6. 更新说明:"></a>6. 更新说明:</h2><table><thead><tr><th>版本</th><th>时间</th><th>说明</th></tr></thead><tbody><tr><td>version 1.0</td><td>2016&#x2F;10&#x2F;16 星期日 22:12:50</td><td>初版</td></tr><tr><td>version 1.1</td><td>2017年6月12日09:47:48</td><td>文稿修改</td></tr><tr><td>version 1.2</td><td>2017年6月14日15:24:56</td><td>文稿修改</td></tr><tr><td>version 1.3</td><td>2022年02月08日17:49:01</td><td>更换图床为Github</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纪念 </tag>
            
            <tag> 符号·人生 </tag>
            
            <tag> 方案 </tag>
            
            <tag> RFID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓开发常用软件</title>
      <link href="/2017/06/12/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/"/>
      <url>/2017/06/12/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="系统工具类"><a href="#系统工具类" class="headerlink" title="系统工具类"></a>系统工具类</h3><p>基石软件</p><blockquote><p><a href="http://www.160.com/">驱动人生软件</a></p></blockquote><blockquote><p><a href="http://guanjia.qq.com/?ADTAG=media.buy.baidu.DNGJSEM">电脑管家</a></p></blockquote><blockquote><p><a href="http://www.nvidia.cn/Download/index.aspx?lang=cn" title="NVIDIA">NVIDIA</a></p></blockquote><blockquote><p><a href="http://pinyin.sogou.com/">搜狗输入法</a></p></blockquote><blockquote><p><a href="http://www.google.cn/chrome/browser/desktop/index.html">Chrome</a></p></blockquote><blockquote><p><strong>Chorme常用插件:</strong></p></blockquote><ul><li>TamperMonkey</li><li>穹顶穿越</li><li>Smooth Key Scroll</li><li>小番茄</li></ul><blockquote><p><a href="https://github.com/oldj/SwitchHosts">SwitchHosts</a></p></blockquote><blockquote><p><a href="https://raw.githubusercontent.com/racaljk/hosts/master/hosts">hosts文件下载</a></p></blockquote><h3 id="开发工具类"><a href="#开发工具类" class="headerlink" title="开发工具类"></a>开发工具类</h3><p>开发必要支持</p><blockquote><p><a href="https://developer.android.com/studio/index.html">Android Studio</a></p></blockquote><blockquote><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">JDK</a></p></blockquote><blockquote><p><a href="http://www.eclipse.org/downloads/">Eclipse</a></p></blockquote><blockquote><p><a href="http://download.csdn.net/detail/liu_tao/9257815#comment">ADT23.0.7</a></p></blockquote><blockquote><p><a href="http://www.myeclipsecn.com/">Myeclipse</a></p></blockquote><blockquote><p><a href="http://download.csdn.net/detail/zxc406924714/4382091">Sqlite Expert</a></p></blockquote><blockquote><p><a href="http://pan.baidu.com/s/1i3vEHb3">ApkToolKit</a></p></blockquote><blockquote><p><a href="http://www.52pojie.cn/forum.php?mod=viewthread&tid=405618&page=1">VMware破解版</a></p></blockquote><blockquote><p><a href="http://www.mysql.com/downloads/">MySQL</a></p></blockquote><blockquote><p><a href="https://tomcat.apache.org/">Tomcat</a></p></blockquote><blockquote><p><a href="https://developers.google.com/android/images">Android镜像</a></p></blockquote><blockquote><p><a href="http://www.wugfresh.com/nrt/">Nexus toolkit</a></p></blockquote><h3 id="文字处理类"><a href="#文字处理类" class="headerlink" title="文字处理类"></a>文字处理类</h3><p>文字编辑所需</p><blockquote><p><a href="http://www.xiumu.org/note/sublime-text-3.shtml">Sublime Text3 破解</a></p></blockquote><blockquote><p><a href="http://www.jb51.net/softs/277559.html">Ultracompare</a></p></blockquote><blockquote><p><a href="http://markdownpad.com/">MarkdownPad</a></p></blockquote><blockquote><p><a href="http://markdownpad.com/download/awesomium_v1.6.6_sdk_win.exe">Awesomium 1.6.6 SDK</a></p></blockquote><blockquote><p>邮箱:<strong><a href="mailto:&#83;&#x6f;&#x61;&#x72;&#x33;&#54;&#x30;&#64;&#108;&#x69;&#118;&#101;&#x2e;&#99;&#111;&#x6d;">&#83;&#x6f;&#x61;&#x72;&#x33;&#54;&#x30;&#64;&#108;&#x69;&#118;&#101;&#x2e;&#99;&#111;&#x6d;</a></strong></p></blockquote><blockquote><p>授权秘钥:</p></blockquote><pre><code>GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==</code></pre><h3 id="常用软件类"><a href="#常用软件类" class="headerlink" title="常用软件类"></a>常用软件类</h3><p>功能扩展</p><blockquote><p><a href="http://www.getwox.com/">wox</a></p></blockquote><blockquote><p><a href="https://sourceforge.net/projects/ccseer/">seer官网下载</a></p></blockquote><blockquote><p><a href="https://justgetflux.com/">flux</a></p></blockquote><blockquote><p><a href="http://mofang.ruanmei.com/">魔方</a></p></blockquote><blockquote><p><a href="http://www.mochiwang.com/">小黑屋云写作软件</a></p></blockquote><blockquote><p><a href="http://www.51dzt.com/">金山打字通</a></p></blockquote><blockquote><p><a href="http://pic.2345.com/">2345软件</a></p></blockquote><blockquote><p><a href="http://haozip.2345.com/">好压</a></p></blockquote><blockquote><p><a href="http://www.voidtools.com/">Everything</a></p></blockquote><blockquote><p><a href="https://www.yinxiang.com/download/">印象笔记</a></p></blockquote><p><strong>整理:</strong> ArnoFrost</p><p>**版本:**v1.22017年6月14日15:04:39</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 安卓 </category>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Arno , hello world</title>
      <link href="/2017/06/08/Hello%20Arno%20,%20hello%20world/"/>
      <url>/2017/06/08/Hello%20Arno%20,%20hello%20world/</url>
      
        <content type="html"><![CDATA[<p><embed src="//music.163.com/style/swf/widget.swf?sid=461525011&type=2&auto=1&width=320&height=66" width="340" height="86"  allowNetworking="all"></embed></p><p>blah blah blah</p><p>Hello, 欢迎来到我的个人博客。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> 安卓 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 纪念 </tag>
            
            <tag> 符号·人生 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
