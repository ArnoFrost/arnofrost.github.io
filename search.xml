<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[安卓全局单例刷新Token]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%AE%89%E5%8D%93%E5%85%A8%E5%B1%80%E5%8D%95%E4%BE%8B%E5%88%B7%E6%96%B0Token%2F</url>
    <content type="text"><![CDATA[version 0.1 前言前阶段公司的业务比较忙,很长时间没有整理出来什么博客.最近刚空出些时间,简单再整理一些记录. 产生原因:客户端是被动向服务器查询登录状态,一些网络请求需要一个刷新token来验证客户端是否处于登录态,是则可以进行用户操作,否则做登出操作. 刚开始直接单纯的每个请求刷新token,刷新token,然后请求是没什么问题的. 但是随着版本迭代,任务增多,有些时候,比如app首次启动, 会进行一些列用户相关操作, 比如拉取用户信息, 拉取特定的活动项目,这样一个刷新token的操作可能会并发, 而我们的服务端刷新token每次可能都会不一样,这就产生了一些问题. 以下会展开示意. 之前的方案(并发刷新token)为了简化理解我画了几张图,来说明情况,为了表示并发,我用RequestA,RequestB,RequestC分别表示三个请求,Server表示服务端 可以看见理想状态下,其实是没什么问题,请求都能正常收到与发送,但前提是他们是只有当A请求完全完成后B的后续请求,刷新token才不会受到干扰. 实际情况然而,提到了随着业务增多,实际中大多请求都是并发的,于是乎就有可能有下面的情况. 可以看到,实际中,很有可能产生,A,B同时刷新token,而在A拿到新Token A去再一次请求时,B已经从服务器拿到了Token B导致了A请求又一次失败,随着并发的增多这种失败的可能性越来越多. 改进思路我所想的是全局有一个单例的线程来掌管整个Token的刷新,并且这个token的刷新不是并发,而是队列,但是又不能让之后的请求变成队列. 否则简单的将所有请求变成队列即可,但实际情况我们根本不会让请求都是串行,无论从用户体验还是代码的书写上都是不好的. 所以在与iOS端讨论后,我们决定使用单一管理,并可阻塞的队列方式来管理token的请求过程,确保app内不会并发发送请求token的过程. 改进后就是主要几点: 当A请求过期后,需要向TokenManager去请求token. TokenManager会阻塞住队列,让后来的B请求等待. 当刷新完成后,通知所有队列中的对象,因为这个TokenManager只负责刷新返回token一个职责 所有请求拿到新的token,再来并发执行而互不影响. 代码概要主要是实现一个任务队列,并要求阻塞, 因为刷新token也是一个异步请求,所以可以用wait()来阻塞住,当一次请求完成后,使用notify()来让队列继续执行,然后再加入一个超时规则,一段时间内,不会重新刷新token,加快之后的token请求 那么在安卓中,HandlerThread内部已经有了一个loop的实现,就很方便处理这中情景,而不必要自己去写一些任务队列与Loop,简化代码量. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 //单独开辟一个线程来处理looper tokenThread = new HandlerThread(&quot;token-handlerThread&quot;); tokenThread.start(); /** * 通过handleMessage来处理每个任务 */ mHandler = new Handler(tokenThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); if (msg != null &amp;&amp; msg.obj != null) &#123; switch (msg.what) &#123; case 1: getOrRefreshTokenWithRetry(msg.arg1, (RefreshTokenListener) msg.obj); break; case 2: getRefreshToken((RefreshTokenListener) msg.obj); break; default: getOrRefreshToken((RefreshTokenListener) msg.obj); break; &#125; &#125; &#125; &#125;; /** * 直接获取或刷新token * * @param listener */private void getOrRefreshToken(@NotNull RefreshTokenListener listener) &#123; /** * 超时定时器 */ final Timer[] timeOutTimer = &#123;new Timer()&#125;; if (checkIsTokenExpired()) &#123; if (mContext != null) &#123; MobileAccount.getInst().refreshToken(mContext, new MobileAccount.RefreshCallback() &#123; @Override public void onSuccess(int code, String refreshedToken) &#123; lastToken = refreshedToken; if (listener != null) &#123; listener.onSuccess(refreshedToken); &#125; lastRefreshTime = System.currentTimeMillis(); cancaleRequestTimer(timeOutTimer); synchronized (mLock) &#123; mLock.notify(); &#125; &#125; @Override public void onFailed(int code) &#123; if (listener != null) &#123; listener.doLogOut(code); &#125; cancaleRequestTimer(timeOutTimer); lastRefreshTime = 0; synchronized (mLock) &#123; mLock.notify(); &#125; &#125; @Override public void onNetError(int errorCode) &#123; if (listener != null) &#123; listener.onError(errorCode); &#125; cancaleRequestTimer(timeOutTimer); lastRefreshTime = 0; synchronized (mLock) &#123; mLock.notify(); &#125; &#125; &#125;); try &#123; // 超时防止 TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; if (listener != null) &#123; listener.onError(-9); &#125; synchronized (mLock) &#123; mLock.notify(); &#125; &#125; &#125;; timeOutTimer[0].schedule(timerTask, REFRESH_EXPIRED_TIME); synchronized (mLock) &#123; mLock.wait(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; else &#123; //直接获得 listener.onSuccess(lastToken); &#125;&#125; 当任务执行到访问网络刷新token时,通过信号量wait()阻塞住任务,当收到回调时notify()去执行,为了防止超时,内部起了一个定时器. 外部通过RefreshTokenListener来处理token的回调,做相应的处理.相对于外部请求,依然是无感知TokenManager的存在. 外部调用时: 12345678910111213141516TokenManager.getInstance().getToken(new TokenManager.RefreshTokenListener() &#123; @Override public void onSuccess(String token) &#123; &#125; @Override public void doLogOut(int code) &#123; &#125; @Override public void onError(int code) &#123; &#125;&#125;); 整体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583/** * TokenManager * 用户Token统一管理类 * * @author ArnoFrost * @date 2019/3/19 */public class TokenManager implements ITokenManager &#123; private static final String TAG = &quot;TokenManager&quot;; private static volatile TokenManager singleton; /** * token过期时间 默认25分钟 */ private static final long TOKEN_EXPIRED_TIME = 25 * 60 * 1000; /** * 刷新等待超时时间 30秒 */ private static final long REFRESH_EXPIRED_TIME = 30 * 1000; /** * 自动检查时间 25分钟 */ private static final int AUTO_REFERSH_TIME = 25 * 60 * 1000; private Context mContext; private long lastRefreshTime; /** * 缓存中Token */ private String lastToken; private Object mLock = new Object(); private HandlerThread tokenThread; private Handler mHandler; private TokenManager() &#123; &#125; public static TokenManager getInstance() &#123; if (singleton == null) &#123; synchronized (TokenManager.class) &#123; if (singleton == null) &#123; singleton = new TokenManager(); &#125; &#125; &#125; return singleton; &#125; /** * 初始化 */ @Override public void init(Context context) &#123; mContext = context; //单独开辟一个线程来处理looper tokenThread = new HandlerThread(&quot;token-handlerThread&quot;); tokenThread.start(); /** * 通过handleMessage来处理每个任务 */ mHandler = new Handler(tokenThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); if (msg != null &amp;&amp; msg.obj != null) &#123; switch (msg.what) &#123; case 1: getOrRefreshTokenWithRetry(msg.arg1, (RefreshTokenListener) msg.obj); break; case 2: getRefreshToken((RefreshTokenListener) msg.obj); break; default: getOrRefreshToken((RefreshTokenListener) msg.obj); break; &#125; &#125; &#125; &#125;; &#125; /** * 销毁 */ @Override public void destroy() &#123; mContext = null; tokenThread.getLooper().quit(); &#125; /** * 初始化刷新定时器 */ @Override public void autoRefresh() &#123; AILog.d(TAG, &quot;autoRefresh: &quot;); TokenHeartTimer tokenHeartTimer = new TokenHeartTimer(); tokenHeartTimer.start(-1, AUTO_REFERSH_TIME); &#125; /** * 获得用户Token * * @param listener */ @Override public void getToken(@NotNull RefreshTokenListener listener) &#123; AILog.d(TAG, &quot;getToken() called with: listener = [&quot; + listener + &quot;]&quot;); Message message = new Message(); message.obj = listener; mHandler.sendMessage(message); &#125; /** * 带有重试的获取token * * @param retryCount 重试次数 * @param listener */ @Override public void getTokenWithRetry(int retryCount, RefreshTokenListener listener) &#123; AILog.d(TAG, &quot;getTokenWithRetry() called with: retryCount = [&quot; + retryCount + &quot;], listener = [&quot; + listener + &quot;]&quot;); Message message = new Message(); message.obj = listener; message.what = 1; if (retryCount &lt; 0) &#123; retryCount = 0; &#125; if (retryCount &gt; 10) &#123; retryCount = 10; &#125; message.arg1 = retryCount; mHandler.sendMessage(message); &#125; /** * 强制刷新Token * * @param listener */ @Override public void forceRefreshToken(RefreshTokenListener listener) &#123; AILog.d(TAG, &quot;getTokenTest() called with: listener = [&quot; + listener + &quot;]&quot;); Message message = new Message(); message.obj = listener; message.what = 2; mHandler.sendMessage(message); &#125; /** * 测试并发请求token稳定 */ @Override public void testTokenManager(int number) &#123; AILog.d(TAG, &quot;testTokenManager: &quot;); if (number &gt; 0) &#123; for (int i = 0; i &lt; number; i++) &#123; if (i % 2 == 0) &#123; int finalI = i; TokenManager.getInstance().forceRefreshToken(new TokenManager.RefreshTokenListener() &#123; @Override public void onSuccess(String token) &#123; AILog.d(TAG, &quot;initAutoRefresh:&quot; + finalI + &quot; onSuccess() called with: token = [&quot; + token + &quot;]&quot;); &#125; @Override public void doLogOut(int code) &#123; AILog.d(TAG, &quot;initAutoRefresh&quot; + finalI + &quot; doLogOut() called with: code = [&quot; + code + &quot;]&quot;); &#125; @Override public void onError(int code) &#123; AILog.d(TAG, &quot;initAutoRefresh&quot; + finalI + &quot; onError() called with: code = [&quot; + code + &quot;]&quot;); &#125; &#125;); &#125; else &#123; int finalI1 = i; TokenManager.getInstance().getToken(new TokenManager.RefreshTokenListener() &#123; @Override public void onSuccess(String token) &#123; AILog.d(TAG, &quot;initAutoRefresh:&quot; + finalI1 + &quot; onSuccess() called with: token = [&quot; + token + &quot;]&quot;); &#125; @Override public void doLogOut(int code) &#123; AILog.d(TAG, &quot;initAutoRefresh&quot; + finalI1 + &quot; doLogOut() called with: code = [&quot; + code + &quot;]&quot;); &#125; @Override public void onError(int code) &#123; AILog.d(TAG, &quot;initAutoRefresh&quot; + finalI1 + &quot; onError() called with: code = [&quot; + code + &quot;]&quot;); &#125; &#125;); &#125; &#125; &#125; &#125; /** * 检查token是否过期 true 过期 false 不过期 * * @return */ private boolean checkIsTokenExpired() &#123; boolean flag = true; //25分钟刷新token if (System.currentTimeMillis() - lastRefreshTime &lt; TOKEN_EXPIRED_TIME) &#123; flag = false; &#125; return flag; &#125; /** * 直接获取或刷新token * * @param listener */ private void getOrRefreshToken(@NotNull RefreshTokenListener listener) &#123; /** * 超时定时器 */ final Timer[] timeOutTimer = &#123;new Timer()&#125;; if (checkIsTokenExpired()) &#123; if (mContext != null) &#123; MobileAccount.getInst().refreshToken(mContext, new MobileAccount.RefreshCallback() &#123; @Override public void onSuccess(int code, String refreshedToken) &#123; lastToken = refreshedToken; if (listener != null) &#123; listener.onSuccess(refreshedToken); &#125; lastRefreshTime = System.currentTimeMillis(); cancaleRequestTimer(timeOutTimer); synchronized (mLock) &#123; mLock.notify(); &#125; &#125; @Override public void onFailed(int code) &#123; if (listener != null) &#123; listener.doLogOut(code); &#125; cancaleRequestTimer(timeOutTimer); lastRefreshTime = 0; synchronized (mLock) &#123; mLock.notify(); &#125; &#125; @Override public void onNetError(int errorCode) &#123; if (listener != null) &#123; listener.onError(errorCode); &#125; cancaleRequestTimer(timeOutTimer); lastRefreshTime = 0; synchronized (mLock) &#123; mLock.notify(); &#125; &#125; &#125;); try &#123; // 超时防止 TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; if (listener != null) &#123; listener.onError(-9); &#125; synchronized (mLock) &#123; mLock.notify(); &#125; //TODO listener &#125; &#125;; timeOutTimer[0].schedule(timerTask, REFRESH_EXPIRED_TIME); synchronized (mLock) &#123; mLock.wait(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; else &#123; //直接获得 listener.onSuccess(lastToken); &#125; &#125; /** * 带有重试的直接获取或刷新token * * @param listener */ private void getOrRefreshTokenWithRetry(int retryCount, @NotNull RefreshTokenListener listener) &#123; AILog.d(TAG, &quot;getOrRefreshTokenWithRetry() called with: retryCount = [&quot; + retryCount + &quot;], listener = [&quot; + listener + &quot;]&quot;); /** * 超时定时器 */ final Timer[] timeOutTimer = &#123;new Timer()&#125;; if (checkIsTokenExpired()) &#123; if (mContext != null) &#123; MobileAccount.getInst().refreshToken(mContext, new MobileAccount.RefreshCallback() &#123; @Override public void onSuccess(int code, String refreshedToken) &#123; lastToken = refreshedToken; if (listener != null) &#123; listener.onSuccess(refreshedToken); &#125; lastRefreshTime = System.currentTimeMillis(); cancaleRequestTimer(timeOutTimer); synchronized (mLock) &#123; mLock.notify(); &#125; &#125; @Override public void onFailed(int code) &#123; if (listener != null) &#123; listener.doLogOut(code); &#125; cancaleRequestTimer(timeOutTimer); lastRefreshTime = 0; synchronized (mLock) &#123; mLock.notify(); &#125; &#125; @Override public void onNetError(int errorCode) &#123; cancaleRequestTimer(timeOutTimer); lastRefreshTime = 0; if (retryCount &gt; 0) &#123; //递归重试 getOrRefreshTokenWithRetry(retryCount - 1, listener); &#125; else &#123; if (listener != null) &#123; listener.onError(errorCode); &#125; synchronized (mLock) &#123; mLock.notify(); &#125; &#125; &#125; &#125;); try &#123; // 超时防止 TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; if (listener != null) &#123; listener.onError(-9); &#125; synchronized (mLock) &#123; mLock.notify(); &#125; //TODO listener &#125; &#125;; timeOutTimer[0].schedule(timerTask, REFRESH_EXPIRED_TIME); synchronized (mLock) &#123; mLock.wait(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;[为macOS开启局域网ss](media/%E4%B8%BAmacOS%E5%BC%80%E5%90%AF%E5%B1%80%E5%9F%9F%E7%BD%91ss.md) &#125; else &#123; //直接获得 listener.onSuccess(lastToken); &#125; &#125; /** * 强制刷新token * * @param listener */ private void getRefreshToken(@NotNull RefreshTokenListener listener) &#123; /** * 超时定时器 */ final Timer[] timeOutTimer = &#123;new Timer()&#125;; if (mContext != null) &#123; MobileAccount.getInst().refreshToken(mContext, new MobileAccount.RefreshCallback() &#123; @Override public void onSuccess(int code, String refreshedToken) &#123; lastToken = refreshedToken; if (listener != null) &#123; listener.onSuccess(refreshedToken); &#125; cancaleRequestTimer(timeOutTimer); lastRefreshTime = System.currentTimeMillis(); synchronized (mLock) &#123; mLock.notify(); &#125; &#125; @Override public void onFailed(int code) &#123; if (listener != null) &#123; listener.doLogOut(code); &#125; cancaleRequestTimer(timeOutTimer); lastRefreshTime = 0; synchronized (mLock) &#123; mLock.notify(); &#125; &#125; @Override public void onNetError(int errorCode) &#123; if (listener != null) &#123; listener.onError(errorCode); &#125; cancaleRequestTimer(timeOutTimer); lastRefreshTime = 0; synchronized (mLock) &#123; mLock.notify(); &#125; &#125; &#125;); try &#123; // 超时防止 TimerTask timerTask = new TimerTask() &#123; @Override public void run() &#123; if (listener != null) &#123; listener.onError(-9); &#125; synchronized (mLock) &#123; mLock.notify(); &#125; //TODO listener &#125; &#125;; timeOutTimer[0].schedule(timerTask, REFRESH_EXPIRED_TIME); synchronized (mLock) &#123; mLock.wait(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 取消超时定时器 * * @param timeOutTimer */ private void cancaleRequestTimer(Timer[] timeOutTimer) &#123; AILog.d(TAG, &quot;cancaleRequestTimer() called with: timeOutTimer = [&quot; + timeOutTimer + &quot;]&quot;); if (timeOutTimer[0] != null) &#123; timeOutTimer[0].cancel(); timeOutTimer[0] = null; &#125; &#125; public interface RefreshTokenListener &#123; /** * 刷新token成功返回 * * @param token */ void onSuccess(String token); /** * 需要做登出操作 * * @param code */ void doLogOut(int code); /** * 失败 * * @param code 错误码 */ void onError(int code); &#125; /** * 内部定时器检查 */ private class TokenHeartTimer extends TimerCheck &#123; @Override public void doTimerCheckWork() &#123; AILog.d(TAG, &quot;TokenHeartTimer doTimerCheckWork() called&quot;); Account account = UserExt.getAccount(); if (account != null &amp;&amp; mContext != null) &#123; if (!TextUtils.isEmpty(account.getUid(mContext))) &#123; //满足登录条件后判断是否应该刷新 getToken(new RefreshTokenListener() &#123; @Override public void onSuccess(String token) &#123; AILog.d(TAG, &quot;auto RefreshToken onSuccess: &quot;); userUpload(token); &#125; @Override public void doLogOut(int code) &#123; AILog.e(TAG, &quot;auto RefreshToken doLogOut() called with: code = [&quot; + code + &quot;]&quot;); &#125; @Override public void onError(int code) &#123; AILog.e(TAG, &quot;auto RefreshToken onError() called with: code = [&quot; + code + &quot;]&quot;); &#125; &#125;); &#125; &#125; &#125; @Override public void doTimeOutWork() &#123; &#125; &#125; private void userUpload(String token) &#123; AILog.d(TAG, &quot;userUpload --- &quot;); JSONObject jsonObject = new JSONObject(); try &#123; String uid = &quot;&quot;; String phoneNumber = &quot;&quot;; Account account = UserExt.getAccount(); if (account != null) &#123; uid = account.getUid(mContext); phoneNumber = account.getPhoneNumber(mContext); &#125; if (!TextUtils.isEmpty(uid)) &#123; jsonObject.put(&quot;userid&quot;, uid); &#125; else &#123; jsonObject.put(&quot;userid&quot;, &quot;&quot;); &#125; if (!TextUtils.isEmpty(phoneNumber)) &#123; jsonObject.put(&quot;phone&quot;, phoneNumber); &#125; else &#123; jsonObject.put(&quot;phone&quot;, &quot;&quot;); &#125; jsonObject.put(&quot;token&quot;, token); &#125; catch (JSONException e) &#123; AILog.e(TAG, e.getMessage(), e); &#125; ClientInfoModel.getInstance().uploadUserInfo(jsonObject); &#125;&#125; 更新说明: 版本 时间 说明 version 0.0.1 2019年03月20日11:29:20 初版]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为macOS开启局域网ss]]></title>
    <url>%2F2019%2F01%2F15%2F%E4%B8%BAmacOS%E5%BC%80%E5%90%AF%E5%B1%80%E5%9F%9F%E7%BD%91ss%2F</url>
    <content type="text"><![CDATA[version 0.0.1 1. 通过 brew 安装 privoxybrew install privoxy 安装后查看安装目录 brew privoxy list 打开目录并编辑config文件 open /usr/local/etc/privoxy/config 2. 添加需要映射的端口本地ss端口forward-socks5t / 127.0.0.1:1086 .(注意要有默认的点) 转发的端口 listen-address 0.0.0.0:6666 3. 运行privoxysudo /usr/local/Cellar/privoxy/3.0.26/sbin/privoxy /usr/local/etc/privoxy/config 4. 添加开机启动将变量添加到 .bash_profile 中: export PATH=$PATH:/usr/local/Cellar/privoxy/3.0.26/sbin/ 新建一个文本文档, 将如下添加后, 修改后缀名为.sh # 添加开机启动:ln -sfv /usr/local/opt/privoxy/*.plist ~/Library/LaunchAgents# 开启 Privoxy:launchctl load ~/Library/LaunchAgents/homebrew.mxcl.privoxy.plist# 如果不需要用 launchctl 就直接运行:privoxy /usr/local/etc/privoxy/config 在终端运行 : eg: sh test.sh 5. 查看是否已经开启netstat -na | grep 6666 如上, 已经成功监听 6. 更新说明: 版本 时间 说明 version 0.0.1 2019年01月15日16:10:55 初版]]></content>
      <tags>
        <tag>Geek</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git日常(二)----常用git 命令]]></title>
    <url>%2F2018%2F11%2F01%2Fgit%E6%97%A5%E5%B8%B8-%E4%BA%8C-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[version 0.0.2 1. 日志类 显示每次更新的文件修改统计信息 git log --stat 显示最近两次提交 git log -p -2 根据自定义格式过滤日志 git log --pretty=format:&quot;%h - %an, %ar : %s&quot; 使用ASCII表示简单git图 git log --pretty=format:&quot;%h %s&quot; --graph 显示最近一周的提交 git log --since=1.weeks 显示指定作者的提交 git log --author=xuxin 显示指定区间段的提交 git log --author=xuxin --since=&quot;2018-04-01&quot; --before=&quot;2018-10-01&quot; 显示提交但未合并的信息 git log --pretty=&quot;%h - %s&quot; --author=xuxin --since=&quot;2018-04-01&quot; \ --before=&quot;2018-10-08&quot; --no-merges -- t/ 2. 检索类 根据commit信息搜索提交 git log -g --grep=&quot;KEYWORD&quot;git log --all --grep=&#39;KEYWORD&#39; 查找有关的关键字 git log --all --pretty=\&quot;format:%Cgreen%H %Cblue%s\n%b%Creset\&quot; --name-status --grep KEYWORD 根据CommitID查看所属分支 git branch -a --contains CommitID 3. 操作类 (未使用add)放弃本地所有更改 git checkout . 撤销特定文件 (注意-- ) git checkout -- filepathname (已经使用add)放弃本地所有更改 git reset --hard HEAD^ 回退到任意版本 git reset --hard CommitID 修改错误的提交 git commit --amend 查看某人提交的代码 git log --author=&quot;xuxin&quot; --pretty=tformat: --numstat | awk &#39;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc }&#39; - 统计每个人提交的代码 git log --format=&#39;%aN&#39; | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#39;{ add += $1; subs += $2; loc += $1 - $2 } END { printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc }&#39; -; done 查看提交者 前五名 git log --pretty=&#39;%aN&#39; | sort | uniq -c | sort -k1 -n -r | head -n 5 4. 注: 添加到全局变量中的代码(注意author修改) git config --global alias.lm &quot;log --no-merges --color --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;xuxin&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; git config --global alias.lms &quot;log --no-merges --color --stat --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;xuxin&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; git config --global alias.ls &quot;log --no-merges --color --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; git config --global alias.lss &quot;log --no-merges --color --stat --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; git config --global alias.find &quot;log --all --pretty=\&quot;format:%Cred%cd\n%Cgreen%H %Cblue%s\n%b%Creset\&quot; --name-status --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --grep&quot; gitconfig中代码: [alias] lm = log --no-merges --color --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;xuxin&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit find = log --all --pretty=\&quot;format:%Cred%cd\n%Cgreen%H %Cblue%s\n%b%Creset\&quot; --name-status --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --grep lss = log --no-merges --color --stat --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit lms = log --no-merges --color --stat --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --author=&#39;xuxin&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit ls = log --no-merges --color --graph --date=format:&#39;%Y-%m-%d %H:%M:%S&#39; --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit 4.2 参考: git 查看提交历史 git log命令全解析 git 放弃本地修改 git代码行统计命令集 4.3 更新说明: 版本 时间 说明 version 0.0.1 2018年10月09日15:45:06 初版 version 0.0.2 2018年10月24日15:51:51 添加代码统计命令]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Geek</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git日常(一)----基础篇]]></title>
    <url>%2F2018%2F09%2F30%2Fgit%E6%97%A5%E5%B8%B8-%E4%B8%80-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[git 多用户配置流程## 1. 生成自定义密钥文件 进入目录cd ~/.ssh/ 或 cd /Users/arno/.ssh 或 cd .ssh 根据用户邮箱生成不同的key文件ssh-keygen -t rsa -C &quot;davidxuxin@qq.com&quot;ssh-keygen -t rsa -C &quot;xin.xu@carrbot.com&quot; key分别设置别名 如: github_id_rsa,ileja_id_rsa 2. 将生成的key填入到相应 github 或 gitlab 的SSH密钥中cat github_id_rsacat ileja_id_rsa 3. 在.ssh目录下创建config 文件vim config 填写相关配置123456789101112131415#githubHost github.comHostname ssh.github.comUser daivdxuxin@qq.comPreferredAuthentications publickeyPort 443IdentityFile ~/.ssh/github_id_rsa# 该文件用于配置私钥对应的服务器# 配置公司账户(xin.xu@carrobot.com)Host git@code.cheluobo.cnHostName http://github.comUser xin.xu@carrbot.comPort 5837IdentityFile ~/.ssh/ileja_id_rsa 4. 在agent中添加自定义的key后台启动ssh-agenteval &quot;$(ssh-agent -s)&quot; 将自定义的key添加到agent中ssh-add ~/.ssh/github_id_rsassh-add ~/.ssh/ileja_id_rsa 5. 测试连接ssh -T git@github.com 或 ssh -vT git@github.com git clone -b branch_meebot_1.5.0 git@42.159.143.73:guilbert/carrobot_lite_android.git 6. 常见问题解答 Github-常见SSH密钥问题 Github-查看SSH密钥 Github-添加SSH 到ssh-agent Github-SSH故障排除]]></content>
      <tags>
        <tag>Geek</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用日志过滤手册]]></title>
    <url>%2F2018%2F05%2F11%2F%E5%B8%B8%E7%94%A8%E6%97%A5%E5%BF%97%E8%BF%87%E6%BB%A4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[常用日志过滤手册 v0.1命令格式: [adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 1. 显示日志adb logcat 2. 过滤优先级 标签 说明 (级别低-&gt;高) V Verbos(级别最低) D Debug I Info W Warning E Error F Fatal S Silent(级别最高) 按照某级别过滤日志: adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 3. 配合正则筛选日志adb logcat -v threadtime |grep --color = auto -iE &quot;XXX|YYY&quot; 会将匹配 XXX和 YYY忽略大小写的匹配日志输出 4. 正则筛选日志文件(txt文件)grep --color=auto -iE &quot;XXX|YYY&quot; e:\desktop\1.txt 会将 1.txt 匹配 XXX和 YYY忽略大小写的匹配日志输出 5. 根据正则关键字查看某一文件并输出到新的文件中grep -rni &quot;OfflineChild&quot; 原始文件目录及名字 |tee 新文件目录及名字]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>adb</tag>
        <tag>logcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS快速部署手册]]></title>
    <url>%2F2018%2F01%2F12%2FVPSSetting%2F</url>
    <content type="text"><![CDATA[VPS快速部署手册 version 0.1基础配置2018年1月10日17:40:33 version 0.2添加了本地化,以及部分说明2018年1月12日14:51:29 注:本手册每个模块互相独立,按需参考即可 1. 部署SSR 1.1 安装依赖软件 环境 Ubuntu 16.04.3 LTS 更新软件源 apt-get update 安装python pip apt-get install python-pip 升级pip pip install --upgrade pip 安装中文语言包 apt-get install language-pack-zh-hant 1.2 安装SSR 安装SSR pip install shadowsocks 配置ss json文件(参考1.3) vim /etc/shadowsocks.json 使用screen开启服务 screen -S ssr 开启ss服务 ssserver -c /etc/shadowsocks.json 返回 C -a-d 重新连接开启ssr服务的screen screen -r ssr 1.3 ssr配置文件 { &quot;server&quot;:&quot;服务器外网ip&quot;, //&quot;server&quot;:&quot;198.96.88.112&quot;, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;timeout&quot;:300, &quot;port_password&quot;:{ &quot;端口号&quot;:&quot;密码&quot;, //(&quot;8888&quot;,&quot;123456&quot;) &quot;端口号&quot;:&quot;密码&quot; //(&quot;&quot;8889&quot;,&quot;123457&quot;) }, &quot;method&quot;:&quot;rc4-md5&quot;, //加密规则 &quot;protocol&quot;: &quot;origin&quot;, //混淆插件 &quot;protocol_param&quot;: &quot;&quot;, &quot;obfs&quot;: &quot;plain&quot;, &quot;obfs_param&quot;: &quot;&quot;, &quot;workers&quot;: 1 } 2. NextCloud安装 2.1 基础软件安装 Apache 安装 sudo apt-get install apache2 MySQL 安装 sudo apt-get install mysql-server mysql-client PHP 安装 sudo apt-get install phpmyadmin 2.2 安装Nextcloud //下载文件 wget https://download.nextcloud.com/server/releases/nextcloud-12.0.4.tar.bz2 //解压文件bz2格式 tar -xjvf nextcloud-12.0.4.tar.bz2 //解压文件zip格式 unzip nextcloud-12.0.4.zip //将文件拷贝至服务器目录 cp -r nextcloud /var/www/html/ //修改nextcloud权限 2.3 启用额外插件 重新启动模块 sudo a2enmod rewrite sudo a2enmod headers zip模块 apt-get install php-zip curl模块 apt-get install php-curl 修改php.ini文件 vim /etc/php/7.0/apache2/php.ini 修改以下内容 ;extension=php_mbstring.dll ==&gt; extension=php_mbstring.dll 修改apache2.conf文件 vim /etc/apache2/apache2.conf 修改以下内容 &lt;Directory /var/www/&gt; Options Indexes FollowSymLinks AllowOverride None ==&gt; AllowOverride All Require all granted &lt;/Directory&gt; 重启Apache /etc/init.d/apache2 restart 2.4 配置文件位置 Apache2配置文件 vim /etc/apache2/apache2.conf php配置文件路径 vim /etc/php/7.0/apache2/php.ini apache2启动 /etc/init.d/apache2 start /etc/init.d/apache2 restart /etc/init.d/apache2 stop 移除文件 rm -rf /var/www/html/nextcloud/ 3.本地化Ubuntu3.1 安装中文支持及语言包安装中文语言包 apt-get install language-pack-zh-hant language-pack-zh-hans 配置相关环境变量： vim /etc/environment 在文件中增加语言和编码的设置： LANG=&quot;zh_CN.UTF-8&quot; LANGUAGE=&quot;zh_CN:zh:en_US:en&quot; 如: LANG=&quot;zh_CN.UTF-8&quot; LANGUAGE=&quot;zh_CN:zh:en_US:en&quot; PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games&quot; 重新设置本地配置： dpkg-reconfigure locales 3.2 更改时区选择时区 tzselect 复制文件到/etc目录下 sudo cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 如改为中国北京时间,直接输入以下(重新连接会消失) TZ=&apos;Asia/Beijing&apos;; export TZ 配置时间文件(重新连接不会消失) //选择Asia - Shanghai dpkg-reconfigure tzdata 重启VPS reboot]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Geek</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spicy]]></title>
    <url>%2F2017%2F12%2F22%2FSpicy%2F</url>
    <content type="text"><![CDATA[Spicy (Android端信息展示软件) 最近感觉自己实际编码经验太少，花了大概三周跟着慕课去学习完成这个demo练习，收获很多。除了组件化思想外，同时也练习了下mvp模式和许多开发中的小技巧，整体完成下来还是有很多收获。 功能概览多图加载,动态添加布局,视频播放，组件化开发，封装了通用sdk，并采用mvp重构。集成推送分享，生成扫描二维码，图表生成，评论，搜索登录,版本更新等功能。 大图浏览 二维码生成 未启动状态推送 视频播放 walle多渠道打包 2017-12-6 16:36:20 version0.0.1软件初步搭建2017-12-22 10:02:13 version 1.0 release 第一个正式发行版完成 项目地址:Spicy]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View绘制机制]]></title>
    <url>%2F2017%2F11%2F09%2FView%E7%BB%98%E5%88%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[View的绘制机制1. view树的绘制流程(当Activity接收到用户触摸焦点的时候, 会被请求去绘制布局;请求是由安卓Framework层去处理绘制,从根节点去对布局进行测量和绘制ViewRoot类中) measure -&gt; layout -&gt; draw measure: 是否重新计算视图大小; (递归)view 会对所有子元素进行测量, 测量过程从父的ViewGroup传递到子View里面, 经过子元素的递归, 测量好所有子元素的长度, 再进行递归, 反复之后就完成了ViewGroup的测量; layout: 是否需要重新安置视图位置; draw: 是否需要重绘; 2. measure2.1 ViewGroup.LayoutParams: 用来指定视图的高度和宽度 2.2 MeasureSpec(测量规格):32位int值 , 最高两位表示SpecMode是模式占位符, 后面30位表示测量规格的大小; 在一个空间measure过程中, 会将这个View的LayoutParams结合父容器生成一个MeasureSpec, MeasureSpec就会规定好怎样去测量这个View容器的大小, 返回给父容器, 父容器根据这个去测量大小 模式名称 模式数值 实际数值 UNSPECIFIED 00 000000000000000000001111011000 EXACTLY 01 000000000000000000001111011000 AT_MOST 10 000000000000000000001111011000 UNSPECIFIED: 不确定, 父控件不会对子控件有任何约束, 只要小于手机屏幕宽和高; EXACTLY: 父容器会对子视图确定一个大小, 无论子视图有多大, 都必须限定在父容器给定的范围内; AT_MOST : 父容器为所有子视图指定一个最大的尺寸, 子视图所有的大小都必须在这个范围内; 2.3 measure 重要的回调方法:measure(): 调用onMeasure();树遍历所有子结点; onMeasure(): 将所有测量的规格传递给setMeasuredDimension(); 12345 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;// setMeasuredDimension是用来通知测量结束的, 必须调用 setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; setMeasuredDimension(): 完成整个测测量过程; 123456789101112131415161718192021222324/** * &lt;p&gt;This method must be called by &#123;@link #onMeasure(int, int)&#125; to store the * measured width and measured height. Failing to do so will trigger an * exception at measurement time.&lt;/p&gt; * * @param measuredWidth The measured width of this view. May be a complex * bit mask as defined by &#123;@link #MEASURED_SIZE_MASK&#125; and * &#123;@link #MEASURED_STATE_TOO_SMALL&#125;. * @param measuredHeight The measured height of this view. May be a complex * bit mask as defined by &#123;@link #MEASURED_SIZE_MASK&#125; and * &#123;@link #MEASURED_STATE_TOO_SMALL&#125;. */ protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; &#125; setMeasuredDimensionRaw(measuredWidth, measuredHeight); &#125; 注: 如果父视图发现子视图传递的大小可能不对时候, 会再次请求子视图进行测量, 如果给定的数值超过了规定大小或者太小, 父视图会赋值给AT_MOST 或者 EXACTLY的形式,再次对子视图进行测量 3. layout会根据测量所得到的尺寸来确定layout摆放的位置, 子视图的具体位置是相对于父视图而言的, 必须实现onLayout(), 重新摆放; layout(): 调用onLayout(); onLayout(): 一定要实现;可以去分析LinearLayout中的实现; 123456789101112131415/** * Called from layout when this view should * assign a size and position to each of its children. * * Derived classes with children should override * this method and call layout on each of * their children. * @param changed This is a new size or position for this view * @param left Left position, relative to parent * @param top Top position, relative to parent * @param right Right position, relative to parent * @param bottom Bottom position, relative to parent */ protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; &#125; 是一个树形结构, 依次从ViewGroup进行位置摆放 4. draw两个比较容易混淆的回调方法: 4.1 invalidate(): 请求安卓系统;如果视图大小没有发生变化, 则不会调用layout放置过程; 4.2 requestLayout(): 当布局方向变化, 尺寸变化就回去调用;会触发measure, layout过程, 但不会调用draw方法]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广播]]></title>
    <url>%2F2017%2F11%2F09%2F%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[1. 广播1.1 广播定义(类似观察者模式)在Android中，Broadcast是一种广泛运用的在应用程序之间的传输信息的机制， Android中我们要发送的广播内容是一个Intent，这个Itent中可以携带我们要传送的数据。 1. 广播实现的不同程序间的数据传输与共享（只要和发送广播的Action相同的接收者都可以接收到） 2. 广播接收者通知作用（在程序中通过广播接收者来更新UI，避免了Service与Activity进行交互） 1.2 广播场景A. 同一App内具有多个进程的不同组件之间的消息通信B. 不同App间的组件之间消息通信(推广运营) 1.3 广播种类 Nromal Broadcast : Context.sendBroadcast(普通广播) System Broadcast: Context.sendOrderedBroadcast(有序广播\系统广播) Local Broadcast: 只在自身App内传播(本地广播) 2. 实现广播-receiver(接收Broadcast)1.静态注册: 注册完成就一直运行(Manifest文件中,Activity销毁仍能接收广播,缺点:不灵活) 动态注册,跟随Activity的生命周期(onDestroy中要销毁,跟随Activity) 区别: 动态在代码中调用 registerReceiver 静态在Manifest里写入 实现方式/区别 声明 生命周期 动态注册 registerReceiver 跟随Activity 静态注册 Manifest 被销毁了仍能运行接收 3. 广播实现机制3.1 自定义广播接收者BroadcastReceiver,并复写onReceive()方法;3.2. 通过Binder机制想*AMS(Activity Manager Service) 进行注册;3.3 广播发送这通过Binder机制向AMS发送广播;3.4 AMS查找符合相应条件(IntentFilter/Permission等) 的BroadcastReceiver, 将广播发送到BroadcastReceiver(一般情况下是Activity) 相应的消息循环队列中;3.5 消息循环执行拿到此广播, 回调BroadcastReceiver中的onReceive()方法; *AMS:AMS是作为管理Android系统组件的核心服务，他在SystemServer执行run()方法的时候被创建，并运行在独立的进程中。具体来说就是SystemServer管理着Android中所有的系统服务，这些系统服务的生命周期回调都由SystemServer去调度负责。 4. LoacalBroadcastManager详解4.1 使用它发送的广播将只在自身内传播, 不必担心泄露隐私数据;4.2 其他App无法对你的App发送该广播 因为你的App根本不可能收到其他非自身应用发送的广播, 避免了安全漏洞的利用;(防止其他人获取到action 并篡改, 如植入广告等) 4.3 比系统全局广播更高效;在LocalBroadcastReceiver中三个集合类: 4.3.1 mReceivers:是一个HashMap,key是receiver , value是intentfilter 1private final HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt; mReceivers 4.3.2 mActions:key是Action, value 是arrylist ,是对应的receiverRecord 1private final HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; mActions 4.3.3 mPendingBroadcasts:存储BroadcastRecord对象的(intent和receivers) 作用:存储和发送广播的action匹配的ReceiverRecord的集合,在执行时会遍历的集合里面广播接收器(存储了广播接收器的存储器) 12private final ArrayList&lt;BroadcastRecord&gt; mPendingBroadcasts = new ArrayList&lt;BroadcastRecord&gt;(); 4.3.4 注册方法:registerReceiver12345678910111213141516171819202122232425262728/** * Register a receive for any local broadcasts that match the given IntentFilter. * * @param receiver The BroadcastReceiver to handle the broadcast. * @param filter Selects the Intent broadcasts to be received. * * @see #unregisterReceiver */ public void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; synchronized (mReceivers) &#123; ReceiverRecord entry = new ReceiverRecord(filter, receiver); ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver); if (filters == null) &#123; filters = new ArrayList&lt;IntentFilter&gt;(1); mReceivers.put(receiver, filters); &#125; filters.add(filter); //添加过滤规则 for (int i=0; i&lt;filter.countActions(); i++) &#123; String action = filter.getAction(i); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action); if (entries == null) &#123; entries = new ArrayList&lt;ReceiverRecord&gt;(1); mActions.put(action, entries); &#125; entries.add(entry);//将里面的Filter分别建立了Arraylist映射,通过广播接收器来接收 &#125; &#125; &#125; 4.3.5 unregisterReceiver:1234567891011121314151617181920212223242526272829303132333435/** * Unregister a previously registered BroadcastReceiver. &lt;em&gt;All&lt;/em&gt; * filters that have been registered for this BroadcastReceiver will be * removed. * * @param receiver The BroadcastReceiver to unregister. * * @see #registerReceiver */ public void unregisterReceiver(BroadcastReceiver receiver) &#123; synchronized (mReceivers) &#123; ArrayList&lt;IntentFilter&gt; filters = mReceivers.remove(receiver); if (filters == null) &#123; return; &#125; for (int i=0; i&lt;filters.size(); i++) &#123; IntentFilter filter = filters.get(i); for (int j=0; j&lt;filter.countActions(); j++) &#123; String action = filter.getAction(j); ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action); if (receivers != null) &#123; for (int k=0; k&lt;receivers.size(); k++) &#123; if (receivers.get(k).receiver == receiver) &#123; receivers.remove(k);//将myreceiver中的广播接收器删除 k--; &#125; &#125; if (receivers.size() &lt;= 0) &#123; mActions.remove(action);//把mActions中集合类删除 &#125; &#125; &#125; &#125; &#125; &#125; 4.3.6 sendBroadcast:12345678910if (receivers != null) &#123; for (int i=0; i&lt;receivers.size(); i++) &#123; receivers.get(i).broadcasting = false; &#125; mPendingBroadcasts.add(new BroadcastRecord(intent, receivers));//过滤之后的广播记录 if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123;//判断是否有消息 mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); &#125; return true; &#125; 4.4 LocalBroadcastMananger 高效的原因4.4.1 内部通过HandlersendBroadcast()方法主要是它内部通过HandlersendBroadcast()方法含义并非平时所用,它的sendBroadcast()方法其实是通过handler发送一个Message实现的; 4.3.2 内部通过Handler来实现广播发送既然是它内部通过Handler来实现广播发送的,那么相比系统广播通过Binder实现肯定高效,同事用Handler来实现,别的应用无法像我们的应用发送该广播,而我们的应用内发送的广播也不会离开我们的应用; 4.3.3 LocalBroadcastMananger 内部协作主要是靠这两个集合:mReceivers和mActions, 还有一个List集合mPedingBroadcasts, 这个主要就是存储待接收的广播对象;]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Andorid基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HandlerThread]]></title>
    <url>%2F2017%2F11%2F08%2FHandlerThread%2F</url>
    <content type="text"><![CDATA[HandlerThread1.Handler是什么?1.1 handlerThread产生背景开启Thread子线程进行耗时操作 多次创建和销毁线程是很消耗系统资源的 (通过阻塞等待) handler + thread + looper 一个内部有looper的thread (普通handler如果创建在子线程, 由于handler消息处理需要一个messagequeen的looper, 但默认创建子线程时候没有looper就会发生异常报错;如果想在子线程中创建一个handler就必须手动初始化looper,调用looper.loop()方法开启循环) 1.2 handlerThread 的特点 HandlerThread 本质上是一个线程类, 它继承了Thread; HandlerThread 有自己的内部Looper对象, 可以进行looper循环; 通过获取HandlerThread的looper对象传递给Handler对象,可以在handleMessage()方法中执行异步任务; 有点是不会有阻塞, 减少了对性能的消耗; 缺点是不能同时进行多任务的处理, 需要等待进行处理, 处理效率较低; 与线程池注重并发不同, HandlerThread是一个串行队列, HandlerThread背后只有一个线程; 2. HandlerThread源码解析2.1 构造方法构造方法里可设置名称和优先级; 123456789101112131415public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT;&#125;/** * Constructs a HandlerThread. * @param name * @param priority The priority to run the thread at. The value supplied must be from * &#123;@link android.os.Process&#125; and not from java.lang.Thread. */public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority;//设置优先级&#125; 2.2 onLooperPrepared()空方法可以在需要的时候去复写它, 它执行在loop之前; 123456/** * Call back method that can be explicitly overridden if needed to execute some * setup before Looper loops. */ protected void onLooperPrepared() &#123; &#125; 2. 3 run()方法;synchronized: 当有两个并发线程访问同一个对象, 一个时间内只能有一个线程得到执行;而另一个线程也要执行, 就必须等待另一个线程也执行完;(这里通知的是getLooper()中的wait()) 12345678910111213@Override public void run() &#123; mTid = Process.myTid(); Looper.prepare();// 初始化looper synchronized (this) &#123;// 保证线程间数据安全 mLooper = Looper.myLooper(); notifyAll();// 通知当前等待的线程 &#125; Process.setThreadPriority(mPriority);// 给线程设定优先级(可以解决内存泄露*1) onLooperPrepared(); Looper.loop();// 开启循环 mTid = -1; &#125; 2.4 getLooper():在获取mylooper时候存在一个同步问题, 只有当上面线程创建成功, looper对象也创建成功时, 才会通知下面的;wait(); 12345678910111213141516171819202122/** * This method returns the Looper associated with this thread. If this thread not been started * or for any reason isAlive() returns false, this method will return null. If this thread * has been started, this method will block until the looper has been initialized. * @return The looper. */ public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; // 如果looper没创建成功则一直阻塞 try &#123; wait();// 被run()方法中的notifyAll()通知 &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; 2.5 quit():退出消息循环, 退出线程 123456789101112131415161718192021222324252627/** * Quits the handler thread&apos;s looper. * &lt;p&gt; * Causes the handler thread&apos;s looper to terminate without processing any * more messages in the message queue. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt;&lt;p class=&quot;note&quot;&gt; * Using this method may be unsafe because some messages may not be delivered * before the looper terminates. Consider using &#123;@link #quitSafely&#125; instead to ensure * that all pending work is completed in an orderly manner. * &lt;/p&gt; * * @return True if the looper looper has been asked to quit or false if the * thread had not yet started running. * * @see #quitSafely */ public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; 2.6 quitSafely():退出消息循环, 退出线程(效率上不是很高, 但更安全) 1234567891011121314151617181920212223242526/** * Quits the handler thread&apos;s looper safely. * &lt;p&gt; * Causes the handler thread&apos;s looper to terminate as soon as all remaining messages * in the message queue that are already due to be delivered have been handled. * Pending delayed messages with due times in the future will not be delivered. * &lt;/p&gt;&lt;p&gt; * Any attempt to post messages to the queue after the looper is asked to quit will fail. * For example, the &#123;@link Handler#sendMessage(Message)&#125; method will return false. * &lt;/p&gt;&lt;p&gt; * If the thread has not been started or has finished (that is if * &#123;@link #getLooper&#125; returns null), then false is returned. * Otherwise the looper is asked to quit and true is returned. * &lt;/p&gt; * * @return True if the looper looper has been asked to quit or false if the * thread had not yet started running. */ public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125;]]></content>
      <tags>
        <tag>Android</tag>
        <tag>异步消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntentService]]></title>
    <url>%2F2017%2F11%2F07%2FIntentService%2F</url>
    <content type="text"><![CDATA[IntentService1. IntentService是什么1.1 特殊的Service//继承了Service,可以执行高优先级的任务, 封装了HandlerThread和Handler 本质上是一种特殊的Service, 继承自Service并且本身就是一个抽象类 它的内部通过HandlerThread 和 Handler 实现异步操作 是继承并处理异步同步请求的一个类, 在IntentService内有一个工作线程来处理耗时操作, 启动IntentService的方式和启动传统的Service一样, 同时, 当任务执行完后, IntentService 会自动停止, 而不需要我们手动去控制stopSelf(), 另外, 可以启动IntentService多次, 而每一个耗时操作都会以工作队列的方式在IntentService的onHandlerIntent回调方法中执行, 并且 , 每次只会执行一个工作线程, 执行完第一个再执行第二个;(串行) 2. IntentService使用方法2.1 必须实现两个方法(创建IntentService时, 只需要实现onHandleIntent和构造方法, onHandleIntent为异步方法, 可以执行耗时操作) 写一个类继承IntentService 构造方法: 传入线程名称1234public IntentService(String name) &#123; super(); mName = name;&#125; onHandleIntent(): 进行Itent的耗时操作 后intent里携带信息, 并startService(intent),最后MyIntentService.setUpdate(this); 12@WorkerThreadprotected abstract void onHandleIntent(@Nullable Intent intent) 3. IntentService源码解析3.1 onCreate()123456789101112131415@Override public void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;);// 创建了HandlerThread来进行异步消息传递 thread.start(); mServiceLooper = thread.getLooper();// 传递的是HandlerThread的loop对象;// (由于looper 对象和 HandlerThread绑定,而HandlerThread又是一个异步线程,把HandlerThread 持有的 looper 传递给 ServiceHandler这样ServiceHandler就变成了处理异步线程的执行类) mServiceHandler = new ServiceHandler(mServiceLooper);// 一个继承了Handler的Handler &#125; intentService启动后还会调用onStartCommand(); 3.2 onStartCommand():1234567891011/** * You should not override this method for your IntentService. Instead, * override &#123;@link #onHandleIntent&#125;, which the system calls when the IntentService * receives a start request. * @see android.app.Service#onStartCommand */ @Override public int onStartCommand(@Nullable Intent intent, int flags, int startId) &#123; onStart(intent, startId);//实际操作都在onStart return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; &#125; 3.4 onStart():1234567@Override public void onStart(@Nullable Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); &#125; 3.5 ServiceHandler类:1234567891011private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1);// 如果没有参数会立即停止, 如果有参数会等待所有消息都处理完之后才会终止任务 &#125; &#125; onHandleIntent: 是一个抽象方法, 在创建IntentService时一定要实现该方法(异步方法)如果执行完会立刻销毁, 当有多个服务时会明确到执行完最后一个服务才会销毁;stopSelf加参数; (Service里不能做耗时操作, 而IntentService可以执行耗时操作) 123456789101112131415161718/** * This method is invoked on the worker thread with a request to process. * Only one Intent is processed at a time, but the processing happens on a * worker thread that runs independently from other application logic. * So, if this code takes a long time, it will hold up other requests to * the same IntentService, but it will not hold up anything else. * When all requests have been handled, the IntentService stops itself, * so you should not call &#123;@link #stopSelf&#125;. * * @param intent The value passed to &#123;@link * android.content.Context#startService(Intent)&#125;. * This may be null if the service is being restarted after * its process has gone away; see * &#123;@link android.app.Service#onStartCommand&#125; * for details. */ @WorkerThread protected abstract void onHandleIntent(@Nullable Intent intent); 本质上就是一个封装了HandlerThread 和 handler的异步框架 每次去实现时一定实现onHandleIntent()在里面进行耗时操作, 会按照顺序执行]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>异步消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask]]></title>
    <url>%2F2017%2F11%2F07%2FAsyncTask%2F</url>
    <content type="text"><![CDATA[AsyncTask1. 什么是 AsyncTask1.1 AsyncTask 是安卓提供的轻量异步类(抽象), 可以继承AsyncTask,在类中可以进行异步操作, 并提供接口反馈当前异步执行的程度或进度。 本质上就是一个封装了线程池和handler的异步框架,主要用来执行异步任务,由于集成了handler,通过handler发送消息,它很方便的在工作线程和UI线程之间切换(最好做耗时比较短的,长的还是用线程池) 2. AsyncTask的使用方法2.1 三个参数 public abstract class AsyncTask&lt;Params, Progress, Result&gt; { private static final String LOG_TAG = “AsyncTask”; private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); // We want at least 2 threads and at most 4 threads in the core pool, // preferring to have 1 less than the CPU count to avoid saturating // the CPU with background work private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4)); private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; private static final int KEEP_ALIVE_SECONDS = 30; private static final ThreadFactory sThreadFactory = new ThreadFactory() { private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) { return new Thread(r, “AsyncTask #” + mCount.getAndIncrement()); } };Params:执行时传入的参数;Progress:在后台执行时的进度;Result:当任务执行完毕后的结果返回; 2.2 五个方法 耗时操作没进行前,在UI线程汇中调用onPreExecute(); @MainThread protected void onPreExecute() { } 在后台执行时调用doInBackground();计算结果必须有一个返回,并会被传到onPost()中;也可以调用publishProgress();返回进度显示 @WorkerThread protected abstract Result doInBackground(Params… params);在每次onProgressUpdate()调用完后会执行onProgressUpdate();通过progressbar.setProgress(value)动态显示进度条; @MainThread protected void onProgressUpdate(Progress... values) { } 最后所有doInBackground之后会通过result来传递给onPostExecute()并调用; @MainThread protected void onPostExecute(Result result) { } 3. AsyncTask内部原理3.1 AsyncTask的本质是一个静态的线程池,AsyncTask派生出的子类可以实现不同的异步任务, 这些任务都是提交到静态的线程池中执行; 3.2 线程池中的工作线程执行doInBackground(mParans)方法执行异步任务; 3.3 当任务状态改变之后,工作线程会向UI线程发送消息,AsyncTask内部的InternalHandler响应这些消息, 并调用相关的回调函数; 4. AsyncTask注意事项4.1 内存泄露 被声明为Activity的非静态的内部类,会持有外部类的引用; 设为静态 static;或者持有弱引用;或在外部onDestroy里用cancle; 4.2 生命周期必须在activity生命周期销毁时销毁AsyncTask 4.3 结果丢失原因 如被杀掉,或者屏幕旋转时onPostExcute不会更新界面 4.4 并行OR串行 版本 执行方式 &lt;= 1.6 串行 &gt;= 1.6 &amp;&amp; &lt; 2.3 并行 &gt;= 2.3 串行]]></content>
      <tags>
        <tag>Android</tag>
        <tag>异步消息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio 工程jar包重复引入报错]]></title>
    <url>%2F2017%2F10%2F27%2FAndroidStudio%20%E5%B7%A5%E7%A8%8Bjar%E5%8C%85%E9%87%8D%E5%A4%8D%E5%BC%95%E5%85%A5%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[app:transformClassesWithJarMergingForDebug 工程中，如果我们叫A，要引用的两个三方库分别叫B和C。 其中B包含了若干小jar包，比如其中有一个叫d，C中也包含了同样的jar包d。 那么我们直接应用这两个库的时候，编译过程会报错 1Execution failed for task &apos;:app:transformClassesWithJarMergingForDebug&apos;. 那么我们只需要在其中库中「去掉」jar包的引用，或者说过滤掉。 可以切换到「Project」视图， 查看比较两者间有什么库是一样的名字。这里我举了个例子： 在MANIFEST.MF文件中,找到要过滤的包名: io.reactivex.java 在gradle文件中，引用工程后面添加过滤的包名。这里我将rx有关的都过滤了，（使用的是AS3.0有了新的关键字implementation具体看这里） 123456compile(&apos;cn.bmob.android:bmob-sdk:3.5.5&apos;) &#123; exclude group: &apos;io.reactivex&apos;&#125;compile(&apos;com.kymjs.rxvolley:rxvolley:1.1.4&apos;) &#123; exclude group: &apos;io.reactivex&apos;&#125; 重新编译一下，就可以正常运行了。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>三方集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度地图集成的小问题]]></title>
    <url>%2F2017%2F10%2F27%2F%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BE%E9%9B%86%E6%88%90%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[模拟器运行时候JS不加载或白屏 之前用百度地图的时候都是直接Copy过来其他项目的地方，因为好业务逻辑相同，也简单了不少。但是偶然在运行中发现了这样一个问题。我用的是SDK 25（7.1）的模拟器，在我点击跳转到页面的时候显示了空白，同时我的日志输出了这样一段： 1chromium: [ERROR:interface_registry.cc(104)] Failed to locate a binder for interface: autofill::mojom::PasswordManagerDriver 上网查阅资料里好多人说的是权限没获取到，又或是服务器资源不好。但这个页面短暂空白后，又出现了地图列表，看起来似乎是JS没有加载。可是我的代码里已经有了这些东西： 1234webView.getSettings().setJavaScriptEnabled(true);webView.getSettings().setJavaScriptCanOpenWindowsAutomatically(true);webView.getSettings().setDomStorageEnabled(true);webView.getSettings().setLoadsImagesAutomatically(true); 这个时候还是Stack Overflow上能看出些门道， 同时我注意到还有另外一条信息： 1Unrecognized GLES max version string in extensions: ANDROID_EMU_CHECKSUM_HELPER_v1 ANDROID_EMU_dma_v1 由于是使用虚拟机，我意识到可能还有显示渲染的不兼容。 然后我试着找了一个x86版本的虚拟机安装上去，画面又显示回来了。 目前在Stack Overflow上没有找到什么能解决的办法。 无法在AndroidManifest.xml中获取com.baidu.android.lbs.API_KEY的值 按照文档上的说明，我在AndroidManifest文件中配置meta-data应该是可以的，但是读取不到，后来发现原来key 不应该是api_key而是com.baidu.lbsapi.API_KEY，这个问题还是要细心注意一下。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>三方集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView和RecyclerView中item中宽度不占满的一种可能]]></title>
    <url>%2F2017%2F10%2F25%2FListView%E5%92%8CRecyclerView%E4%B8%ADitem%E4%B8%AD%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%8D%A0%E6%BB%A1%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%83%BD%2F</url>
    <content type="text"><![CDATA[ListView和RecyclerView中item中宽度不占满的一种可能公司里有个项目，用到一个简单的ListView，我在item里写了match_parent属性，但是在运行中却并没有占满一整行，就导致了布局有问题。 在使用ListView的Adapter中,我们在getView方法里是这样的写的： public View getView(int position, View convertView, ViewGroup parent) { if (convertView == null) { convertView = inflate(R.layout.item_lv_test, null); } return convertView; } 其中的第二个参数是放parent，通常情况下之前一直在用null，但是这次却行不通了。问题在其实还真就在于这个null上。 点进去去看了下源码，发现inflate里还有一个方法。 查阅资料，发现了我代码的问题。 1.如果设置为null：根布局设置的高度是不起作用的，即使根布局是一个控件，比如： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:text=&quot;abc&quot; /&gt; 这时200dp不起作用，而是根据里面的文字大小来决定item的高度,比如如下起作用: &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:text=&quot;abc&quot; android:textSize=&quot;200dp&quot; /&gt; 根布局是一个layout的情况下，根布局的高度也不起作用，而是里面子控件的高度起作用，比如下面item的高度是100dp： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:text=&quot;abc&quot;/&gt; &lt;/RelativeLayout&gt; 如果里面的内容设置为match_parent,效果跟第一个一样，根据文字大小来决定item高度，因为parent设置的高度没用，所以里面子空间match_parent也没用： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;abc&quot;/&gt; &lt;/RelativeLayout&gt; 对传null总结：设置为null时，因为没有父亲，根布局的layout_height没有作用，子布局的layout_height为绝对值时有用，为相对值（match_parent,wrap_content）时没用，里面内容的高度决定了item的高度（根部局为普通空间时，控件内容决定item高度，根布局为layout时，子控件设置的绝对高度或子控件的内容决定item高度） 2.如果传入三个参数如果parent设置为getview传入的parent（第三个参数false），则根布局设置的高度就有用了： 比如上面第一个就是200dp了 如果这时候，根部局设置为match_parent，则根据里面内容来适配，比如以下item高度跟上面第一个一样，为文字的高度： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;abc&quot;/&gt; &lt;/RelativeLayout&gt; 以下高度变成了200dp: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot; android:text=&quot;abc&quot;/&gt; &lt;/RelativeLayout&gt; 同样这个在RecyclerView中也是，总结起来是自己当初用的时候太过着急没仔细看看这个方法是什么用的。以此来记录这次小坑。]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows中的一些快捷键]]></title>
    <url>%2F2017%2F10%2F25%2FWindows%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Winodws快捷键根据Microsoft官网:2017年10月18日 - 修订版本： 8(这篇文章中的信息适用于:Windows 10, Windows 8.1, Windows 7) 复制、粘贴及其他常规的键盘快捷方式 快捷键 作用 Ctrl + X 剪切选定项 Ctrl + C（或 Ctrl + Insert） 复制选定项 Ctrl + V（或 Shift + Insert） 粘贴选定项 Ctrl + Z 撤消操作 Alt + Tab 在打开的应用之间切换 Alt + F4 关闭活动项，或者退出活动应用 Windows 徽标键 + L 锁定你的电脑 Windows 徽标键 + D 显示和隐藏桌面 F2 重命名选定项 F3 在文件资源管理器中搜索文件或文件夹 F4 在文件资源管理器中显示地址栏列表 F5 刷新活动窗口 F6 循环浏览窗口中或桌面上的屏幕元素 F10 激活活动应用中的菜单栏 Alt + F8 在登录屏幕上显示你的密码 Alt + Esc 按项目打开顺序循环浏览 Alt + 带下划线的字母 执行该字母相关的命令 Alt + Enter 显示所选项目的属性 Alt + 空格键 打开活动窗口的快捷方式菜单 Alt + 向左键 返回 Alt + 向右键 前进 Alt + Page Up 向上移动一个屏幕 Alt + Page Down 向下移动一个屏幕 Ctrl + F4 关闭活动文档（在可全屏显示并允许你同时打开多个文档的应用中） Ctrl + A 选择文档或窗口中的所有项目 Ctrl + D（或 Delete） 删除所选的项目，将其移至回收站 Ctrl + R（或 F5） 刷新活动窗口 Ctrl + Y 恢复操作 Ctrl + 向右键 将光标移动到下一个字词的起始处 Ctrl + 向左键 将光标移动到上一个字词的起始处 Ctrl + 向下键 将光标移动到下一段落的起始处 Ctrl + 向上键 将光标移动到上一段落的起始处 Ctrl + Alt + Tab 使用箭头键在所有打开的应用之间进行切换 Ctrl + Alt + Shift + 箭头键 当组或磁贴的焦点放在“开始”菜单上时，可将其朝指定方向移动 Ctrl + 箭头键（移至某个项目）+ 空格键 选择窗口中或桌面上的多个单独项目 Ctrl + Shift（及箭头键） 选择文本块 Ctrl + Esc 打开“开始”屏幕 Ctrl + Shift + Esc 打开任务管理器 Ctrl + Shift 如果多种键盘布局可用，则可切换键盘布局 Ctrl + 空格键 打开或关闭的中文输入法编辑器 (IME) Shift + F10 显示所选项目的快捷方式菜单 按 Shift 与任何箭头键 在窗口中或桌面上选择多个项目，或在文档中选择文本 Shift + Delete 删除选定项，无需先移动到回收站 向右键 打开右侧的下一个菜单，或打开子菜单 向左键 打开左侧的下一个菜单，或关闭子菜单 Esc 停止或离开当前任务 Windows 徽标键键盘快捷方式 快捷键 作用 Windows 徽标键 打开或关闭“开始”屏幕 Windows 徽标键 + A 打开操作中心 Windows 徽标键 + B 将焦点放在通知区域上 Windows 徽标键 + C 在侦听模式下打开 Cortana Windows 徽标键 + Shift + C 打开超级按钮菜单 Windows 徽标键 + D 显示和隐藏桌面 Windows 徽标键 + Alt + D 显示和隐藏桌面上的日期和时间 Windows 徽标键 + E 打开文件资源管理器 Windows 徽标键 + F 打开反馈中心并获取屏幕截图 Windows 徽标键 + G 打开游戏栏（当游戏处于打开状态时） Windows 徽标键 + H 开始听写 Windows 徽标键 + I 打开“设置” Windows 徽标键 + J 请将焦点设置到可用的 Windows 提示。 Windows 徽标键 + K 打开“连接”快速操作 Windows 徽标键 + L 锁定你的电脑或切换帐户 Windows 徽标键 + M 最小化所有窗口 Windows 徽标键 + O 锁定设备方向 Windows 徽标键 + P 选择演示显示模式 Windows 徽标键 + R 打开“运行”对话框 Windows 徽标键 + S 打开“搜索” Windows 徽标键 + T 循环浏览任务栏上的应用 Windows 徽标键 + U 打开“轻松使用设置中心” Windows 徽标键 + V 循环浏览通知 Windows 徽标键 + Shift + V 以相反顺序循环浏览通知 Windows 徽标键 + X 打开“快速链接”菜单 Windows 徽标键 + Y 在 Windows Mixed Reality 与桌面之间切换输入 Windows 徽标键 + Z 以全屏模式显示应用中可用的命令 Windows 徽标键 + 句点 (.) 或分号 (;) 打开表情符号面板 Windows 徽标键 + 逗号 (,) 临时速览桌面 Windows 徽标键 + Pause 键 显示“系统属性”对话框 Windows 徽标键 + Ctrl + F 搜索电脑（如果已连接到网络） Windows 徽标键 + Shift + M 还原桌面上的最小化窗口 Windows 徽标键 + 数字 打开桌面，然后启动固定到任务栏的应用（位于数字所指明的位置）。如果应用已处于运行状态，则切换至该应用。 Windows 徽标键 + Shift + 数字 打开桌面，然后启动固定到任务栏的应用新实例（位于数字所指明的位置） Windows 徽标键 + Ctrl + 数字 打开桌面，然后切换至固定到任务栏的应用的最后活动窗口（位于数字所指明的位置） Windows 徽标键 + Alt + 数字 打开桌面，然后打开固定到任务栏的应用的“跳转列表”（位于数字所指明的位置） Windows 徽标键 + Ctrl + Shift + 数字 打开桌面，然后以管理员身份打开位于任务栏上指定位置的应用新实例 Windows 徽标键 + Tab 打开任务视图 Windows 徽标键 向上键 最大化窗口 Windows 徽标键 向下键 删除屏幕上的当前应用并最小化桌面窗口 Windows 徽标键 + 向左键 最大化屏幕左侧的应用或桌面窗口 Windows 徽标键 + 向右键 最大化屏幕右侧的应用或桌面窗口 Windows 徽标键 + Home 最小化活动桌面窗口之外的所有窗口（在第二个笔划时还原所有窗口） Windows 徽标键 + Shift + 向上键 将桌面窗口拉伸至屏幕顶部和底部 Windows 徽标键 + Shift + 向下键 在垂直方向上还原/最小化活动桌面窗口，而宽度保持不变 Windows 徽标键 Shift + 向左键或向右键 将桌面上的应用或窗口从一台显示器移动至另一台显示器 Windows 徽标键 + 空格键 切换输入语言和键盘布局 Windows 徽标键 + Ctrl + 空格键 对之前选择的输入所做的更改 Windows 徽标键 + Ctrl + Enter 打开“讲述人” Windows 徽标键 + 正斜杠 (/) 开始输入法复原流程 Windows 徽标键 + Ctrl + V 打开肩式分接设备 命令提示符键盘快捷方式 快捷键 作用 Ctrl + C（或 Ctrl + Insert） 复制选定文本 Ctrl + V（或 Shift + Insert） 粘贴选定文本 Ctrl + M 输入标记模式 Alt + 所选择的键 开始在块模式下选择 箭头键 按指定方向移动光标 Page up 将光标向上移动一个页面 Page down 将光标向下移动一个页面 Ctrl + Home（标记模式） 将光标移动到缓冲区起始处 Ctrl + End（标记模式） 将光标移动到缓冲区结尾处 Ctrl + 向上键 在输出历史记录中上移一行 Ctrl + 向下键 在输出历史记录中下移一行 Ctrl + Home（历史记录导航） 如果命令行为空，则将视区移动到缓冲区顶部。否则，请删除命令行中光标左侧的所有字符。 Ctrl + End（历史记录导航） 如果命令行为空，则将视区移动到命令行。否则，请删除命令行中光标右侧的所有字符。 对话框键盘快捷方式 快捷键 作用 对话框键盘快捷方式 按键 操作 F4 显示活动列表中的项目 Ctrl + Tab 在选项卡中向前移动 Ctrl + Shift + Tab 在选项卡中向后移动 Ctrl + 数字（数字 1–9） 移动到第 n 个选项卡 Tab 在选项中向前移动 Shift + Tab 在选项中向后移动 Alt + 带下划线的字母 执行可与该字母结合使用的命令（或选择该选项） 空格键 如果活动选项为复选框，则选择或清除复选框 Backspace 如果在“另存为”或“打开”对话框中选择文件夹，则打开上一级别的文件夹 箭头键 如果活动选项是一组选项按钮，请选择一个按钮 文件资源管理器键盘快捷方式 快捷键 作用 Alt + D 选择地址栏 Ctrl + E 选择搜索框 Ctrl + F 选择搜索框 Ctrl + N 打开新窗口 Ctrl + W 关闭活动窗口 Ctrl + 鼠标滚轮 更改文件和文件夹图标的大小和外观 Ctrl + Shift + E 显示选定文件夹上所有级别文件夹 Ctrl + Shift + N 新建文件夹 Num Lock + 星号 (*) 显示选定文件夹下所有子文件夹 Num Lock + 加号 (+) 显示选定文件夹中的内容 Num Lock + 减号 (-) 折叠选定文件夹 Alt + P 显示预览面板 Alt + Enter 打开选定项目的“属性”对话框 Alt + 向右键 查看下一个文件夹 Alt + 向上键 查看该文件夹所在的文件夹 Alt + 向左键 查看上一个文件夹 Backspace 查看上一个文件夹 向右键 显示当前选择内容（如果已折叠），或选择第一个子文件夹 向左键 折叠当前所选内容（如果已展开），或选择该文件夹所在的文件夹 End 显示活动窗口底部 Home 显示活动窗口顶部 F11 最大化或最小化活动窗口 虚拟桌面的键盘快捷方式 快捷键 作用 Windows 徽标键 + Tab 打开“任务视图” Windows 徽标键 + Ctrl + D 添加虚拟桌面 Windows 徽标键 + Ctrl + 向右键 在你于右侧创建的虚拟桌面之间切换 Windows 徽标键 + Ctrl + 向左键 在你于左侧创建的虚拟桌面之间切换 Windows 徽标键 + Ctrl + F4 关闭你正在使用的虚拟桌面 任务栏键盘快捷方式 快捷键 作用 Shift + 单击任务栏按钮 打开应用或快速打开另一个应用实例 Ctrl + Shift + 单击任务栏按钮 以管理员身份打开应用 Shift + 右键单击任务栏按钮 显示应用的窗口菜单 Shift + 右键单击分组任务栏按钮 显示组窗口菜单 Ctrl + 单击分组任务栏按钮 循环浏览组窗口 任务栏键盘快捷方式 快捷键 作用 Windows 徽标键 + I 打开设置 Backspace 返回至设置主页 使用搜索框在任何页面上键入 搜索设置]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Geek</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次折腾过程（二）]]></title>
    <url>%2F2017%2F10%2F24%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8A%98%E8%85%BE%E8%BF%87%E7%A8%8B(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[第二次折腾:在稳定的使用一段时间后,有一天突然不能访问了。想到后台看一眼，没想到官网来了这样一段文字。 为了避免之前其他的提供商那句：“相会有时，后会无期”的话。我还是别等了。 VPS： 其实之前没搞VPS是因为需要信用卡或者PayPal，当时还没有。不过现在终于有了，又重新找了找发现有的提供商付款选项里有个支付宝，马云爸爸还是厉害啊。（比特币笑而不语） VPS的选择也有很多，可以上知乎看一看。别着急，耐心的看一看你是否都需要那么多配置，你需要为你过剩的CPU，内存以及硬盘空间来买单的。当然，性能越好，可做的事情就越多。你可以搭个服务器，跑点PHP，远程下载balabala的。 选择好你的服务器确定好系统后，我们可以开始了。（注：这里最好使用Linux 比Windows便宜很多而且Linux毕竟是专门干这种的，而且这里还有一个坑就是可能给你的IP也被*了，具体有没有Ping一下就行了，如果发生了咱态度诚恳点找一下客服给你换个IP解决） 开始 然后我们需要用到SSH连接工具来登录我们的服务器。 Mac和Linux下直接在终端中输入命令，连接后直接输入你的登录密码就可以直接连接。在Windows系统下需要专门的客户端来SSH登录VPS。在Xshell官网下载。 ssh root@your_VPS_ipAddress 安装Shadowsocks： Debian / Ubuntu: apt-get install python-pip pip install shadowsocks CentOS: yum install python-setuptools &amp;&amp; easy_install pip pip install shadowsocks 配置文件： 使用vim命令来编辑 /etc/shadowsocks.json vim /etc/shadowsocks.json 如果你不会用vim来保存和编辑的话，去用几分钟学习下简单的使用，这个神器还有有很多故事和强大之处的。 { &quot;server&quot;:&quot;my_server_ip&quot;, &quot;server_port&quot;:8388, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;mypassword&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false } 字段名 意义 server 你的服务器地址 server_port 连接你服务器的端口 local_address 本地服务器地址 local_port 本地端口 password 密码 timeout 超时时间（秒） method 加密方式（默认：aes-256-cfb） fast_open TCP快速开启 （true / false） 填写正确后我们保存并退出。 运行: ssserver -c /etc/shadowsocks.json 如果一切配置顺利，你可以在你的终端看见端口正在启动，然后我们在客户端上按照之前的一样填写好我们的配置就可以了。这里的小细节，不要打错任何东西，否则两边不一致是无论如何都都建立不起来连接的。 好了，我们又可以愉快的玩耍了~ 又是彩蛋： 没错，我们通过自己建立VPS有了一个自己的专属服务器连接，这个的速度和性能完全是根据我们选择去定制的。同时，我们会发现一个小弊端，那么就是我们如何让它一直活动，不能关闭后就不能用了，那也太坑了。 我们当然可以写一个shell脚本，放在开机自启动。这里有个比较取巧的方法。(感谢我的渣浪好室友,冠希童鞋:手动撒花~) 保持SS运行 使用screen命令进行远程回话管理流程： ssh登陆到远程机器上 键入screen建立一个新的会话窗口 在这个新的会话窗口中运行命令（通常是一些时间较长的任务），键入C-a d，退出并保存该会话窗口（这之后可以退出ssh登陆的终端，下次工作时重新ssh登陆，再进行如下步骤） screen -ls列出所有会话 screen -r id重新连接会话 使用exit真正退出会话 该命令真正强大之处是退出远程登陆后，screen依然会替我们管理保存的会话，在后台执行，我们再次远程登陆后可以恢复任何会话的现场，适用于时间较长的任务。 其中C-a d是ctrl + A + D一起键入。 这样我们在screen中运行启动命令，然后按ctrl + A + D退出。再断开连接的时候就不会中断这个命令，可以放心的关闭SSH连接了。 当然正统的方法是这样的： 添加应用到service：创建脚本 /etc/init.d/shadowsocks 文件（其实也是 /etc/rc.d/init.d/shadowsocks 文件） sudo vim /etc/init.d/shadowsocks 添加以下内容： #!/bin/sh # # shadowsocks start/restart/stop shadowsocks # # chkconfig: 2345 85 15 # description: start shadowsocks/ssserver at boot time start(){ ssserver -c /etc/shadowsocks.json -d start } stop(){ ssserver -c /etc/shadowsocks.json -d stop } restart(){ ssserver -c /etc/shadowsocks.json -d restart } case &quot;$1&quot; in start) start ;; stop) stop ;; restart) restart ;; *) echo &quot;Usage: $0 {start|restart|stop}&quot; exit 1 ;; esac 然后增加这个文件的可执行权限： sudo chmod +x /etc/init.d/shadowsocks 这样就可以在 shell 中直接运行下面的命令开启程序了（重启和停止同理）： sudo service shadowsocks start 注意：这里以root权限运行的，如果不想以root权限运行可以用 sudo -u {user} {command}。如果不给脚本文件加上其他用户的可执行权限，不带参数运行 service shadowsocks 会提示 unrecognized service。 设置开机启动：在上面脚本没有问题（也就是保留了前面10行，并且语法正确）的情况下，通过下面的命令，就可以设置程序自动启动了 sudo chkconfig shadowsocks on 这样程序就会自动启动了。 结合此处两个解决方案: Linux将应用添加到service，并设置自动启动 How do I install chkconfig on Ubuntu? 多用户配置 我使用的每个月有2T流量，嗯…单单使用做SS的话，的确过剩了。 我们可以开辟多个端口，为每个端口使用不同的密码来登录。 { &quot;server&quot;:&quot;my_server_ip&quot;, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: { &quot;2333&quot;:&quot;mima12345&quot;, &quot;6666&quot;:&quot;mima12345&quot; }, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: false } 这其中加密方式 我还是推荐rc4-md5的。或者他们说chacha20对移动端访问速度比较快。 主要是AES加密太耗时。 另附地址：多用户配置 结束: 经过这样我们可以暂时有一个小小的窗户，来继续访问官网的最新技术。 扔给你个小软件HyperApp~（撒花~φ(&gt;ω&lt;*) ） 至此，我们已经可以实现一个很理想的状态。但是能不能更好地让家里全局的设备，比如Chromecat也支持呢？下一篇我会介绍。]]></content>
      <tags>
        <tag>Geek</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次折腾过程（一）]]></title>
    <url>%2F2017%2F10%2F24%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8A%98%E8%85%BE%E8%BF%87%E7%A8%8B(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[写在前面:做安卓的都知道，安卓是归谷歌的。谷歌很多最新的好玩儿有趣的功能，第一时间对移动端的支持大部分也都是在安卓上。身为平常娱乐，有些东西可有可无，也就作罢。但是身为一名开发者，你经常要了解最新的咨询需要上官网，那么这个官网还不能访问，这种情况是不能容忍的。本文是我对这系列折腾过程的记录，当做一个对过去的总结。 Why？ 整体软件环境 安卓的开源是便利的，但同样是危险的。当开发者发现安卓的各种可定制的功能时，同样也是对一名开发者或者说一个软件团队的技术与「道德」的考验。 常驻后台，相互唤醒。国内安卓的App市场里各种应用的审核并不像想想象中那么严，尤其是身为一名开发者后，发现国内环境的确没有Play Store上那种基于机器学习App检测系统更安全。 如果你可以可以看看QQ在Play Store上的功能要简约明朗很多，我想无论如何Play Store多多少少制约了一下现在这种软件的「店大欺客」的状态，什么微信必须给定位权限，支付宝必须要给电话拨打权限，否则就不让用。这相当有悖于谷歌的设计动态权限申请的原则。国内虽然也有一大堆「国人习惯」的第三方ROM来制衡这个混乱的生态圈，但这也给很多开发者带来了更多的适配兼容的问题。(´-ι_-｀) 海外连接速度过慢 作为一个开发者，上到软件的下载，下到linux的代码仓，好多软件的更新支持都需要一个稳定速度的带宽支持。说到这点，就好比我刚开始用AS开发，一个几百兆的gradle文件愣是让我下载了半天时间，除了学校当时网速有点低之外更主要还是本身对海外节点的访问速度。 You Can Learn More And More 我只是一个纯粹的喜爱生活，热爱技术的人，好多东西明明应该是「无害」的，就好比我想看个谷歌IO大会的直播视频，却难以实现。好在谷歌在国内的影响力又渐渐有了些起色，虽然现在也有腾讯的同声转播，但是总感觉哪里有点不一样。 What？ 最简单的人们听过最多的也就是VPN，这个简单粗暴和正常软件的使用没什么太大难度。很多时候我们只是使用了一个服务商提供的已经设置好的「工具」，来直接使用，多数的直接就是提供商自己的出的软件，定制化不是很高。理论上和SS速度不应该差距太多，但是实际使用中稳定性，速度体验都有很大折扣。当然在企业里VPN这种东西还是很方便的，你可以远程访问内网环境来提交你的文件管理日常等。 我选择的是Shadowsocks，简称SS。 简单理解的话，Shadowsocks是将以前通过SSH创建的Socks5协议拆开成Server端和client端，下面这个原理图能简单介绍其翻墙原理，基本上和利用SSH tunnel大致类似： PC客户端（即你的电脑）发出请求基于Socks5协议跟SS-Local端进行通讯，由于这个SS-Local一般是本机或路由器等局域网的其他机器，不经过GFW，所以解决GFW通过特征分析进行干扰的问题。 SS-Local和SS-Server两端通过多种可选的加密方法进行通讯，经过GFW的时候因为是常规的TCP包，没有明显特征码GFW也无法对通讯数据进行解密，因此通讯放行。 SS-Server将收到的加密数据进行解密，还原初始请求，再发送到用户需要访问的服务网站，获取响应原路再返回SS-04，返回途中依然使用了加密，使得流量是普通TCP包，并成功穿过GFW防火墙。 How？ 各平台位置 （注： 这里的SS和SSR还是有区别的 不过本篇暂且不说。）找到一个稳定的提供商，根据节点信息来填写后连接就好。而且二维码的加入更是降低了用户门槛，很多时候只需要点击客户端的扫描二维码就可以啦！ 你可以在小伙伴的客户端或者提供商页面找到二维码，其实就是包含我所填入的这些信息的一段内容。 然后我们直接点击扫描屏幕上的二维码就会拿到识别信息了。如果没有的话，手动填写即可。（这里mac客户端是SS那么没有混淆和协议选项的情况下先不写。或者有的使用的是启动参数，-O -o等） 最后我们可以选择服务器来切换不同的节点，同样可以开启全局。也可在需要时开启。 然后我们就可以愉快的看着我们gradle下载文件的速度变快了不少。 当然还有彩蛋这是折腾过程的第一部分，没有什么复杂的东西，如果你要是动手实现的话，估计几分钟十几分钟就能搞定。当然我们们可以做的还远不止这些。 为软件设置代理 公司里大局域网屏蔽了一切和音视频相关的内容网站和信息，连网易云音乐都不让听。小伙伴们可着急了，音乐是动力啊有木有。 全局代理虽然简单暴力，让你直接达到直连的效果。但是你会发现会有很多弊端：访问国内网站时候我们仍然会走这个代理模式，这就导致了速度变慢，而且很多提供商每个月的流量也都有限。虽然正常使用下流量基本够用，但是也是浪费了不必要的资源。 在运行客户端后我们开始，选择设置中为局域网开启代理。 然后在网易云音乐里的设置里找到下载，填写好本地地址和端口，点击测试发现代理可用，然后重启软件，发现每日推荐又活过来了。 以此类推，你会发现好多软件都可以这样设置代理。达到节约流量和不影响你日常的网速效果。 更灵活的配置方式 PAC 代理自动配置（英语：Proxy auto-config，简称PAC）是一种网页浏览器技术，用于定义浏览器该如何自动选择适当的代理服务器来访问一个网址。一个PAC文件包含一个JavaScript形式的函数“FindProxyForURL(url, host)”。这个函数返回一个包含一个或多个访问规则的字符串。用户代理根据这些规则适用一个特定的代理器或者直接访问。当一个代理服务器无法响应的时候，多个访问规则提供了其他的后备访问方法。浏览器在访问其他页面以前，首先访问这个PAC文件。PAC文件中的URL可能是手工配置的，也可能是是通过网页的网络代理自动发现协议（WPAD）自动配置的。 简单来说就是国内走国内，国外走代理。你可以在客户端找到这个选项，我们可以设置国内不走这个节点，国外自动走代理。 这里我用了一个好像不是最优不过也还好： http://jiasd123.oss-cn-hangzhou.aliyuncs.com/list.txt 同样我们可以自己通过JS编辑规则，来实现更高度的定制化。语法规则和具体，可以查阅这几个参考资料: 浅析PAC，教你动手修改你的PAC文件及user-rule文件实现自动代理 详解代理自动配置 PAC-知乎专栏 PAC脚本语法（代理自动配置） 我们还可以通过软件来直接在Chrome上集成这种自动切换的插件。 比如：proxy-switchyomega 跟着教程走一遍，你会发现PAC的神器之处。 最后 祝下载不再缓慢，祝git把把顺畅。当然我们只是走了第一步，还有很多可提升的空间，后续我会再写两篇。]]></content>
      <tags>
        <tag>Geek</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017七夕]]></title>
    <url>%2F2017%2F08%2F26%2F2017%E4%B8%83%E5%A4%95%2F</url>
    <content type="text"><![CDATA[2017七夕我爱你，没有技巧，野蛮真诚。 老婆： 2017年，七夕快乐。我知道七夕节这一天的你，还在东北往北京行驶的长途大巴上。这时候的你，或是在望着沿途公路的风景，或是翻看着手机与周围人说话，也可能因为太疲劳正睡着。为了能和以往有些不同，我先写了草稿，又打在电脑上打印出来这次的信。 我知道工作和生活一定要平衡的好，既要把工作弄好，也要把生活过好。这样才会有权利去照顾别人，才有资格成为你身边的人。 时光真快，转眼就是两年多的光景，感谢能有你这一路的陪伴。你说凡事顺其自然，我当然知道这句话的意思。我很珍惜能和你在一起的每段时光。这段时间经常惹你生气，我害怕，害怕每次你生气的时候。怕哪一次就真的失去你，所以每次的礼物都当是最后一次。只要我能力所及，总是想能让你过的和别人女朋友一样开心。 对美好的东西,我总是拙于言辞,对美好的事物如此,对你也是如此。 你知道，我想爱你。我想多主动的表达我的爱意，也错误的表达好多样子，害你总是对我有些想法，好在我们那天说开了。我想了很多种再次见到你要怎样的定格才算永久，怎样的相遇姿势才能不辜负一场不轰轰烈烈，但是刻骨铭心的爱情。 我知道你内心里还是住着一个可爱善良的小公主，虽然有时候你会突然的高冷女神范儿。我问你想我没的时候，你总是违背心思的说没想我。你知道吗，虽然你叫我老公的次数很有限，但是每次都让我好开心。让我知道其实你很在乎我，也为我付出了那么多辛苦。每个周末的两天似乎是上天对我们最简单的恩赐，虽然你会经常有事去忙。但是你也从来没有因为自己太累而对我的语音要求说不，当然生气的时候除外。 想带你走过每个春夏秋冬，不想太普通，不想落于俗套，却也不想弄得浮夸做做。 想在你开心的时候坐在沙发上听你说天南海北，在你需要的时候有一个可以依靠的肩膀。想了解你穿衣服的风格，想明白对化妆品牌的偏爱，想知道你爱吃的每个味道。太多的想要了解，太多的想要知道。想慢慢的守着我们的幸福，简简单单却丰富多彩。 我这段时间过得其实并不是想象中的好，但是眼前的所有都是为了能更好的见到你的考验。我也在努力争取时间，努力丰富自己，好早日在北京与你相聚。这件事情，我定不负你。 可遇不可求，珍惜便是。 其实我真的很想很想在七夕之前完成好它，每个机关都想着最完美的实现方式。但是任何能让你感到惊喜的机会，都不想错过。哪怕只有一毫秒的惊艳之感，就要用力去做。我不知道当这个盒子到你手里的时候,会不会是准时的七夕。准确来说它不算是一个盒子吧，我知道这又是一个毫不实用，也无处安放的东西。没有地方的话，尽管让它魂归垃圾桶。只要能让你开心这一秒，这都不算是事情。 （如果老婆大人还有空间的话，这个小小的盒子就请先寄存在那也好。等我去北京，我帮你放着。） 如果余生来得及，你是我所有的不介意。 徐鑫 2017年8月25日晚]]></content>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio更改R文件位置]]></title>
    <url>%2F2017%2F06%2F22%2FAndroid%20Studio%E6%9B%B4%E6%94%B9R%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言AndroidStudio（以下简称AS）内置了多种强大的快捷操作，最近项目需要在另一个项目基础上更改，替换包名是个麻烦的工作。安卓程序中的R文件改名的各种坑，导致找不到文件的错误。 后来发现只需要几个简单的步骤就可以将R文件位置替换好。 步骤一 视图切换为Project或者Android，方便查找文件。 以Android视图为例： 找到AndroidManifest文件，找到package中的包名并选中 右键Refactor -&gt; Rename 或者快捷键shift + F6 点击RenamePackage，然后输入所需的R文件名字，点击Refactor 过程可能会有点卡顿，等待画面加载完毕。（过程中出现的重命名都用Do Refactor） 步骤二 打开对应Module的build.gradle文件,更改相应的applicationId即可。 然后点击Build -&gt; Rebuild Project等待Build完成 这时候会发现包名及R文件已经更改。]]></content>
      <tags>
        <tag>Android</tag>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IC卡破解教程]]></title>
    <url>%2F2017%2F06%2F12%2FIC%E5%8D%A1%E7%A0%B4%E8%A7%A3%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前言 我的学校并不是“211”,“985”之类的重点大学，学校的热水也不是免费。每学期补贴的20多块根本不够用，而且丢了之后也**懒得去买**，关键还是觉得**热水** 这个东西**太奢侈**。走过弯路，不过也算比较顺利的解决了问题。后来我还自己编写了一个带GUI程序和安卓小DEMO软件，直到后来学校把设备都换成**联网**，并且实名制。免费水卡算是告一段落。 好在升级设备前也把水卡钱充的足够多了，我不贪心够用就好，仅仅帮助我女朋友和室友在内的几个人而已。本文是把我理解的一些入门知识梳理开来，特此纪念一下这段大学时光。自学能力有限，不足之处望不吝指正。 我把实现过程分成两个部分，可以先看**原理简介**，也可以直接看**实现过程**。 原理简介 1.首先介绍一个概念，RFID 射频识别，RFID（Radio Frequency Identification）技术，又称无线射频识别，是一种通信技术，可通过无线电讯号识别特定目标并读写相关数据，无需识别系统与特定目标之间建立机械或光学接触。 射频的话，一般是微波，1-100GHz，适用于短距离识别通信。RFID读写器也分移动式的和固定式的，目前RFID技术应用很广，如：图书馆，门禁系统，食品安全溯源等。 从概念上来讲，RFID类似于条码扫描，对于条码技术而言，它是将已编码的条形码附着于目标物并使用专用的扫描读写器利用光信号将信息由条形磁传送到扫描读写器； 而RFID则使用专用的RFID读写器及专门的可附着于目标物的RFID标签，利用频率信号将信息由RFID标签传送至RFID读写器。 从结构上讲RFID是一种简单的无线系统，只有两个基本器件，该系统用于控制、检测和跟踪物体。系统由一个询问器和很多应答器组成。 2.简单说下RFID工作原理: 卡片由一个卷绕天线和特定用途集成电路模块组成。 其中，模块由一个高速(106KB波特率)的RF接口。一个控制单元和一个8K位E2PROM组成。读写器向MF1卡发出一组固定频率(13.56MHZ)的电磁波， 卡片内有一个LC串联谐振电路，其频率与读写器发射的频率相同， 在电磁波的激励下，LC谐振电路产生共振，从而使谐振电容内有了电荷， 在这个电容的另一端，接有一个单向导通的电子泵，将电容内的电荷送到模块存储电容内储存， 当所积累的电荷达到2V以上时，此电容可作为电源向模块电路提供工作电压，将卡内数据发射出去或接收读写器的数据。 3.存储结构: 字节号 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 控制值 FF FF FF FF FF FF 07 08 69 FF FF FF FF FF FF 说明 密码A（0~5字节） 存储控制 密码B（10~15字节） 4.控制属性： 每个扇区的用户密码和存取控制条件都是独立设置的，可以根据实际需要设定各自的密码及存取控制。 在存取控制中，每个块都有三个控制位相对应，用以决定某数据块或控制块的读写条件，定义为：”CXxy”，见表1所示。 其中CX代表每块控制位号(C1～C3)，x代表某块所属扇区号(0～15)， y代表该扇区内某块号。例如C1x2 即为x扇区内块2的第1控制位，余此类推。 注：控制位的设置存放在存取控制字节中，见表2所示。 >**表1：控制位定义"CXxy"** > 块0| C1x0| C2x0| C3x0| 用户数据块，(0区0块除外) ---| --- | ----| ----| 块1| C1x1| C2x1| C3x1| 用户数据块 块2| C1x2| C2x2| C3x2| 用户数据块 块3| C1x3| C2x3| C3x3| 密匙存取控制块 >**表2:三个控制位在存取控制字节中的位置**(注：" _b" 表示取反) > |位号 | bit 7| 6| 5| 4| 3| 2| 1| 0 --- | --- | ----|---|---|---|---|---|--- **字节号** | | | | | | | | | | 字节6 ||C2x3_b |C2x2_b |C2x1_b |C2x0_b |C1x3_b |C1x2_b |C1x1_b |C1x0_b| 字节7 ||C1x3 |C1x2 |C1x1 |C1x0 |C3x3_b |C3x2_b |C3x1_b |C3x0_b| 字节8 ||C3x3 |C3x2 |C3x1 |C3x0 |C2x3 |C2x2 |C2x1 |C2x0| 字节9 ||BX7 |BX6 |BX5 |BX4 |BX3 |BX2 |BX1 |BX0| 所属块 ||块3控制位|块2控制位 |块1控制位 |块0控制位 |块3控制位 |块2控制位 |块1控制位 |块0控制位| 关于更多细节知识，点击这里: [mifare卡的初值说明及使用方法](http://pan.baidu.com/s/1jHCeVkU) 实现过程 1.分清卡的种类： 我们破解卡，首先要分清是什么卡。RFID里有很多种卡，IC卡现在最为常见。ID卡过去较为常见，逐渐被淘汰。现多数卡都是IC卡，M1类型的。为了帮助大家识别，介绍个简单方法。 2.破解原理： IC卡的特点是由16个扇区存储数据（0~15，不是16，0扇区是第一个），0扇区用来存储卡号，所以机器上直接能读取到卡号。每个扇区的数据有４块，即0~3。前三个用于存储数据，最后一个块用来存放KeyA和KeyB。先不用管有什么区别，只要记住这个就是破解一个扇区的关键就好。 紧接着如果我们有了KeyA就可以更改相应扇区的块里面的值。（这样听起来是不是简单多了？） 被标为蓝色的就是KeyA，后面跟着的ff07 8069是默认控制位，先不用理会，后面的6efd 32e1 1f59就是KeyB。只要我们获得到这个，就可以随意更改其他三个块里面的数据。（其实第四个块，块3也能更改，后面会提到，一般不需要因为你改了，机器不识别也没用0.0）细心的你可能发现这KeyA和KeyB不TM一样嘛！本来应该不一样，这里它俩一样更是降低了安全系数，同时为以后我们穷举破解减少了时间。 这是一个卡0扇区的数据，第一行为0块，卡号就是存在这里。 也是识别一张唯一卡的标志，它是不会被更改的，就是说你即使知道KeyA也更改不了这个扇区里面的值。这样做的目的当然是有的，就是说如果以后出了问题通过日志记录会知道是哪张卡。 3.破解过程： 说了这么多知道了原理，现在终于开始操作了。 连接上ACR122U读卡器到电脑，运行M1卡服务程序。 程序会自动识别出读卡器，初次安装可能会自动安装驱动，稍等一下就行。直到读卡器的灯亮起红色，这时候如果程序没识别读卡器重启一次程序就行。 这个时候已经识别出读卡器，将需要破解的卡放在上面，读卡器的灯会变成绿色，并会有一声“滴”表示已经检测到卡片。点击开始破解，进入穷举。 等待破解，这个过程看卡加密扇区多少和密码强度有关，只要不是全扇区加密耐心等待一会儿就好。极个别情况，我试过会长时间无响应，再试一次就好。破解完成后读卡器会闪一下，并有一声“滴”。 在软件根目录下会按日期生成dump文件，用ultra edit 或者sublime text之类的编辑软件就能直接打开，看见里面的数据。 接下来的范畴就是改数据，我两次打水后的金额一定不相同。以此找出数据区，推荐使用ultra compare这个软件。省着自己人工找了。 我比较懒，没拿以前的水卡做对比，这里放了一张我饭卡的。饭卡联网大家不要动啊！联网的服务器有数据!切记！切记！切记！重要的事情说三遍！ 我上次卡里有35.47块16进制是0ddb，它存储的是db0d，这里不难看出。下一次消费12，所以是23.47块16进制是092b 在后面的0069没弄清，不过每次都不变动，再后面的13b9。13是日期13号，和我们的消费终端位置。b004是04b0换算过来就是1200精确少数点后两位就是12.00块就是我这次消费的金额。在后面0605类似，最后6a7b那里和6aee不同是为了让整个行的异或和校验为00。 这有点类似于一个密码校验，不能让人随便改数，当然这个算法我现在通过多次数据对比发现了，所以随便改数也就没事了。可以根据实际情况，多次取值，一般都可以推算出结构，然后算出来滴。 4.复制、改值 先说复制，直接把另一个复制软件打开，将uid卡放在上面，dump文件对应好，就直接成功了。没什么技巧，一般都能看懂，注意一点一定要是UID卡，否则会因为0扇区写入不成功出错。 改值，用PCSC Mifare。 打开软件，初始化，放上卡片。点击加载秘钥，把从dump文件里要修改的扇区KeyA记住，输入进去。密钥存储编号默认就行。 点击扇区认证，我是要修改2扇区所以打2，密钥选A 如果你前两步没有出问题，那么会显示认证成功！紧接着点读取扇区就会显示这个扇区的数据。 点击二进制写扇区将数据9B 07 00 69 15 B9 0B 01 40 06 4B 00 06 05 6A 3A写进去，去掉空格（由于这个里有两个块都存值，所以我勾选两个，一次更改完） 完事点击二进制读扇区会发现数据已经更改，后一次我是又写回来了，改饭卡绝对作死啊！ 通过PCSC可以修改密钥，自行探索即可。 注意：经测试发现这个软件只能在xp下好使，所以我把它放进xp虚拟机中运行，应该是软件不兼容后期维护也差着了的缘故。还有如果打不开记得安装framework 2.0框架 5.**全扇区加密破解** 当然上面的方法只适用于非全扇区加密的小打小闹，现在好多公司都是防复制卡，就是全扇区加密。但是通过侦听方式还是可以实现的。这部分比较复杂，自行百度就行，我说的也都大同小异。 pm3的工具比较贵，廉价方案是用侦听卡，前提要有ACR122U读卡器。简单原理就是通过侦听两次通信，得出一个KeyA，相当于有一个扇区已知，再进行破解。这部分内容可自行探索。 结语 花了几个小时，终于整理完了这篇文章也算是有始有终吧。未来估计用到很少，可能就是自己电梯卡用用而已。大四上学期，临近毕业人的心态也有变化。细细想来这算是一个很宝贵的经历。感谢百度，感谢我的室友，感谢我女朋友桐。 2017年6月12日11:08:24:毕业后又整理了一次这个文章，重新提交到博客上。以此纪念我的一段大学Geek时光，纪念当时为了与一个编程兴奋到彻夜未眠的自己。 希望这篇文章能对你有帮助。 更新历史： version 1.0 2016/10/16 星期日 22:12:50 version 1.1 2017年6月12日09:47:48 version 1.3 2017年6月14日15:24:56]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Geek</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓开发常用软件]]></title>
    <url>%2F2017%2F06%2F12%2F%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[系统工具类基石软件 驱动人生软件 电脑管家 NVIDIA 搜狗输入法 Chrome Chorme常用插件: TamperMonkey 穹顶穿越 Smooth Key Scroll 小番茄 SwitchHosts hosts文件下载 开发工具类开发必要支持 Android Studio JDK Eclipse ADT23.0.7 Myeclipse Sqlite Expert ApkToolKit VMware破解版 MySQL Tomcat Android镜像 Nexus toolkit 文字处理类文字编辑所需 Sublime Text3 破解 Ultracompare MarkdownPad Awesomium 1.6.6 SDK 邮箱:**Soar360@live.com** 授权秘钥: GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2 kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45J E2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJd hGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 常用软件类功能扩展 wox seer官网下载 flux 魔方 小黑屋云写作软件 金山打字通 2345软件 好压 Everything 印象笔记 整理: ArnoFrost 版本:v1.2 2017年6月14日15:04:39]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Arno , hello world]]></title>
    <url>%2F2017%2F06%2F08%2FHello%20Arno%20%2C%20hello%20world%2F</url>
    <content type="text"><![CDATA[blah blah blah Hello, 欢迎来到我的个人博客。]]></content>
      <tags>
        <tag>符号·人生</tag>
      </tags>
  </entry>
</search>
