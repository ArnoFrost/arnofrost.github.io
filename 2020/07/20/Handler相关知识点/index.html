
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Handler相关知识点 - Fox Hound</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="ArnoFrost FoxHound,"> 
    <meta name="description" content="Life should be so,Handler常见知识总结
version 0.1

[TOC]
主要组件：
Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的MessageQueue(消息队列)。
Han,"> 
    <meta name="author" content="Arno Frost"> 
    <link rel="alternative" href="atom.xml" title="Fox Hound" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 7.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">Fox Hound</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://arnoforst.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">Handler相关知识点</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">Handler相关知识点</h1>
        <div class="stuff">
            <span>七月 20, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/Handler/" rel="tag">Handler</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%9C%BA%E5%88%B6/" rel="tag">机制</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="Handler常见知识总结"><a href="#Handler常见知识总结" class="headerlink" title="Handler常见知识总结"></a>Handler常见知识总结</h1><blockquote>
<p>version 0.1</p>
</blockquote>
<p>[TOC]</p>
<h2 id="主要组件："><a href="#主要组件：" class="headerlink" title="主要组件："></a>主要组件：</h2><ol>
<li><strong>Looper</strong>: 一个<strong>线程</strong>可以产生<strong>一个</strong>Looper对象，由它来<strong>管理</strong>此线程里的<strong>MessageQueue</strong>(消息队列)。</li>
<li><strong>Handler</strong>: 你可以构造Handler对象来<strong>与Looper沟通</strong>，以便<strong>push</strong>新消息到MessageQueue里;或者<strong>接收</strong>Looper从Message Queue取出)所送来的<strong>消息</strong>。</li>
<li><strong>Message Queue</strong>(消息队列):用来<strong>存放</strong>线程放入的<strong>消息</strong>，采用单链表实现。</li>
<li><strong>线程</strong>：UIthread 通常就是main thread，而Android启动程序时会替它建立一个MessageQueue。</li>
</ol>
<h2 id="过程简单概述"><a href="#过程简单概述" class="headerlink" title="过程简单概述"></a>过程简单概述</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guolin_blog/article/details/9991569">郭霖-Android异步消息处理机制完全解析，带你从源码的角度彻底理解</a></p>
<p>Android UI线程是不安全，同时也不能进行耗时操作，安卓提供了Handler方便开发者来进行线程间切换与通信。<br>Handler在<strong>创建时需要</strong>传递一个线程的<strong>Looper</strong>，Looper内存在对应线程的<strong>消息队列</strong>（MessageQueue）（通过ThreadLocal获取）。Handler将<strong>消息</strong>（Message）发送给Looper，由Looper<strong>放入消息队列</strong>。而Looper又通过循环从消息队列中<strong>取出</strong>消息再<strong>交给Handler</strong>处理。</p>
<p><img src="https://imgur.com/download/I4S8ANc" alt="-c"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LooperThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          Looper.prepare();</span><br><span class="line"> </span><br><span class="line">          mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">              <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                  <span class="comment">// process incoming messages here</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;;</span><br><span class="line"> </span><br><span class="line">          Looper.loop();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h2><h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><blockquote>
<p>Handler构造方法：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(Callback callback, <span class="type">boolean</span> async)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Handler</span>&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">&quot;The following Handler class should be static or leaks might occur: &quot;</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mLooper = Looper.myLooper(); <span class="comment">//这里从Looper中获取mLooper对象，如果为空则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="string">&quot;Can&#x27;t create handler inside thread that has not called Looper.prepare()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;<span class="comment">//从Looper中获取消息队列</span></span><br><span class="line">        mCallback = callback;<span class="comment">//callback赋值</span></span><br><span class="line">        mAsynchronous = async;<span class="comment">//是否是同步处理消息</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>Looper.myLooper():</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> Looper <span class="title function_">myLooper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到初始化的过程中就是要从Looper中获取myLooper，那与我们直接使用之间的区别是是否有调用<code>Looper.prepare()</code>方法。</p>
<blockquote>
<p>Looper.prepare()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> <span class="title class_">Looper</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先判断<code>sThreadLocal</code>中是否已经存在Looper，没有的话则创建一个新的进去，而且必须满足只能有一个Looper对象。</p>
<p>（主线程不需要，因为系统在<strong>ActivityThread启动</strong>时已经调用了该方法）</p>
<hr>
<h3 id="发送消息过程"><a href="#发送消息过程" class="headerlink" title="发送消息过程"></a>发送消息过程</h3><p>最终调用为<code>public boolean sendMessageAtTime(Message msg, long uptimeMillis)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(Message msg, <span class="type">long</span> uptimeMillis)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">sent</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue != <span class="literal">null</span>) &#123;</span><br><span class="line">        msg.target = <span class="built_in">this</span>;</span><br><span class="line">        sent = queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>msg</code>为发送的 <strong>Message</strong> 对象，<code>uptimeMillis</code>表示 <strong>发送消息的时间</strong>。如果没有延迟，则延迟时间为0。<em><strong>注意</strong></em> 它的时间是系统 <strong>开机到当前时间的毫秒数再加上延迟时间</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(Message msg, <span class="type">long</span> delayMillis)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            delayMillis = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="入队过程"><a href="#入队过程" class="headerlink" title="入队过程"></a>入队过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.when != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AndroidRuntimeException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span> &amp;&amp; !mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread not allowed to quit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuiting) &#123;</span><br><span class="line">            <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(<span class="string">&quot;MessageQueue&quot;</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">            mQuiting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="comment">//入队过程</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;<span class="comment">//先判断是否需要立即发送或延迟时间小于队列中第一个消息的延迟时间的话则放入队首</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">null</span> &amp;&amp; p.when &lt;= when) &#123;<span class="comment">//否则找到合适位置入队</span></span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = prev.next;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">            <span class="built_in">this</span>.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队过程中只有<code>mMessages</code>来表示当前待处理消息，同时按照时间来升序排列。同时注意虽然称之为消息队列但是我们看见其实这是一个单链表的结构，优点是增删的性能较好。</p>
<h3 id="出队过程"><a href="#出队过程" class="headerlink" title="出队过程"></a>出队过程</h3><p>出队主要是通过<code>Looper.loop()</code>方法,所以使用中只是调用<code>prepare</code>入队是不能让handler工作起来的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//这里单链表中获取消息一直是循环的，当没有消息时这里会阻塞住，进入休眠状态等待再有消息后唤醒</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里有一个执行耗时阈值的检测，统计执行时间差如果超过阈值会进行打印，并获取堆栈信息</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">slowDispatchThresholdMs</span> <span class="operator">=</span> me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">traceTag</span> <span class="operator">=</span> me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> end;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//开始调用target的dispatchMessage来分发消息</span></span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end = (slowDispatchThresholdMs == <span class="number">0</span>) ? <span class="number">0</span> : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (slowDispatchThresholdMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> end - start;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Dispatch took &quot;</span> + time + <span class="string">&quot;ms on &quot;</span></span><br><span class="line">                        + Thread.currentThread().getName() + <span class="string">&quot;, h=&quot;</span> +</span><br><span class="line">                        msg.target + <span class="string">&quot; cb=&quot;</span> + msg.callback + <span class="string">&quot; msg=&quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">        <span class="comment">// identity of the thread wasn&#x27;t corrupted.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">newIdent</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">&quot;Thread identity changed from 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">&quot; to 0x&quot;</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">&quot; while dispatching to &quot;</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + msg.callback + <span class="string">&quot; what=&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见主要是进入了<strong>死循环</strong>，并不断的调用消息队列的<code>next()</code>来获取消息，出队操作中如果没有消息或消息发送时间还未到会进入阻塞，只有手动让Looper停止才可以使next()方法返回null，从而退出循环</p>
<p>具体出队过程分析： &#x2F;&#x2F;TODO </p>
<h3 id="分发事件"><a href="#分发事件" class="headerlink" title="分发事件"></a>分发事件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">//如果消息msg.callback不为空则回调给callback，赋值的地方稍后分析</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果初始化时候有callback，则会在本身的callback中回调handleMessage</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通常情况会直接回调给handleMessage去处理</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而其中的<code>handleCallback</code> 实际上是调用了run（）方法，<br><code>handleMessage</code> 是回调去处理，<code>mCallback</code>赋值地方下面分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">handleCallback</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback interface you can use when instantiating a Handler to avoid</span></span><br><span class="line"><span class="comment"> * having to implement your own subclass of Handler.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>由于<code>Handler</code>总是依附于<strong>创建时</strong>所在的<strong>线程</strong>（Looper决定），比如在主线程中创建，而子线程无法直接对UI进行操作，于是可以通过调用<code>Handler</code>将消息经过一些列的发送，入队，出队最后在<strong>主线程</strong>的<code>handleMessage</code>中<strong>回调</strong>。</p>
<ul>
<li><code>Handler.post()</code> 方法:</li>
</ul>
<p>这里调用了<strong>sendMessageDelayed()</strong>, 并将时间设置为 0ms，mCallback也是这个时候去赋值的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(Runnable r)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Message <span class="title function_">getPostMessage</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    <span class="comment">//obtain是从消息缓存池中获取避免多次new的优化</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">    <span class="comment">//这里将runnable对象赋值给了callback</span></span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>View.post()</code> 方法：</li>
</ul>
<p>最终还是调用了<code>handler.post</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">post</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    Handler handler;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        handler = mAttachInfo.mHandler;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果还没有被依附则会放入队列等待直到被依附后调用</span></span><br><span class="line">        ViewRoot.getRunQueue().post(action);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler.post(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>runOnUiThread()</code> 方法：<br>也是调用了<code>post</code>,同时如果是主线程则直接<code>run</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runOnUiThread</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        action.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="常见问题与优化"><a href="#常见问题与优化" class="headerlink" title="常见问题与优化"></a>常见问题与优化</h2><h3 id="Android中为什么非UI线程不能更新UI"><a href="#Android中为什么非UI线程不能更新UI" class="headerlink" title="Android中为什么非UI线程不能更新UI?"></a>Android中为什么非UI线程不能更新UI?</h3><h4 id="UI线程工作机制"><a href="#UI线程工作机制" class="headerlink" title="UI线程工作机制"></a>UI线程工作机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">    thread.attach(<span class="literal">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                <span class="title class_">LogPrinter</span>(Log.DEBUG, <span class="string">&quot;ActivityThread&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    <span class="comment">//主线程会一直死循环运行 也就是阻塞</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="comment">//如果死循环退出了，程序就会崩掉抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>UI线程</strong>就是<strong>zygote</strong>直接fork出来的<strong>进程中的线程</strong>，就是Activty中的<strong>main</strong>。</p>
<hr>
<h4 id="为什么UI线程设计成不安全的？"><a href="#为什么UI线程设计成不安全的？" class="headerlink" title="为什么UI线程设计成不安全的？"></a>为什么UI线程设计成不安全的？</h4><p>如果在子线程子线程中去更新ui，必定要对view更新的操作加锁，<strong>加锁的效率很受影响</strong>，不能接受</p>
<ul>
<li>ui具有可变性，甚至是高频可变性</li>
<li>ui对响应时间非常敏感</li>
<li>ui组件必须批量绘制，保证效率</li>
</ul>
<h4 id="非UI线程一定不能更新UI吗？"><a href="#非UI线程一定不能更新UI吗？" class="headerlink" title="非UI线程一定不能更新UI吗？"></a>非UI线程一定不能更新UI吗？</h4><p>可以间接更新，比如<strong>post</strong>，<strong>postinvalidate</strong>。还有<strong>SurfaceView</strong>是直接在子线程中去更新UI的，在Activity的<code>onCreate</code>生命周期中也可以在子线程中更新ui。</p>
<p><img src="https://imgur.com/download/4zQHJqG" alt="-c"></p>
<p>安卓更新UI的时候会去做<strong>线程检测</strong>，检测创建这个UI的线程是不是要更新ui的线程，更新UI就是在<code>ViewRootImpl</code>中做<strong>requestLayout</strong>，做线程检测。</p>
<p>但是ViewRoot是在<strong>onResume</strong>中<code>addDecView</code>去实现的，如果在<strong>onCreate</strong>中创建子线程更新UI 也许这时候<strong>还没有创建Viewroot</strong>，这时候就<strong>绕开了检测</strong>。</p>
<p>在子线程弹<code>Toast</code>是可以的，因为<strong>Toast</strong>是在<strong>windowManager</strong>上弹的，与Activity无关，也就与ViewRoot无关，但是由于Toast里面用到了handler，所以在子线程中***Looper.prepare()***一下。所以，在子线程中是可以更新ui的</p>
<h3 id="Handler常见的内存泄露问题"><a href="#Handler常见的内存泄露问题" class="headerlink" title="Handler常见的内存泄露问题"></a>Handler常见的内存泄露问题</h3><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a692377518825734e3e71ab">掘金 - 你的 Handler 内存泄露 了吗？</a></p>
<h3 id="Handler-postDelay方法是否可靠？"><a href="#Handler-postDelay方法是否可靠？" class="headerlink" title="Handler postDelay方法是否可靠？"></a>Handler postDelay方法是否可靠？</h3><blockquote>
<p>结论：不可靠，但需要深入分析</p>
</blockquote>
<ul>
<li>大于Handler Looper的周期时基本可靠（例如主线程&gt;50ms）</li>
<li>Looper 负载越高，任务越容易积压，进而导致卡顿</li>
<li>不要用Handler的delay做计时使用</li>
</ul>
<p><img src="https://imgur.com/dowanload/R37uPgJ" alt="-c"></p>
<p>当事件生产过多，在队列中事件产生堆积时要注意。</p>
<p>这里还是要分析入队的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="type">boolean</span> needWake;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">                <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">                <span class="comment">//如果在队列最开始并满足条件</span></span><br><span class="line">                msg.next = p;</span><br><span class="line">                mMessages = msg;</span><br><span class="line">                needWake = mBlocked;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//根据when时间去遍历然后放入队列</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入阻塞态</span></span><br><span class="line">            <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">                nativeWake(mPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="loop-分析"><a href="#loop-分析" class="headerlink" title="loop()分析"></a>loop()分析</h4><p><a href="#%E5%87%BA%E9%98%9F%E8%BF%87%E7%A8%8B">Looper.loop过程</a> 中看到了调用了Message的<strong>next</strong>方法，这里是我们要分析的重点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//如果这里的值是-1则会在底层阻塞</span></span><br><span class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">                <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                        <span class="comment">//设置时间要休眠的时间，让nativePollOnce一段时间后醒过来</span></span><br><span class="line">                        nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        <span class="keyword">return</span> msg;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，消息等待阻塞机制主要是在<code>nativePollOnce</code>中去实现，当前消息时间还没有到，或者没有消息了，这时候会进行等待<strong>休眠状态</strong>，<strong>不会消耗cpu</strong>，这是采用了<strong>Linux的IO多路复用机制</strong></p>
<p><img src="https://imgur.com/download/zV9k6EL" alt="-c"></p>
<p> 大致过程描述为从<code>MessageQueue</code>调用<code>next</code>后<strong>如果没有消息</strong>会进入底层的<code>pollOnce</code>然后去调用<code>epoll_wait</code>这个文件描述符上去<strong>等待</strong>消息。<br> 当有新消息进来<strong>需要处理时</strong>，会让底层的调用<code>wake</code>然后通过<code>write</code>后去让<code>epoll_wait</code><strong>唤醒</strong>，再通知上层继续。</p>
<blockquote>
<p>总结：<br>言而言之Looper采用了<strong>epoll机制</strong>，当没有消息来得时候会处于阻塞状态<strong>wait</strong>,从而不消耗CPU,当消息需要通知的时候会通过<strong>wake</strong>来通知上层继续工作。</p>
</blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5e7776bdf265da57127e6b2b#heading-12">掘金-彻底了解Handler</a></li>
</ul>
<hr>
<h3 id="为什么Handler不会阻塞主线程造成ANR-（Looper死循环为什么不会导致CPU占用率很高？）"><a href="#为什么Handler不会阻塞主线程造成ANR-（Looper死循环为什么不会导致CPU占用率很高？）" class="headerlink" title="为什么Handler不会阻塞主线程造成ANR?（Looper死循环为什么不会导致CPU占用率很高？）"></a>为什么Handler不会阻塞主线程造成ANR?（Looper死循环为什么不会导致CPU占用率很高？）</h3><h4 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h4><p>首先明确，造成ANR的主要是事件没有在规定时间内分发。只有当应用程序的UI线程响应超时才会引起ANR，超时产生原因一般有两种。</p>
<ul>
<li>当前的事件没有机会得到处理，例如UI线程正在响应另一个事件，当前事件由于某种原因被阻塞了。</li>
<li>当前的事件正在处理，但是由于耗时太长没能及时完成。</li>
</ul>
<h5 id="ANR-类型"><a href="#ANR-类型" class="headerlink" title="ANR 类型"></a>ANR 类型</h5><ul>
<li>ServiceTimeOut:<ol>
<li>前台服务20s</li>
<li>后台服务200s</li>
</ol>
</li>
<li>BroadcaseQueue Timeout:<ol>
<li>前台广播 10S</li>
<li>后台广播 60S</li>
</ol>
</li>
<li>ContentProvider Timeout：10S</li>
<li><strong>InputDispatching</strong> Timeout: 5S</li>
</ul>
<h6 id="分析一次ANR过程"><a href="#分析一次ANR过程" class="headerlink" title="分析一次ANR过程"></a>分析一次ANR过程</h6><p>无论是四大组件或者进程等只要发生ANR，最终都会调用***AMS.appNotResponding()***方法</p>
<blockquote>
<p>以Service TimeOut为例：</p>
</blockquote>
<p><img src="https://imgur.com/download/TlAl6TI"></p>
<p>ActivityServices类中：</p>
<p>####### 埋入炸弹</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">realStartServiceLocked</span><span class="params">(ServiceRecord r, ProcessRecord app, <span class="type">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//发送delay消息(SERVICE_TIMEOUT_MSG) 在这里埋入炸弹</span></span><br><span class="line">        bumpServiceExecutingLocked(r, execInFg, <span class="string">&quot;create&quot;</span>);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//最终执行服务的onCreate()方法</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bumpServiceExecutingLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> fg, String why)</span> &#123;</span><br><span class="line">    ... </span><br><span class="line">    scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleServiceTimeoutLocked</span><span class="params">(ProcessRecord proc)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc.executingServices.size() == <span class="number">0</span> || proc.thread == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = proc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当超时后仍没有remove该SERVICE_TIMEOUT_MSG消息，则执行service Timeout流程</span></span><br><span class="line">    <span class="comment">//同时判断根据是否是前台进程来设置超时时间为20s与200s</span></span><br><span class="line">    mAm.mHandler.sendMessageAtTime(msg,</span><br><span class="line">        proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见发送了一个delay的消息一旦达到超时时间就会触发，那提前拆除这个消息的地方就是在<strong>onCreate</strong>方法后紧接调用<strong>system_server</strong> 的 <code>serviceDoneExecuting</code></p>
<p>####### 拆除炸弹</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="type">boolean</span> inDestroying, <span class="type">boolean</span> finishing)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="literal">null</span>) &#123;</span><br><span class="line">            r.app.execServicesFg = <span class="literal">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当前服务所在进程中没有正在执行的service</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当service启动完成后，则移除service创建超时的消息否则就会触发。</p>
<p><img src="https://imgur.com/download/RJV1zGJ"></p>
<p>####### 引爆炸弹</p>
<p>在<code>system_server</code>进程中有一个Handler线程, 名叫”<code>ActivityManager</code>”.当倒计时结束便会向该Handler线程发送 一条信息 <em><strong>SERVICE_TIMEOUT_MSG</strong></em> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MainHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;</span><br><span class="line">                ...</span><br><span class="line">        mServices.serviceTimeout((ProcessRecord)msg.obj);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">serviceTimeout</span><span class="params">(ProcessRecord proc)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (anrMessage != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当存在timeout的service，则执行appNotResponding</span></span><br><span class="line">        mAm.appNotResponding(proc, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">false</span>, anrMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">appNotResponding</span><span class="params">(ProcessRecord app, ActivityRecord activity, ActivityRecord parent, <span class="type">boolean</span> aboveSystem, <span class="keyword">final</span> String annotation)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Bring up the infamous（声名狼藉）App Not Responding dialog</span></span><br><span class="line">     <span class="comment">//弹出ANR对话框</span></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        msg.what = SHOW_NOT_RESPONDING_MSG;</span><br><span class="line">        msg.obj = map;</span><br><span class="line">        msg.arg1 = aboveSystem ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        map.put(<span class="string">&quot;app&quot;</span>, app);</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;activity&quot;</span>, activity);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//向ui线程发送，内容为SHOW_NOT_RESPONDING_MSG的消息</span></span><br><span class="line">        mUiHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过一系列的跟踪，终于看见了一直以来深恶痛觉的ANR错误的由来。其中也夹杂着各种信息收集trace等，如果展开篇幅太长，我也参考了这里：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://gityuan.com/2016/12/02/app-not-response/">袁辉辉-理解Android ANR的信息收集过程</a></li>
<li><a target="_blank" rel="noopener" href="http://gityuan.com/2016/07/02/android-anr/">袁辉辉-理解Android ANR的触发原理</a></li>
</ul>
<hr>
<h4 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h4><p>ActivityThread的<code>main</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="type">ActivityThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActivityThread</span>();</span><br><span class="line">        thread.attach(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        Looper.loop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://imgur.com/download/cdK21XK" alt="-c"></p>
<p>Looper是一个整体概念，ANR主要是执行到某一环节执行耗时的一种监控。所以有了这个区别，发现应该更侧重于<strong>Looper为何不会导致CPU占用率过高？</strong></p>
<p>由于Looper消息底层是native的<code>epoll_wait</code></p>
<ul>
<li>Looper::pollInner:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mEpollFd = <span class="built_in">epoll_create</span>(EPOLL_SIZE_HINT);</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">epoll_ctl</span>(mEpollFd,EPOLL_CTL_ADD,mWakeEventFd, &amp;eventItem);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> eventItems[EPOLL_MAX_EVENTS];</span><br><span class="line"><span class="type">int</span> eventCount = <span class="built_in">epoll_wait</span>(mEpollFd.eventItems,EPOLL_MAX_EVENTS,timeoutMills);</span><br></pre></td></tr></table></figure>

<p><img src="https://imgur.com/download/Le11BPp" alt="-c"></p>
<blockquote>
<p>IO多路复用部分会有一个监控的红黑树，开始时对epoll监听描述符做了一个配置连接的管道，如果事件就绪会移动到就绪列表，绿色的部分，然后去通知<code>epoll_wait</code>。这时如果Looper卡在了<code>epoll_wait</code>则会把它唤醒，去处理消息。</p>
</blockquote>
<hr>
<h3 id="消息屏障是什么？"><a href="#消息屏障是什么？" class="headerlink" title="消息屏障是什么？"></a>消息屏障是什么？</h3><p>在Android的消息机制中，其实有三种消息: <strong>普通消息</strong>、<strong>异步消息</strong>及<strong>消息屏障</strong></p>
<p><strong>消息屏障</strong>也是一种消息，但是它的<code>target</code>为 null。可以通过<code>MessageQueue</code>中的<strong>postSyncBarrier</strong>方法发送一个消息屏障（该方法为私有，需要反射调用）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">postSyncBarrier</span><span class="params">(<span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="comment">// Enqueue a new sync barrier token.</span></span><br><span class="line">    <span class="comment">// We don&#x27;t need to wake the queue because the purpose of a barrier is to stall it.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">token</span> <span class="operator">=</span> mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> Message.obtain();</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token;</span><br><span class="line">        <span class="comment">//按照时间顺序将消息插入到消息队列中</span></span><br><span class="line">         ......</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在消息循环中，如果<strong>第一条</strong>消息就是<strong>屏障消息</strong>，就往后遍历，看看<strong>有没有异步消息</strong>: 如果没有，则无限<strong>休眠</strong>，等待被唤醒 如果<strong>有</strong>，就看离这个消息被触发时间还有多久，<strong>设置一个超时时间</strong>，继续休眠</p>
<p>异步消息和普通消息一样，只不过它被设置<code>setAsynchronous</code> 为<strong>true</strong>。有了这个标志位，消息机制会对它有些特别的处理，使<strong>异步消息具有优先处理的权利</strong>。</p>
<p>这时候我们回顾将消息添加到消息队列中时，可以发现， <em><strong>其实并不是每一次添加消息时，都会唤醒线程</strong></em> 。 当该消息插入到队列头时，会唤醒该线程； 当该消息 <em><strong>没有插入到队列头</strong></em> ，但队列 <em><strong>头是屏障</strong></em> ，且该消息是队列中 <strong>靠前</strong>的一个<strong>异步消息</strong>，则会<strong>唤醒</strong>线程，执行该消息。</p>
<p>调用<code>MessageQueue.removeSyncBarrier</code> 方法可以移除指定的消息屏障。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d3ad2ec6fb9a07ef81a4460">掘金 - Android Handler那些事儿</a></p>
<h3 id="Handler-队列优化"><a href="#Handler-队列优化" class="headerlink" title="Handler 队列优化"></a>Handler 队列优化</h3><h4 id="互斥消息取消"><a href="#互斥消息取消" class="headerlink" title="互斥消息取消"></a>互斥消息取消</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Category</span>&#123;</span><br><span class="line">RENDER,START,STOP</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MessageType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> Message.obtain(handler, STOP_MAP.what);</span><br><span class="line">        message.obj = STOP_MAP.category;</span><br><span class="line">        <span class="keyword">for</span> (Category category : Category.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span>（category.ordinal() &lt;= STOP_MAP.category.ordinal()）&#123;</span><br><span class="line">            <span class="comment">//当满足条件时清除其他消息，有优先级</span></span><br><span class="line">        handler.removeCallbacksAndMessages(category);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            handler.sendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复用消息"><a href="#复用消息" class="headerlink" title="复用消息"></a>复用消息</h4><p>调用<strong>Message</strong> 的**obtain()**方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">     * avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="literal">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MessageQueue.<span class="type">IdleHandler</span> <span class="variable">idleHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>.IdleHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">queueIdle</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//处理事情</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//false 代表只在空闲时执行一次,执行完移除,true会多次触发</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(idleHandler);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>Glide 3.X</code>中用此方法来移除gc调用的图片弱引用，4.X中移除。</p>
<h4 id="独享Looper"><a href="#独享Looper" class="headerlink" title="独享Looper"></a>独享Looper</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">HandlerThread</span> <span class="variable">handlerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;Token-Thread&quot;</span>)</span><br><span class="line">handlerThread.start();</span><br><span class="line"><span class="keyword">private</span> <span class="type">Handler</span> <span class="variable">tokenHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(handlerThread.getLooper());</span><br></pre></td></tr></table></figure>


<h2 id="更新日志："><a href="#更新日志：" class="headerlink" title="更新日志："></a>更新日志：</h2><table>
<thead>
<tr>
<th>版本</th>
<th>时间</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>version 0.1</td>
<td>2020年05月22日17:50:30</td>
<td>初版整理常用复习知识点</td>
</tr>
</tbody></table>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='http://music.163.com/song/media/outer/url?id=723174.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='true'
        data-ci='bea144b43eefb358981c'
        data-cs='a36c22fec87740cbe5e17b541731a652d8e2785d'
        data-r='gitalk'
        data-o='ArnoFrost'
        data-a='ArnoFrost'
        data-d='true'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Handler%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">Handler常见知识总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">主要组件：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E7%AE%80%E5%8D%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.</span> <span class="toc-text">过程简单概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">具体分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">初始化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">发送消息过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A5%E9%98%9F%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">入队过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E9%98%9F%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">出队过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.3.5.</span> <span class="toc-text">分发事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.3.6.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">常见问题与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Android%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9EUI%E7%BA%BF%E7%A8%8B%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI"><span class="toc-number">1.4.1.</span> <span class="toc-text">Android中为什么非UI线程不能更新UI?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UI%E7%BA%BF%E7%A8%8B%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">UI线程工作机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88UI%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">为什么UI线程设计成不安全的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9EUI%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AE%9A%E4%B8%8D%E8%83%BD%E6%9B%B4%E6%96%B0UI%E5%90%97%EF%BC%9F"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">非UI线程一定不能更新UI吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">Handler常见的内存泄露问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler-postDelay%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E9%9D%A0%EF%BC%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">Handler postDelay方法是否可靠？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#loop-%E5%88%86%E6%9E%90"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">loop()分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Handler%E4%B8%8D%E4%BC%9A%E9%98%BB%E5%A1%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E9%80%A0%E6%88%90ANR-%EF%BC%88Looper%E6%AD%BB%E5%BE%AA%E7%8E%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4CPU%E5%8D%A0%E7%94%A8%E7%8E%87%E5%BE%88%E9%AB%98%EF%BC%9F%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">为什么Handler不会阻塞主线程造成ANR?（Looper死循环为什么不会导致CPU占用率很高？）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ANR"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">ANR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ANR-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.4.1.1.</span> <span class="toc-text">ANR 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E4%B8%80%E6%AC%A1ANR%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.4.1.1.1.</span> <span class="toc-text">分析一次ANR过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Looper-loop"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">Looper.loop()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%B1%8F%E9%9A%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.5.</span> <span class="toc-text">消息屏障是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handler-%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.6.</span> <span class="toc-text">Handler 队列优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E6%B6%88%E6%81%AF%E5%8F%96%E6%B6%88"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">互斥消息取消</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E6%B6%88%E6%81%AF"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">复用消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IdleHandler"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">IdleHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E4%BA%ABLooper"><span class="toc-number">1.4.6.4.</span> <span class="toc-text">独享Looper</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">更新日志：</span></a></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<!-- Google Analytics -->
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-M1XD2J0EJY', 'auto');
  ga('send', 'pageview');
</script>
<!-- End Google Analytics -->


</html>
